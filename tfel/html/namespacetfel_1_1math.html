<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <title>tfel: tfel::math Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">The TFEL project </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetfel.html">tfel</a></li><li class="navelem"><a class="el" href="namespacetfel_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tfel::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains various classes and functions dÃ©fining mathematical objects and numerical algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1ieee754"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1ieee754.html">ieee754</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1internals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1internals.html">internals</a></td></tr>
<tr class="memdesc:namespacetfel_1_1math_1_1internals"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains classes, functions, metafunctions and data structures that are used internally in the <code><a class="el" href="namespacetfel_1_1math.html" title="This namespace contains various classes and functions dÃ©fining mathematical objects and numerical alg...">tfel::math</a></code> namespace and that are meant to be used by the end user. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1abs_compare.html">absCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_abs_sum.html">AbsSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit__.html">AddUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_6e9b48f5d91e090539faa59a6ac8ad5d.html">AddUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_da6dcb20b504450056b1fd8385d8c613.html">AddUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, AP1 &gt;, std::integral_constant&lt; unsigned int, AP2 &gt;, std::integral_constant&lt; unsigned int, AP3 &gt;, std::integral_constant&lt; unsigned int, AP4 &gt;, std::integral_constant&lt; unsigned int, AP5 &gt;, std::integral_constant&lt; unsigned int, AP6 &gt;, std::integral_constant&lt; unsigned int, AP7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_anderson_base.html">AndersonBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for the Anderson accelation algorithm.  <a href="structtfel_1_1math_1_1_anderson_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1array__container.html">array_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_binary_operation.html">BinaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html">ComputeBinaryResult_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_compute_binary_result__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; MatrixTag, MatrixTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; MatrixTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; MatrixTag, VectorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, MatrixTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ST2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ST2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, T2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, T2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for scalar-t2tot2 operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, VectorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ST2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ST2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_dot_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, T2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for t2tot2-scalar operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, T2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>'s operation  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for T2toT2-T2toT2 operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for T2toT2-Tensor operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; VectorTag, MatrixTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; VectorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_dot_product_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag.html">ComputeObjectTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction which compute the tag. associated with a given type.  <a href="structtfel_1_1math_1_1_compute_object_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag__.html">ComputeObjectTag_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper metafunction for tag computing.  <a href="structtfel_1_1math_1_1_compute_object_tag__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for functions.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for unary operators.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html">ComputeObjectTag_&lt; Type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for scalars.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_special_s_t2_s_t2_values.html">ComputeSpecialST2ST2Values</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_special_s_t2_s_t2_values_3_011u_00_01_t_01_4.html">ComputeSpecialST2ST2Values&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_special_s_t2_s_t2_values_3_012u_00_01_t_01_4.html">ComputeSpecialST2ST2Values&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_special_s_t2_s_t2_values_3_013u_00_01_t_01_4.html">ComputeSpecialST2ST2Values&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_matrix_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; MatrixTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html">ComputeUnaryResult_&lt; ScalarTag, TagOp, A, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial Specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a> for scalars.  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_stensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; StensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></code> for <code>T2toT2</code>'s object  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_tensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; TensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_vector_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; VectorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html">ConceptRebind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_type_01_4.html">ConceptRebind&lt; MatrixTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for matrices  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_s_t2_tag_00_01_t_01_4.html">ConceptRebind&lt; ST2toST2Tag, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; ST2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html">ConceptRebind&lt; StensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toST2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for T2toST2  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html">ConceptRebind&lt; TensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html">ConceptRebind&lt; VectorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for vectors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_s_t2to_s_t2_view_expr.html">ConstST2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_stensor_view_expr.html">ConstStensorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t2to_s_t2_view_expr.html">ConstT2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t_matrix_view_expr.html">ConstTMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t_vector_view_expr.html">ConstTVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html">ConvertLogarithmicStrainTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent moduli.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html">ConvertLogarithmicStrainTangentOperator&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html" title="A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent...">ConvertLogarithmicStrainTangentOperator</a> in 1D.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_t2to_s_t2_to_s_t2to_s_t2_expr.html">ConvertT2toST2ToST2toST2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste.html">Cste</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste_base.html">CsteBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_roots.html">CubicRoots</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline.html">CubicSpline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_abscissa_vector_size.html">CubicSplineInvalidAbscissaVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_inputs.html">CubicSplineInvalidInputs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_ordinate_vector_size.html">CubicSplineInvalidOrdinateVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_null_pivot.html">CubicSplineNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_uninitialised.html">CubicSplineUninitialised</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_unordered_abscissa_vector.html">CubicSplineUnorderedAbscissaVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_diadic_product_operation.html">DiadicProductOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_difference_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html">DifferenceRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html" title="an adaptator to random access iterator ">DifferenceRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product.html">dotProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2...">dotProduct</a> calculates a generalized inner product of the ranges [first1,first1+N) and [first2,first2+N)  <a href="structtfel_1_1math_1_1dot_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product.html">DotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html">dotProduct&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation used to end recursion when using the <a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2...">dotProduct</a> algorithm.  <a href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product_3_010u_00_01_m_01_4.html">DotProduct&lt; 0u, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is aimed to used for mathematical objects whose size are known at compile-tme.  <a href="structtfel_1_1math_1_1_empty_run_time_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_evaluator.html">Evaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class in charge of handling a function defined by a string.  <a href="structtfel_1_1math_1_1_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation. ">Expr</a> object allows the lazy evaluation of a mathematical operation.  <a href="structtfel_1_1math_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_binary_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, BinaryOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_diadic_product_operation_3_01_t1_00_01_t2_01_4_01_4.html">Expr&lt; ResultType, DiadicProductOperation&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_object_scalar_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ObjectScalarOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_scalar_object_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ScalarObjectOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_unary_operation_3_01_t1_00_01_op_01_4_01_4.html">Expr&lt; ResultType, UnaryOperation&lt; T1, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_const_s_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; st2tost2&lt; N, T &gt;, ConstST2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_from_tiny_matrix_0b65a96da2fd434c4504b3ad91687014.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2FromTinyMatrixView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_from_tiny_matrix_5d7d9d3c651568fadb2b23032443bc0e.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2FromTinyMatrixViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_const_stensor_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; stensor&lt; N, T &gt;, ConstStensorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_colum651beb94bb796f0fe0a96869c319fe81.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_columd61eb7230bf5bfeb00090d6ffa1ee624.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_row_vcd7e9933f829c50fdd14867fa642a5cf.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_row_vbb8e834eeff4203ecedacf1c63b36404.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_vector_view_82cbbfb10b414b56cd3432d72fc32068.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; stensor&lt; N, T &gt;, StensorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_const_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tost2&lt; N, T &gt;, ConstT2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tost2&lt; N, T &gt;, T2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_column_90e6c5a0b22204e71f019b056042d9da.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_column_37a4f4b582a70566ea3d5354f25cf96a.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_row_vie58f9ba98184126761fca3cc9fb82c484.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_row_vie197da9ef818a07949020f8bf74d87451.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_vector_view_excd0765c041f2aa70c9fbb4df0aebf446.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_value_type_01_4_00_01_tensor_view_from_stensor_expr_3_01_t_01_4_01_4.html">Expr&lt; tensor&lt; N, ValueType &gt;, TensorViewFromStensorExpr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_013u_00_013u_00_01_tensor_num_type_3_01typename_01std_1a6b3b2f2fa0c2c526deabfddf31356c.html">Expr&lt; tmatrix&lt; 3u, 3u, TensorNumType&lt; typename std::decay&lt; TensorType &gt;::type &gt; &gt;, MatrixViewFromTensorExpr&lt; TensorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_const_t_matrix_view_ex4ac13d0660d557667e9fac67277955dd.html">Expr&lt; tmatrix&lt; N, M, T &gt;, ConstTMatrixViewExpr&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_t_matrix_view_expr_3_01_n_00_01_m_00_01_t_01_4_01_4.html">Expr&lt; tmatrix&lt; N, M, T &gt;, TMatrixViewExpr&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_const_t_vector_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; tvector&lt; N, T &gt;, ConstTVectorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_tiny_vector_from_tiny_vector_ve4426bd9028d65ef49b0af19a58b2d0c.html">Expr&lt; tvector&lt; N, T &gt;, TinyVectorFromTinyVectorViewExpr&lt; N, Mn, In, T, b &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; tvector&lt; N, T &gt;, TVectorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_nn_00_01stensor_3_01_n_00_01_t_01_4_01_4_00_01_tiny03ab00e9f46540130ac2586b9b2c8886.html">Expr&lt; tvector&lt; Nn, stensor&lt; N, T &gt; &gt;, TinyVectorOfStensorFromTinyVectorViewExpr&lt; N, Mn, In, Nn, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_nn_00_01tvector_3_01_n_00_01_t_01_4_01_4_00_01_tinyc4b64e635bd18497f53043592d62e75a.html">Expr&lt; tvector&lt; Nn, tvector&lt; N, T &gt; &gt;, TinyVectorOfTinyVectorFromTinyVectorViewExpr&lt; N, Mn, In, Nn, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_base.html">ExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_with_array_access_operator.html">ExprWithArrayAccessOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper class which defines array-like access operator by relying on the operator() of the derived class.  <a href="structtfel_1_1math_1_1_expr_with_array_access_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging.html">FactorizedKriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d1_d.html">FactorizedKriging1D1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d2_d.html">FactorizedKriging1D2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d3_d.html">FactorizedKriging1D3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_anderson.html">FAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_fct_object_random_access_const_iterator.html">FctObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a container for finite size array. This is mainly equivalent to the array class of C++11.  <a href="structtfel_1_1math_1_1fsarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt.html">FSLevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable.html">FSLevenbergMarquardtVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable_3_011u_00_01_t_01_4.html">FSLevenbergMarquardtVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_density.html">GeometricDiscretizationInvalidDensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_length.html">GeometricDiscretizationInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_number_of_elements.html">GeometricDiscretizationInvalidNumberOfElements</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_integer_evaluator.html">IntegerEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_invalid_time_step_exception.html">InvalidTimeStepException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_convertible_to_qt_no_unit.html">IsConvertibleToQtNoUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_qt_scalar_operation_valid.html">IsQtScalarOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_scalar_vector_operation_valid.html">IsScalarVectorOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_t_vector_scalar_operation_valid.html">IsTVectorScalarOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging.html">Kriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging1_d.html">Kriging1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging2_d.html">Kriging2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging3_d.html">Kriging3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model.html">KrigingDefaultModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_011u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 1u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_012u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 2u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_013u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 3u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_nugget_model.html">KrigingDefaultNuggetModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_insufficient_data.html">KrigingErrorInsufficientData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_invalid_length.html">KrigingErrorInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_no_data_specified.html">KrigingErrorNoDataSpecified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_model_adaptator.html">KrigingModelAdaptator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_piece_wise_linear_model1_d.html">KrigingPieceWiseLinearModel1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_utilities.html">KrigingUtilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable.html">KrigingVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable_3_011u_00_01_t_01_4.html">KrigingVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html">LeftCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_evaluator_wrapper.html">LevenbergMarquardtEvaluatorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_external_function_wrapper.html">LevenbergMarquardtExternalFunctionWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_function_wrapper.html">LevenbergMarquardtFunctionWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_decomp.html">LUDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_exception.html">LUException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_invalid_matrix_size.html">LUInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_matrix_not_square.html">LUMatrixNotSquare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_determinant.html">LUNullDeterminant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_pivot.html">LUNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_solve.html">LUSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_unmatched_size.html">LUUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_divergence_exception.html">MathDivergenceException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_exception.html">MathException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_run_time_exception.html">MathRunTimeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities.html">matrix_utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities_3_010u_00_01_m_00_01_m__init_01_4.html">matrix_utilities&lt; 0u, M, M_init &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities_3_01_n_00_010u_00_01_m__init_01_4.html">matrix_utilities&lt; N, 0u, M_init &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_concept.html">MatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to model the concept of matrices. Here we use the curiously recurring template pattern.  <a href="structtfel_1_1math_1_1_matrix_concept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_properties.html">MatrixProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_tag.html">MatrixTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise matrices.  <a href="structtfel_1_1math_1_1_matrix_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_traits.html">MatrixTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class for matrices.  <a href="structtfel_1_1math_1_1_matrix_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">MatrixTraits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_traits_3_01matrix_3_01_t_01_4_01_4.html">MatrixTraits&lt; matrix&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for matrixs.  <a href="structtfel_1_1math_1_1_matrix_traits_3_01matrix_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html">MatrixTraits&lt; tmatrix&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrixs.  <a href="structtfel_1_1math_1_1_matrix_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_type.html">MatrixType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">MatrixType&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle.html">MatrixVectorHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_7459a53bfb61de9ef0633aa0de6b8077.html">MatrixVectorHandle&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_0a6d426fa0cba568d50d019d6432066a6.html">MatrixVectorHandle&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html">MatrixViewFromTensorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_maximum_number_of_iterations_reached_exception.html">MaximumNumberOfIterationsReachedException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_minus_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpMinus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_plus_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpPlus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_object_scalar_operation.html">ObjectScalarOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ObjectScalarRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ObjectScalarRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_and.html">OpAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_or.html">OpOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_permutation.html">Permutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power.html">Power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_generator.html">PowerGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector.html">PowerImplSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector_3_01_n_00_011u_01_4.html">PowerImplSelector&lt; N, 1u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector_3_01_n_00_012u_01_4.html">PowerImplSelector&lt; N, 2u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_neg.html">PowerNeg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure to compute the negative power of a number.  <a href="structtfel_1_1math_1_1_power_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_pos.html">PowerPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_010u_01_4.html">PowerPos&lt; 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_011u_01_4.html">PowerPos&lt; 1u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_012u_01_4.html">PowerPos&lt; 2u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_013u_01_4.html">PowerPos&lt; 3u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl.html">PowerPosImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_010u_00_010u_01_4.html">PowerPosImpl&lt; 0u, 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_010u_00_01_m_01_4.html">PowerPosImpl&lt; 0u, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_01_n_00_010u_01_4.html">PowerPosImpl&lt; N, 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_sqrt_neg.html">PowerSqrtNeg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_sqrt_pos.html">PowerSqrtPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_pow_unit__.html">PowUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_pow_unit___3_01_n_00_01_d_00_01_unit_3_01std_1_1integral__constant_3_01in4b8c5f857d933d72fce243da4ec3d4ab.html">PowUnit_&lt; N, D, Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_decomp.html">QRDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_exception.html">QRException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_invalid_matrix_size.html">QRInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_null_pivot.html">QRNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_unmatched_size.html">QRUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1qt.html">qt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes numbers with unit. qt must be has efficient and simple to use that standard numerical types.  <a href="classtfel_1_1math_1_1qt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1qt_3_01_no_unit_00_01_t_01_4.html">qt&lt; NoUnit, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization in case NoUnit. This class shall be implicitly convertible to T and T must be convertible to qt&lt;T,nounit&gt;.  <a href="classtfel_1_1math_1_1qt_3_01_no_unit_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01cadna_1_1numeric4647a7dbf40f75c8d11b614983725a44.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01_t2_00_01_op_01_4.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, T2, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for substraction of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for addition of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_div_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit2, T2 &gt;, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for division of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_div_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit2, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for multiplication of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> and <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_t1_00_01cadna_1_1numeric__type_3_01_t2_01_4_00_01_op_01_4.html">ResultType&lt; T1, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_00_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; M, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type__.html">ResultType_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_me9ae6de7965859d27ef03434bc6c7f52.html">ResultType_&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_me9ae6de7965859d27ef03434bc6c7f52.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_ma0e653c3d66a6288b06d91a432e1fec6.html">ResultType_&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_ma0e653c3d66a6288b06d91a432e1fec6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_matrix_tag_00_01_scal_00_01tmatrix_3_08cda50d859ca3ee73ffea7c032d22569.html">ResultType_&lt; ScalarTag, MatrixTag, Scal, tmatrix&lt; N, M, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_matrix_tag_00_01_scal_00_01tmatrix_3_08cda50d859ca3ee73ffea7c032d22569.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_scal_00_01st2tosc1d0c5b514bcf06bbf7c906ae91b01a7.html">ResultType_&lt; ScalarTag, ST2toST2Tag, Scal, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_scal_00_01st2tosc1d0c5b514bcf06bbf7c906ae91b01a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scal_00_01st2tot2_a1150ab073afbc19ae903b1717c8dc7f.html">ResultType_&lt; ScalarTag, ST2toT2Tag, Scal, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scal_00_01st2tot2_a1150ab073afbc19ae903b1717c8dc7f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_stensor_tag_00_01_scal_00_01stensor_3_0acf953d529361483f81aa0448d57284.html">ResultType_&lt; ScalarTag, StensorTag, Scal, stensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_stensor_tag_00_01_scal_00_01stensor_3_0acf953d529361483f81aa0448d57284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal_00_01t2tost2_f15a598792b8786ebabdc98be50cd8a3.html">ResultType_&lt; ScalarTag, T2toST2Tag, Scal, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal_00_01t2tost2_f15a598792b8786ebabdc98be50cd8a3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scal_00_01t2tot2_3_0dec645c7ae871308e02efe1b28649eae.html">ResultType_&lt; ScalarTag, T2toT2Tag, Scal, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scal_00_01t2tot2_3_0dec645c7ae871308e02efe1b28649eae.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_tensor_tag_00_01_scal_00_01tensor_3_014e8854cb7ff9ea600a3a10ef3d4a31b1.html">ResultType_&lt; ScalarTag, TensorTag, Scal, tensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_tensor_tag_00_01_scal_00_01tensor_3_014e8854cb7ff9ea600a3a10ef3d4a31b1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01tvector_3_06d89c62f22b8c70bd66aa33a9632978d.html">ResultType_&lt; ScalarTag, VectorTag, Scal, tvector&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01tvector_3_06d89c62f22b8c70bd66aa33a9632978d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01vector_3_01_t_01_4_00_01_op_mult_01_4.html">ResultType_&lt; ScalarTag, VectorTag, Scal, vector&lt; T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01vector_3_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0a614054aff72840d9e550611497117e8.html">ResultType_&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0a614054aff72840d9e550611497117e8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0521cc28819535bc0ad60c9fe3cfcc369.html">ResultType_&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0521cc28819535bc0ad60c9fe3cfcc369.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0a746b811fc90e8eb495efd24d62f24d5.html">ResultType_&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0a746b811fc90e8eb495efd24d62f24d5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0c5c9e23c9f092d87a43a222428f714b5.html">ResultType_&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0c5c9e23c9f092d87a43a222428f714b5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_02b6ad26cf90e4198148ca4a8058223f.html">ResultType_&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_02b6ad26cf90e4198148ca4a8058223f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_819aced7a8169610cc89d37a357ed134.html">ResultType_&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_819aced7a8169610cc89d37a357ed134.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00c1fbf515130e142b798bc63e27ad3d2.html">ResultType_&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00c1fbf515130e142b798bc63e27ad3d2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00984a9c8e14878213cf153a46182359b.html">ResultType_&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00984a9c8e14878213cf153a46182359b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_tdccd9191702872cc2e27780865169c3d.html">ResultType_&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_tdccd9191702872cc2e27780865169c3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_t73b3cb6d26b5678c356802fc2084de3a.html">ResultType_&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_t73b3cb6d26b5678c356802fc2084de3a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_48e165fb69a0785a902518a3dc6a0bd8.html">ResultType_&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_48e165fb69a0785a902518a3dc6a0bd8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_a879824024c9915aab6ff978413fd8dd.html">ResultType_&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_a879824024c9915aab6ff978413fd8dd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t8e27333d965750e6f98ae80503d13d97.html">ResultType_&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t8e27333d965750e6f98ae80503d13d97.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t81b86aee6785def0b1c16375a794c6f5.html">ResultType_&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t81b86aee6785def0b1c16375a794c6f5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_div_01_4.html">ResultType_&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_div_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_mult_01_4.html">ResultType_&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html">RightCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta2.html">RungeKutta2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_runge_kutta4.html">RungeKutta4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta42.html">RungeKutta42</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta54.html">RungeKutta54</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check.html">RunTimeCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check_3_01_empty_run_time_properties_01_4.html">RunTimeCheck&lt; EmptyRunTimeProperties &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_check_failure.html">RuntimeCheckFailure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_object_operation.html">ScalarObjectOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ScalarObjectRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ScalarObjectRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_tag.html">ScalarTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise scalars.  <a href="structtfel_1_1math_1_1_scalar_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_singular_jacobian_exception.html">SingularJacobianException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tost2__base.html">st2tost2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1st2tost2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view.html">ST2toST2FromTinyMatrixView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view2.html">ST2toST2FromTinyMatrixView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view2_expr.html">ST2toST2FromTinyMatrixView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view_expr.html">ST2toST2FromTinyMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_s_t2to_s_t2_product_expr.html">ST2toST2ST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_stensor_product_expr.html">ST2toST2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_t2to_s_t2_product_expr.html">ST2toST2T2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html">ST2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">ST2toST2Traits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html">ST2toST2Traits&lt; st2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a></code>.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">ST2toST2Type&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_view_expr.html">ST2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tot2__base.html">st2tot2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1st2tot2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_s_t2to_s_t2_product_expr.html">ST2toT2ST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_stensor_product_expr.html">ST2toT2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_t2to_s_t2_product_expr.html">ST2toT2T2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_tag.html">ST2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_traits.html">ST2toT2Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">ST2toT2Traits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_traits_3_01st2tot2_3_01_n_00_01_t_01_4_01_4.html">ST2toT2Traits&lt; st2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_type.html">ST2toT2Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">ST2toT2Type&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor__base.html">stensor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1stensor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor__common.html">stensor_common</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure inherited by the <code>stensor</code> class  <a href="structtfel_1_1math_1_1stensor__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size.html">StensorDimeToSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the number of components of an stensor given the spatial dimension used. The correspondance between these two numbers is given by the following table:  <a href="structtfel_1_1math_1_1_stensor_dime_to_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_011u_01_4.html">StensorDimeToSize&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_012u_01_4.html">StensorDimeToSize&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_013u_01_4.html">StensorDimeToSize&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view.html">StensorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view2.html">StensorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view2_expr.html">StensorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view_expr.html">StensorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view.html">StensorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view2.html">StensorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view2_expr.html">StensorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view_expr.html">StensorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_vector_view.html">StensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_vector_view_expr.html">StensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr1_d.html">StensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr2_d.html">StensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr3_d.html">StensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_stensor_product_expr_base.html">StensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_left_derivative_expr.html">StensorProductLeftDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_right_derivative_expr.html">StensorProductRightDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime.html">StensorSizeToDime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the spatial dimension given the number of components of a stensor.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_013u_01_4.html">StensorSizeToDime&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_014u_01_4.html">StensorSizeToDime&lt; 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_016u_01_4.html">StensorSizeToDime&lt; 6u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_016u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_square_derivative_expr.html">StensorSquareDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_s_t2to_s_t2_product_expr.html">StensorST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative.html">StensorSymmetricProductDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_011u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_012u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_013u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_t2to_s_t2_product_expr.html">StensorT2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html">StensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise stensors.  <a href="structtfel_1_1math_1_1_stensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">StensorTraits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_traits_3_01stensor_3_01_n_00_01_t_01_4_01_4.html">StensorTraits&lt; stensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">StensorType&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_view_expr.html">StensorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_strided_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html">StridedRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html" title="an adaptator to random access iterator ">StridedRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit__.html">SubUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_43e53766f29d0aabc5d40527d3dc5dc5.html">SubUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_be4082d880dae6c274e4fa573469b6a9.html">SubUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, AP1 &gt;, std::integral_constant&lt; unsigned int, AP2 &gt;, std::integral_constant&lt; unsigned int, AP3 &gt;, std::integral_constant&lt; unsigned int, AP4 &gt;, std::integral_constant&lt; unsigned int, AP5 &gt;, std::integral_constant&lt; unsigned int, AP6 &gt;, std::integral_constant&lt; unsigned int, AP7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tost2__base.html">t2tost2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1t2tost2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_s_t2to_t2_product_expr.html">T2toST2ST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_t2to_t2_product_expr.html">T2toST2T2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html">T2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>.  <a href="structtfel_1_1math_1_1_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tensor_product_expr.html">T2toST2TensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">T2toST2Traits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits_3_01t2tost2_3_01_n_00_01_t_01_4_01_4.html">T2toST2Traits&lt; t2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">T2toST2Type&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_view_expr.html">T2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tot2__base.html">t2tot2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1t2tot2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_s_t2to_t2_product_expr.html">T2toT2ST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_t2to_t2_product_expr.html">T2toT2T2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html">T2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="structtfel_1_1math_1_1_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tensor_product_expr.html">T2toT2TensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">T2toT2Traits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits_3_01t2tot2_3_01_n_00_01_t_01_4_01_4.html">T2toT2Traits&lt; t2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">T2toT2Type&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tensor__base.html">tensor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tensor or classes acting like tensor.  <a href="structtfel_1_1math_1_1tensor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_change_basis.html">TensorChangeBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure in charge of changing the basis of a tensor  <a href="structtfel_1_1math_1_1_tensor_change_basis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_change_basis_3_011u_00_01_t_01_4.html">TensorChangeBasis&lt; 1u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_tensor_change_basis_3_011u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_change_basis_3_012u_00_01_t_01_4.html">TensorChangeBasis&lt; 2u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_tensor_change_basis_3_012u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_change_basis_3_013u_00_01_t_01_4.html">TensorChangeBasis&lt; 3u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_tensor_change_basis_3_013u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size.html">TensorDimeToSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the number of components of an tensor given the spatial dimension used. The correspondance between these two numbers is given by the following table:  <a href="structtfel_1_1math_1_1_tensor_dime_to_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_011u_01_4.html">TensorDimeToSize&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_012u_01_4.html">TensorDimeToSize&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_013u_01_4.html">TensorDimeToSize&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view.html">TensorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view2.html">TensorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view2_expr.html">TensorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view_expr.html">TensorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view.html">TensorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view2.html">TensorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view2_expr.html">TensorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view_expr.html">TensorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_vector_view.html">TensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_vector_view_expr.html">TensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html">TensorInvalidIndexesException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid indexes were given  <a href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html">TensorInvalidIndexException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid index is given  <a href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html">TensorInvalidInitializerListSizeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if an std::initializer_list with no appropriate size is affected to a tensor.  <a href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr1_d.html">TensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr2_d.html">TensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr3_d.html">TensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr_base.html">TensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_left_derivative_expr.html">TensorProductLeftDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_right_derivative_expr.html">TensorProductRightDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime.html">TensorSizeToDime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the spatial dimension given the number of components of a tensor.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_013u_01_4.html">TensorSizeToDime&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_015u_01_4.html">TensorSizeToDime&lt; 5u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_015u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_019u_01_4.html">TensorSizeToDime&lt; 9u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_019u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_s_t2to_t2_product_expr.html">TensorST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_t2to_t2_product_expr.html">TensorT2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_tag.html">TensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class to characterize tensors.  <a href="structtfel_1_1math_1_1_tensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a traits class for tensors. This shall be specialised for classes implementing the tensor concept (  <a href="structtfel_1_1math_1_1_tensor_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">TensorTraits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_tensor_traits.html" title="a traits class for tensors. This shall be specialised for classes implementing the tensor concept ( ...">TensorTraits</a></code> metafunction for structure resulting from the expression template engine.  <a href="structtfel_1_1math_1_1_tensor_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_traits_3_01tensor_3_01_n_00_01_t_01_4_01_4.html">TensorTraits&lt; tensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr1_d.html">TensorTransposeExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr2_d.html">TensorTransposeExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr3_d.html">TensorTransposeExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr_base.html">TensorTransposeExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a meta function returning the concrete tensor type that the given type is meant to represent.  <a href="structtfel_1_1math_1_1_tensor_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">TensorType&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_tensor_type.html" title="a meta function returning the concrete tensor type that the given type is meant to represent...">TensorType</a></code> metafunction for structure resulting from the expression template engine.  <a href="structtfel_1_1math_1_1_tensor_type_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor.html">TensorViewFromStensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor_expr.html">TensorViewFromStensorExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_invert.html">TinyMatrixInvert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve.html">TinyMatrixSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_011u_00_01_t_01_4.html">TinyMatrixSolve&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_012u_00_01_t_01_4.html">TinyMatrixSolve&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_013u_00_01_t_01_4.html">TinyMatrixSolve&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_base.html">TinyMatrixSolveBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_tiny_newton_raphson.html">TinyNewtonRaphson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Newton-Raphson algorithm when the size N of the problem is known at compile-time. One wish to solve the problem: </p><p class="formulaDsp">
\[\vec{f}\left(\vec{x}\right)=\vec{0}\]
</p>
<p> where \(\displaystyle\vec{f}:R^{N}\rightarrow R^{N}\). if \(\displaystyle\vec{x}^{n}\) is an estimation of the solution, \(\displaystyle\vec{x}^{n+1}\) will be given by: </p><p class="formulaDsp">
\[\displaystyle\vec{x}^{n+1}=\vec{x}^{n}-J^{-1}\vec{f}\left(\vec{x}^{n}\right)\]
</p>
<p> where \( J \) is the jacobien matrix of \( f \) at \(\left(\displaystyle\vec{x}^{n}\right)\) defined by \( J_{ij} = \displaystyle\frac{\displaystyle\partial f_{i}}{\displaystyle\partial x_{j}}\).  <a href="classtfel_1_1math_1_1_tiny_newton_raphson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_tiny_newton_raphson_3_011u_00_01_t_00_01_f_01_4.html">TinyNewtonRaphson&lt; 1u, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_permutation.html">TinyPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view.html">TinyVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view.html">TinyVectorOfStensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view_expr.html">TinyVectorOfStensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view.html">TinyVectorOfTinyVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorOfTinyVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__base.html">tmatrix_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tmatrix or classes acting like tmatrix.  <a href="structtfel_1_1math_1_1tmatrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__column__view.html">tmatrix_column_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__column__view__expr.html">tmatrix_column_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__column__view.html">tmatrix_const_column_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__row__view.html">tmatrix_const_row_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__row__view__expr.html">tmatrix_const_row_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__submatrix__view.html">tmatrix_const_submatrix_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__submatrix__view__expr.html">tmatrix_const_submatrix_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__row__view.html">tmatrix_row_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__row__view__expr.html">tmatrix_row_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__submatrix__view.html">tmatrix_submatrix_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__submatrix__view__expr.html">tmatrix_submatrix_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_const_column_view.html">TMatrixConstColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html">TMatrixTVectorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for the computation of product of a tiny matrix and a tiny vector.  <a href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_view_expr.html">TMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tvector__base.html">tvector_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tvector or classes acting like tvector.  <a href="structtfel_1_1math_1_1tvector__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mat4a0fcf4621ebce4274a9b65ffa345efc.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_matc3dae03e360ec0e0492bcefc382b8706.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mat5c97a6f3fba398c0a730ce040ae98f7a.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mata4a7c60f114e3a6cf7250d818379ec7f.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_vecf7cd59d23a0361aaddbc577239d6a49e.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view.html">TVectorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view2.html">TVectorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view2_expr.html">TVectorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view_expr.html">TVectorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view.html">TVectorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view2.html">TVectorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view2_expr.html">TVectorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view_expr.html">TVectorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_vector_view.html">TVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_vector_view_expr.html">TVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_t_matrix_expr.html">TVectorTMatrixExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_view_expr.html">TVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_u_anderson.html">UAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html">UmatNormaliseTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html">UmatNormaliseTangentOperatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D.  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 2u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 3u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operation.html">UnaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operator_tag.html">UnaryOperatorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise operators.  <a href="structtfel_1_1math_1_1_unary_operator_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01cadna_1_1numeric__type_3_01_t_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; cadna::numeric_type&lt; T &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01double_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; double, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01float_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; float, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01long_01double_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; long double, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01double_01_4_01_4_00_061d6b5a193fd75b770af8793d45c486d.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01float_01_4_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; float &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01long_01double_01_4_015cb1689c54c69868d2635b7dded33ef6.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; long double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; stensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tmatrix&lt; N, M, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tvector&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01vector_3_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; vector&lt; T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type__.html">UnaryResultType_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_unary_result_type__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_00_01std_1_1inte22245c37637fc2ae3e1f4d95f396757e.html">Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing resizable medium sized vector.  <a href="classtfel_1_1math_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_concept.html">VectorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle.html">VectorDotProductHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_01_4.html">VectorDotProductHandle&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_vector_matrix_handle.html">VectorMatrixHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_tag.html">VectorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise vectors.  <a href="structtfel_1_1math_1_1_vector_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab.html">vectorToTab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure copy a vector to an array.  <a href="structtfel_1_1math_1_1vector_to_tab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_010u_01_4.html">vectorToTab&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=0 to end the recursion.  <a href="structtfel_1_1math_1_1vector_to_tab_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_0110u_01_4.html">vectorToTab&lt; 10u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=10.  <a href="structtfel_1_1math_1_1vector_to_tab_3_0110u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_011u_01_4.html">vectorToTab&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=1.  <a href="structtfel_1_1math_1_1vector_to_tab_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_012u_01_4.html">vectorToTab&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=2.  <a href="structtfel_1_1math_1_1vector_to_tab_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_013u_01_4.html">vectorToTab&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=3.  <a href="structtfel_1_1math_1_1vector_to_tab_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_014u_01_4.html">vectorToTab&lt; 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=4.  <a href="structtfel_1_1math_1_1vector_to_tab_3_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_015u_01_4.html">vectorToTab&lt; 5u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=5.  <a href="structtfel_1_1math_1_1vector_to_tab_3_015u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_016u_01_4.html">vectorToTab&lt; 6u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=6.  <a href="structtfel_1_1math_1_1vector_to_tab_3_016u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_017u_01_4.html">vectorToTab&lt; 7u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=7.  <a href="structtfel_1_1math_1_1vector_to_tab_3_017u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_018u_01_4.html">vectorToTab&lt; 8u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structtfel_1_1math_1_1vector_to_tab.html" title="This structure copy a vector to an array. ">vectorToTab</a> class for N=8.  <a href="structtfel_1_1math_1_1vector_to_tab_3_018u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_019u_01_4.html">vectorToTab&lt; 9u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=9.  <a href="structtfel_1_1math_1_1vector_to_tab_3_019u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_traits.html">VectorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_traits_3_01_expr_3_01_t__type_00_01_operation_01_4_01_4.html">VectorTraits&lt; Expr&lt; T_type, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html">VectorTraits&lt; tvector&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvectors.  <a href="structtfel_1_1math_1_1_vector_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_traits_3_01vector_3_01_t_01_4_01_4.html">VectorTraits&lt; vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for the vector class.  <a href="structtfel_1_1math_1_1_vector_traits_3_01vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_type.html">VectorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_type_3_01_expr_3_01_result_00_01_operation_01_4_01_4.html">VectorType&lt; Expr&lt; Result, Operation &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_utilities.html">VectorUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class <a class="el" href="structtfel_1_1math_1_1_vector_utilities.html" title="the class VectorUtilities contains a set of functions to be applied to every item of a vector...">VectorUtilities</a> contains a set of functions to be applied to every item of a vector. Those functions are implemented recursively and inlined.  <a href="structtfel_1_1math_1_1_vector_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_utilities_3_010u_01_4.html">VectorUtilities&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partial specialisation for N=0 is used to end the recursion.  <a href="structtfel_1_1math_1_1_vector_utilities_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_vector_dot_product.html">VectorVectorDotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a> = <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt; ValueType &gt;</td></tr>
<tr class="memdesc:a037360e732078b2d8b6bee5f80a0c819"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>.  <a href="#a037360e732078b2d8b6bee5f80a0c819">More...</a><br /></td></tr>
<tr class="separator:a037360e732078b2d8b6bee5f80a0c819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813e0e126161b9c9aea3ce2b085eacc"><td class="memItemLeft" align="right" valign="top"><a id="a6813e0e126161b9c9aea3ce2b085eacc"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>&lt; std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoUnit</b></td></tr>
<tr class="separator:a6813e0e126161b9c9aea3ce2b085eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a></td></tr>
<tr class="memdesc:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mass unit.  <a href="#a0f6aaddfab53e1c567c1f210d3031d7f">More...</a><br /></td></tr>
<tr class="separator:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a></td></tr>
<tr class="memdesc:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Length unit.  <a href="#aeab4cd4dbbabfa81beade7e23a81aa9f">More...</a><br /></td></tr>
<tr class="separator:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1c4734361bfe475e361a040a1ece5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a></td></tr>
<tr class="memdesc:ad1f1c4734361bfe475e361a040a1ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Time unit.  <a href="#ad1f1c4734361bfe475e361a040a1ece5">More...</a><br /></td></tr>
<tr class="separator:ad1f1c4734361bfe475e361a040a1ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c502ed4a6dd50e17f17022f7327d74e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 1, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a></td></tr>
<tr class="memdesc:a4c502ed4a6dd50e17f17022f7327d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Ampere unit.  <a href="#a4c502ed4a6dd50e17f17022f7327d74e">More...</a><br /></td></tr>
<tr class="separator:a4c502ed4a6dd50e17f17022f7327d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a11fc25b0491377347962a2219cf7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a></td></tr>
<tr class="memdesc:aaf2a11fc25b0491377347962a2219cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Temperature unit.  <a href="#aaf2a11fc25b0491377347962a2219cf7">More...</a><br /></td></tr>
<tr class="separator:aaf2a11fc25b0491377347962a2219cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8b7684b7496f5c9bd09f2947b5b8d537">Kelvin</a></td></tr>
<tr class="memdesc:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Kelvin unit.  <a href="#a8b7684b7496f5c9bd09f2947b5b8d537">More...</a><br /></td></tr>
<tr class="separator:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f10c92636c52b23d750dc1d146992"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 1, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a></td></tr>
<tr class="memdesc:a6c9f10c92636c52b23d750dc1d146992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Candela unit.  <a href="#a6c9f10c92636c52b23d750dc1d146992">More...</a><br /></td></tr>
<tr class="separator:a6c9f10c92636c52b23d750dc1d146992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c96cecfa5347958619e2672a9e0e4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 0, 1 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a></td></tr>
<tr class="memdesc:af22c96cecfa5347958619e2672a9e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mole unit.  <a href="#af22c96cecfa5347958619e2672a9e0e4">More...</a><br /></td></tr>
<tr class="separator:af22c96cecfa5347958619e2672a9e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafc93655e0e08a3438947be78f1130"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0,-1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130">InvLength</a></td></tr>
<tr class="memdesc:a4cafc93655e0e08a3438947be78f1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvLength unit.  <a href="#a4cafc93655e0e08a3438947be78f1130">More...</a><br /></td></tr>
<tr class="separator:a4cafc93655e0e08a3438947be78f1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1838b2eecf37fb347a5efb709afed4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0,-1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9a1838b2eecf37fb347a5efb709afed4">InvTemperature</a></td></tr>
<tr class="memdesc:a9a1838b2eecf37fb347a5efb709afed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvTemperature unit.  <a href="#a9a1838b2eecf37fb347a5efb709afed4">More...</a><br /></td></tr>
<tr class="separator:a9a1838b2eecf37fb347a5efb709afed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec6d506c79e1d01840880bc03a54df4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4ec6d506c79e1d01840880bc03a54df4">Frequency</a></td></tr>
<tr class="memdesc:a4ec6d506c79e1d01840880bc03a54df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Frequency unit.  <a href="#a4ec6d506c79e1d01840880bc03a54df4">More...</a><br /></td></tr>
<tr class="separator:a4ec6d506c79e1d01840880bc03a54df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a></td></tr>
<tr class="memdesc:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Velocity unit.  <a href="#a6b4c6c3374a01fa6e86eadcf85cb55ed">More...</a><br /></td></tr>
<tr class="separator:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7809b7b7e3800ebc6fea939690938e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a></td></tr>
<tr class="memdesc:a8e7809b7b7e3800ebc6fea939690938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Acceleration unit.  <a href="#a8e7809b7b7e3800ebc6fea939690938e">More...</a><br /></td></tr>
<tr class="separator:a8e7809b7b7e3800ebc6fea939690938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd04d79c3a9114074eda5a6080fbc6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a></td></tr>
<tr class="memdesc:a95dd04d79c3a9114074eda5a6080fbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="#a95dd04d79c3a9114074eda5a6080fbc6">More...</a><br /></td></tr>
<tr class="separator:a95dd04d79c3a9114074eda5a6080fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898eea1d4e2c1327c6234c96102c970e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a></td></tr>
<tr class="memdesc:a898eea1d4e2c1327c6234c96102c970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="#a898eea1d4e2c1327c6234c96102c970e">More...</a><br /></td></tr>
<tr class="separator:a898eea1d4e2c1327c6234c96102c970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adc5a1bcf7b721fde538e7a19f99bbd36">Newton</a></td></tr>
<tr class="memdesc:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Newton unit.  <a href="#adc5a1bcf7b721fde538e7a19f99bbd36">More...</a><br /></td></tr>
<tr class="separator:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5240f42645c61228638106cf2724850a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5240f42645c61228638106cf2724850a">Stress</a></td></tr>
<tr class="memdesc:a5240f42645c61228638106cf2724850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Stress unit.  <a href="#a5240f42645c61228638106cf2724850a">More...</a><br /></td></tr>
<tr class="separator:a5240f42645c61228638106cf2724850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5861e18a76bb1552c699bdebe327c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9e5861e18a76bb1552c699bdebe327c2">StressRate</a></td></tr>
<tr class="memdesc:a9e5861e18a76bb1552c699bdebe327c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the StressRate unit.  <a href="#a9e5861e18a76bb1552c699bdebe327c2">More...</a><br /></td></tr>
<tr class="separator:a9e5861e18a76bb1552c699bdebe327c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0066b6a6803bbb311c229240d6b6263b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0066b6a6803bbb311c229240d6b6263b">Pressure</a></td></tr>
<tr class="memdesc:a0066b6a6803bbb311c229240d6b6263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Pressure unit.  <a href="#a0066b6a6803bbb311c229240d6b6263b">More...</a><br /></td></tr>
<tr class="separator:a0066b6a6803bbb311c229240d6b6263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 2,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ade22387cb208d66abb4cf8cf1bcbd76f">Energy</a></td></tr>
<tr class="memdesc:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Energy unit.  <a href="#ade22387cb208d66abb4cf8cf1bcbd76f">More...</a><br /></td></tr>
<tr class="separator:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a34e2674b7e7563d24f1550c17f649"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a31a34e2674b7e7563d24f1550c17f649">EnergyDensity</a></td></tr>
<tr class="memdesc:a31a34e2674b7e7563d24f1550c17f649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the EnergyDensity unit.  <a href="#a31a34e2674b7e7563d24f1550c17f649">More...</a><br /></td></tr>
<tr class="separator:a31a34e2674b7e7563d24f1550c17f649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac068b26a121174ac002a67805e86c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-3, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7aac068b26a121174ac002a67805e86c">Density</a></td></tr>
<tr class="memdesc:a7aac068b26a121174ac002a67805e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Density unit.  <a href="#a7aac068b26a121174ac002a67805e86c">More...</a><br /></td></tr>
<tr class="separator:a7aac068b26a121174ac002a67805e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2cabf627d474a2bb5b42486ffdadb0"><td class="memItemLeft" align="right" valign="top"><a id="aed2cabf627d474a2bb5b42486ffdadb0"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-3, 0,-1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aed2cabf627d474a2bb5b42486ffdadb0">ThermalConductivity</a></td></tr>
<tr class="memdesc:aed2cabf627d474a2bb5b42486ffdadb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the ThermalConductivity unit. <br /></td></tr>
<tr class="separator:aed2cabf627d474a2bb5b42486ffdadb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="memItemLeft" align="right" valign="top"><a id="a31d042a7a3b1ad95b9c9495cdb97a773"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0,-3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a31d042a7a3b1ad95b9c9495cdb97a773">HeatFluxDensity</a></td></tr>
<tr class="memdesc:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the HeatFluxDensity unit. <br /></td></tr>
<tr class="separator:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a8048fbed09bfa347e783e2e0490d7"><td class="memTemplParams" colspan="2"><a id="a61a8048fbed09bfa347e783e2e0490d7"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a61a8048fbed09bfa347e783e2e0490d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a61a8048fbed09bfa347e783e2e0490d7">BinaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Result</td></tr>
<tr class="memdesc:a61a8048fbed09bfa347e783e2e0490d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an binary operation <br /></td></tr>
<tr class="separator:a61a8048fbed09bfa347e783e2e0490d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f47b467a56d1e49b49a3a711178364e"><td class="memTemplParams" colspan="2"><a id="a7f47b467a56d1e49b49a3a711178364e"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a7f47b467a56d1e49b49a3a711178364e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a> = std::integral_constant&lt; bool,!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a61a8048fbed09bfa347e783e2e0490d7">BinaryOperationResult</a>&lt; T1, T2, Op &gt; &gt;::cond &gt;</td></tr>
<tr class="memdesc:a7f47b467a56d1e49b49a3a711178364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction returning true if the result of the binary operation is valid <br /></td></tr>
<tr class="separator:a7f47b467a56d1e49b49a3a711178364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memTemplParams" colspan="2"><a id="a1e6928d0a344b02c1df04bcf982f9b04"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Handle</td></tr>
<tr class="memdesc:a1e6928d0a344b02c1df04bcf982f9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an binary operation <br /></td></tr>
<tr class="separator:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4328a34f29771e471ebff5eb98cb2e"><td class="memTemplParams" colspan="2"><a id="aea4328a34f29771e471ebff5eb98cb2e"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:aea4328a34f29771e471ebff5eb98cb2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aea4328a34f29771e471ebff5eb98cb2e">UnaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Result</td></tr>
<tr class="memdesc:aea4328a34f29771e471ebff5eb98cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an unary operation <br /></td></tr>
<tr class="separator:aea4328a34f29771e471ebff5eb98cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300520fa6148e3df294b597830d63e9b"><td class="memTemplParams" colspan="2"><a id="a300520fa6148e3df294b597830d63e9b"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a300520fa6148e3df294b597830d63e9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Handle</td></tr>
<tr class="memdesc:a300520fa6148e3df294b597830d63e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an unary operation <br /></td></tr>
<tr class="separator:a300520fa6148e3df294b597830d63e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memTemplParams" colspan="2"><a id="a8c2abca9d653c8ef4f1f2cfaf31eccaa"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a> = std::integral_constant&lt; bool,!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aea4328a34f29771e471ebff5eb98cb2e">UnaryOperationResult</a>&lt; T1, Op &gt; &gt;::cond &gt;</td></tr>
<tr class="memdesc:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <br /></td></tr>
<tr class="separator:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1541f8bcc6f1f236cae640cd879824e9"><td class="memTemplParams" colspan="2"><a id="a1541f8bcc6f1f236cae640cd879824e9"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a1541f8bcc6f1f236cae640cd879824e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>result_type</b> = typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; A, B, Op &gt;::type</td></tr>
<tr class="separator:a1541f8bcc6f1f236cae640cd879824e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124c4d3e7ae1c8bc746cdb98c5c53c17"><td class="memTemplParams" colspan="2"><a id="a124c4d3e7ae1c8bc746cdb98c5c53c17"></a>
template&lt;unsigned short N, unsigned short M, typename T  = double&gt; </td></tr>
<tr class="memitem:a124c4d3e7ae1c8bc746cdb98c5c53c17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstTMatrixView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t_matrix_view_expr.html">ConstTMatrixViewExpr</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="separator:a124c4d3e7ae1c8bc746cdb98c5c53c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f0065d77c585a992b63986d3d13b0"><td class="memTemplParams" colspan="2"><a id="a858f0065d77c585a992b63986d3d13b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a858f0065d77c585a992b63986d3d13b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a858f0065d77c585a992b63986d3d13b0">MatrixNumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:a858f0065d77c585a992b63986d3d13b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a858f0065d77c585a992b63986d3d13b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7757ac671befe4a4499ac740c95c8e9f"><td class="memTemplParams" colspan="2"><a id="a7757ac671befe4a4499ac740c95c8e9f"></a>
template&lt;unsigned short N, unsigned short M, typename T  = double&gt; </td></tr>
<tr class="memitem:a7757ac671befe4a4499ac740c95c8e9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TMatrixView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t_matrix_view_expr.html">TMatrixViewExpr</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="separator:a7757ac671befe4a4499ac740c95c8e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9fe942a2790b56c3082717ed99ef2b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b9fe942a2790b56c3082717ed99ef2b">mass</a></td></tr>
<tr class="memdesc:a1b9fe942a2790b56c3082717ed99ef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mass.  <a href="#a1b9fe942a2790b56c3082717ed99ef2b">More...</a><br /></td></tr>
<tr class="separator:a1b9fe942a2790b56c3082717ed99ef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a06d97ccd2592515a92ba2a4eb662bb4b">length</a></td></tr>
<tr class="memdesc:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a length.  <a href="#a06d97ccd2592515a92ba2a4eb662bb4b">More...</a><br /></td></tr>
<tr class="separator:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780717c8aea48d1f920aabd64af09270"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a780717c8aea48d1f920aabd64af09270">invlength</a></td></tr>
<tr class="memdesc:a780717c8aea48d1f920aabd64af09270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a invlength.  <a href="#a780717c8aea48d1f920aabd64af09270">More...</a><br /></td></tr>
<tr class="separator:a780717c8aea48d1f920aabd64af09270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3215b75eb5815603d8919a02502241da"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3215b75eb5815603d8919a02502241da">time</a></td></tr>
<tr class="memdesc:a3215b75eb5815603d8919a02502241da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a time.  <a href="#a3215b75eb5815603d8919a02502241da">More...</a><br /></td></tr>
<tr class="separator:a3215b75eb5815603d8919a02502241da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7dcdc304bb2813a61e03b923ad68a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afca7dcdc304bb2813a61e03b923ad68a">ampere</a></td></tr>
<tr class="memdesc:afca7dcdc304bb2813a61e03b923ad68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an ampere.  <a href="#afca7dcdc304bb2813a61e03b923ad68a">More...</a><br /></td></tr>
<tr class="separator:afca7dcdc304bb2813a61e03b923ad68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad522fc0823cac19370b9ade552cc679f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad522fc0823cac19370b9ade552cc679f">temperature</a></td></tr>
<tr class="memdesc:ad522fc0823cac19370b9ade552cc679f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a temperature.  <a href="#ad522fc0823cac19370b9ade552cc679f">More...</a><br /></td></tr>
<tr class="separator:ad522fc0823cac19370b9ade552cc679f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3ed3cb42e97e262d9a0aedcd40bf0aca">candela</a></td></tr>
<tr class="memdesc:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a candela.  <a href="#a3ed3cb42e97e262d9a0aedcd40bf0aca">More...</a><br /></td></tr>
<tr class="separator:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60efadb57e60e9757e189196f3667e68"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a60efadb57e60e9757e189196f3667e68">mole</a></td></tr>
<tr class="memdesc:a60efadb57e60e9757e189196f3667e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mole.  <a href="#a60efadb57e60e9757e189196f3667e68">More...</a><br /></td></tr>
<tr class="separator:a60efadb57e60e9757e189196f3667e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a10ed49c61273a39121565bb011e11"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a30a10ed49c61273a39121565bb011e11">velocity</a></td></tr>
<tr class="memdesc:a30a10ed49c61273a39121565bb011e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a velocity.  <a href="#a30a10ed49c61273a39121565bb011e11">More...</a><br /></td></tr>
<tr class="separator:a30a10ed49c61273a39121565bb011e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea413b09d061d87404c592457b8214"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab0ea413b09d061d87404c592457b8214">acceleration</a></td></tr>
<tr class="memdesc:ab0ea413b09d061d87404c592457b8214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an acceleration.  <a href="#ab0ea413b09d061d87404c592457b8214">More...</a><br /></td></tr>
<tr class="separator:ab0ea413b09d061d87404c592457b8214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8ff986de4d5db9845fdb1ed04f5ba6f2">momentum</a></td></tr>
<tr class="memdesc:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a momentum.  <a href="#a8ff986de4d5db9845fdb1ed04f5ba6f2">More...</a><br /></td></tr>
<tr class="separator:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4753cbd852f9c874ade45013232ba78"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae4753cbd852f9c874ade45013232ba78">force</a></td></tr>
<tr class="memdesc:ae4753cbd852f9c874ade45013232ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a force.  <a href="#ae4753cbd852f9c874ade45013232ba78">More...</a><br /></td></tr>
<tr class="separator:ae4753cbd852f9c874ade45013232ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fbbf5e40ddcaf581cc7d517979a80b"><td class="memTemplParams" colspan="2"><a id="a83fbbf5e40ddcaf581cc7d517979a80b"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a83fbbf5e40ddcaf581cc7d517979a80b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstST2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_s_t2to_s_t2_view_expr.html">ConstST2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a83fbbf5e40ddcaf581cc7d517979a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109ba474ff596e4c0e28f0057dc9235e"><td class="memTemplParams" colspan="2"><a id="a109ba474ff596e4c0e28f0057dc9235e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a109ba474ff596e4c0e28f0057dc9235e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:a109ba474ff596e4c0e28f0057dc9235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a109ba474ff596e4c0e28f0057dc9235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed23d4e17cc8342cfec3025b8f1441f"><td class="memTemplParams" colspan="2"><a id="abed23d4e17cc8342cfec3025b8f1441f"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:abed23d4e17cc8342cfec3025b8f1441f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ST2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_view_expr.html">ST2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:abed23d4e17cc8342cfec3025b8f1441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5839842bf7913a09d718b25727458606"><td class="memTemplParams" colspan="2"><a id="a5839842bf7913a09d718b25727458606"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5839842bf7913a09d718b25727458606"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5839842bf7913a09d718b25727458606">ST2toT2NumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_traits.html">ST2toT2Traits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:a5839842bf7913a09d718b25727458606"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a5839842bf7913a09d718b25727458606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb28ab00c09acac426306bd7a7c650a5"><td class="memTemplParams" colspan="2"><a id="acb28ab00c09acac426306bd7a7c650a5"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:acb28ab00c09acac426306bd7a7c650a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstStensorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_stensor_view_expr.html">ConstStensorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:acb28ab00c09acac426306bd7a7c650a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b63ce2bccd81a04ca3b8fc28a2288f"><td class="memTemplParams" colspan="2"><a id="a62b63ce2bccd81a04ca3b8fc28a2288f"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a62b63ce2bccd81a04ca3b8fc28a2288f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StensorNumType</b> = typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType</td></tr>
<tr class="separator:a62b63ce2bccd81a04ca3b8fc28a2288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403200e8433fcabd65c50f8b04fba33f"><td class="memTemplParams" colspan="2"><a id="a403200e8433fcabd65c50f8b04fba33f"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a403200e8433fcabd65c50f8b04fba33f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StensorBaseType</b> = <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;</td></tr>
<tr class="separator:a403200e8433fcabd65c50f8b04fba33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186269a7abdb956ccde079dd9e107edd"><td class="memTemplParams" colspan="2"><a id="a186269a7abdb956ccde079dd9e107edd"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a186269a7abdb956ccde079dd9e107edd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StensorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_stensor_view_expr.html">StensorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a186269a7abdb956ccde079dd9e107edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd2c57c559b42c3fe15f21598102c7"><td class="memTemplParams" colspan="2"><a id="a3dcd2c57c559b42c3fe15f21598102c7"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a3dcd2c57c559b42c3fe15f21598102c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstT2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t2to_s_t2_view_expr.html">ConstT2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a3dcd2c57c559b42c3fe15f21598102c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03a114100df324795badf42f329f970"><td class="memTemplParams" colspan="2"><a id="af03a114100df324795badf42f329f970"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af03a114100df324795badf42f329f970"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af03a114100df324795badf42f329f970">T2toST2NumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:af03a114100df324795badf42f329f970"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:af03a114100df324795badf42f329f970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87425df28eefe405a6a9238ec48ee030"><td class="memTemplParams" colspan="2"><a id="a87425df28eefe405a6a9238ec48ee030"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a87425df28eefe405a6a9238ec48ee030"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>T2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_view_expr.html">T2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a87425df28eefe405a6a9238ec48ee030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d86db0cac8ff50dd204948538db4b1"><td class="memTemplParams" colspan="2"><a id="a62d86db0cac8ff50dd204948538db4b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a62d86db0cac8ff50dd204948538db4b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a62d86db0cac8ff50dd204948538db4b1">T2toT2NumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:a62d86db0cac8ff50dd204948538db4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a62d86db0cac8ff50dd204948538db4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eedd12532aa85bbeb5b64c63d5f2dc"><td class="memTemplParams" colspan="2"><a id="ac4eedd12532aa85bbeb5b64c63d5f2dc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4eedd12532aa85bbeb5b64c63d5f2dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:ac4eedd12532aa85bbeb5b64c63d5f2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:ac4eedd12532aa85bbeb5b64c63d5f2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef08c481c89f462552a1893bb4c1d4f"><td class="memTemplParams" colspan="2"><a id="a7ef08c481c89f462552a1893bb4c1d4f"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a7ef08c481c89f462552a1893bb4c1d4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstTVectorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t_vector_view_expr.html">ConstTVectorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a7ef08c481c89f462552a1893bb4c1d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e01340d0241a65692ad869fe6002652"><td class="memTemplParams" colspan="2"><a id="a6e01340d0241a65692ad869fe6002652"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a6e01340d0241a65692ad869fe6002652"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TVectorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t_vector_view_expr.html">TVectorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a6e01340d0241a65692ad869fe6002652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5924b0d6383064319dd12d41e9de71c1"><td class="memTemplParams" colspan="2"><a id="a5924b0d6383064319dd12d41e9de71c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5924b0d6383064319dd12d41e9de71c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5924b0d6383064319dd12d41e9de71c1">VectorNumType</a> = typename <a class="el" href="structtfel_1_1math_1_1_vector_traits.html">VectorTraits</a>&lt; T &gt;::NumType</td></tr>
<tr class="memdesc:a5924b0d6383064319dd12d41e9de71c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a5924b0d6383064319dd12d41e9de71c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a25be866f4fe5021c58672780177c7825"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a25be866f4fe5021c58672780177c7825"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a25be866f4fe5021c58672780177c7825">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a25be866f4fe5021c58672780177c7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8437c41fb14f7fbda25b1f07c9dcbf94">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7d43a352f91a795ab4c35cc9cdb69d44">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab12b80ec6e7aad8e4d37e970ecdc0a9d">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#add78759d62a38f9554085c8ecf781d4d">geometricDiscretization</a> (T &amp;v, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::size_type)</td></tr>
<tr class="memdesc:add78759d62a38f9554085c8ecf781d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression.  <a href="#add78759d62a38f9554085c8ecf781d4d">More...</a><br /></td></tr>
<tr class="separator:add78759d62a38f9554085c8ecf781d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Operation &gt; </td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ce654ea4324ea12243df2df8283582e">eval</a> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;e)</td></tr>
<tr class="memdesc:a5ce654ea4324ea12243df2df8283582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate an expression  <a href="#a5ce654ea4324ea12243df2df8283582e">More...</a><br /></td></tr>
<tr class="separator:a5ce654ea4324ea12243df2df8283582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bd98b192d32d075ee257f3a3901764"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a38bd98b192d32d075ee257f3a3901764"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a38bd98b192d32d075ee257f3a3901764">operator-</a> (T1 &amp;&amp;a) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a>&lt; decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a> &gt;::value, <a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a>&lt; decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:a38bd98b192d32d075ee257f3a3901764"><td class="mdescLeft">&#160;</td><td class="mdescRight">negate a mathematical object  <a href="#a38bd98b192d32d075ee257f3a3901764">More...</a><br /></td></tr>
<tr class="separator:a38bd98b192d32d075ee257f3a3901764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7287fc490b8d1ac4964f7e1c8a671"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a91c7287fc490b8d1ac4964f7e1c8a671"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a91c7287fc490b8d1ac4964f7e1c8a671">operator+</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T1 &gt;::type &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T2 &gt;::type &gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:a91c7287fc490b8d1ac4964f7e1c8a671"><td class="mdescLeft">&#160;</td><td class="mdescRight">add to mathematical object  <a href="#a91c7287fc490b8d1ac4964f7e1c8a671">More...</a><br /></td></tr>
<tr class="separator:a91c7287fc490b8d1ac4964f7e1c8a671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19b33749f7cc2c1f30fb6415bc52e4b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab19b33749f7cc2c1f30fb6415bc52e4b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab19b33749f7cc2c1f30fb6415bc52e4b">operator-</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T1 &gt;::type &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T2 &gt;::type &gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:ab19b33749f7cc2c1f30fb6415bc52e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">substract to mathematical object  <a href="#ab19b33749f7cc2c1f30fb6415bc52e4b">More...</a><br /></td></tr>
<tr class="separator:ab19b33749f7cc2c1f30fb6415bc52e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696e7e924df758f77ce3bedbb4e36553"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a696e7e924df758f77ce3bedbb4e36553"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a696e7e924df758f77ce3bedbb4e36553">operator*</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T1 &gt;::type &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T2 &gt;::type &gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:a696e7e924df758f77ce3bedbb4e36553"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply to mathematical object  <a href="#a696e7e924df758f77ce3bedbb4e36553">More...</a><br /></td></tr>
<tr class="separator:a696e7e924df758f77ce3bedbb4e36553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74068221a11b17cc6a044c1e31d19278"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a74068221a11b17cc6a044c1e31d19278"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a74068221a11b17cc6a044c1e31d19278">operator/</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T1 &gt;::type &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T2 &gt;::type &gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:a74068221a11b17cc6a044c1e31d19278"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide a mathematical object by another  <a href="#a74068221a11b17cc6a044c1e31d19278">More...</a><br /></td></tr>
<tr class="separator:a74068221a11b17cc6a044c1e31d19278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c12688608b5a3b089ccd4df6bd3865"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab1c12688608b5a3b089ccd4df6bd3865"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab1c12688608b5a3b089ccd4df6bd3865">operator^</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T1 &gt;::type &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; typename std::decay&lt; T2 &gt;::type &gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a> &gt;&gt;::type</td></tr>
<tr class="memdesc:ab1c12688608b5a3b089ccd4df6bd3865"><td class="mdescLeft">&#160;</td><td class="mdescRight">diadic product between two mathematical objects  <a href="#ab1c12688608b5a3b089ccd4df6bd3865">More...</a><br /></td></tr>
<tr class="separator:ab1c12688608b5a3b089ccd4df6bd3865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b946f23f4e8a133ce1fbe6226dd477"><td class="memTemplParams" colspan="2"><a id="aa1b946f23f4e8a133ce1fbe6226dd477"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:aa1b946f23f4e8a133ce1fbe6226dd477"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; Scal &gt;::cond, Scal &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const Scal &amp;s)</td></tr>
<tr class="separator:aa1b946f23f4e8a133ce1fbe6226dd477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b87fec2a7caaa9303589d0bb588d10"><td class="memTemplParams" colspan="2"><a id="ad2b87fec2a7caaa9303589d0bb588d10"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:ad2b87fec2a7caaa9303589d0bb588d10"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; Scal &gt;::cond, Scal &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; Scal &gt; &amp;s)</td></tr>
<tr class="separator:ad2b87fec2a7caaa9303589d0bb588d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d631a488f31104133e2be8c01a8ff1"><td class="memTemplParams" colspan="2"><a id="aa0d631a488f31104133e2be8c01a8ff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0d631a488f31104133e2be8c01a8ff1"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE const <a class="el" href="structtfel_1_1typetraits_1_1_base_type.html">tfel::typetraits::BaseType</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_cast</b> (const T x)</td></tr>
<tr class="separator:aa0d631a488f31104133e2be8c01a8ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7964b3d477fb1a80466b646ed0320a4"><td class="memTemplParams" colspan="2"><a id="ac7964b3d477fb1a80466b646ed0320a4"></a>
template&lt;typename T , typename Unit &gt; </td></tr>
<tr class="memitem:ac7964b3d477fb1a80466b646ed0320a4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE const <a class="el" href="structtfel_1_1typetraits_1_1_base_type.html">tfel::typetraits::BaseType</a>&lt; <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_cast</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a> &gt; x)</td></tr>
<tr class="separator:ac7964b3d477fb1a80466b646ed0320a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7611707abbdd715c78815912484c38"><td class="memItemLeft" align="right" valign="top"><a id="abe7611707abbdd715c78815912484c38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (unsigned short)</td></tr>
<tr class="separator:abe7611707abbdd715c78815912484c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394811bedb7775124ba51ce3ebc20fd6"><td class="memItemLeft" align="right" valign="top"><a id="a394811bedb7775124ba51ce3ebc20fd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long unsigned int)</td></tr>
<tr class="separator:a394811bedb7775124ba51ce3ebc20fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memItemLeft" align="right" valign="top"><a id="a21cd6a2d2e58760ec69122cba1bd94b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (short)</td></tr>
<tr class="separator:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memItemLeft" align="right" valign="top"><a id="af89bcd53a3d2bdd03772cc418ab4085d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (int)</td></tr>
<tr class="separator:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f143dd8083c2602578e835a85679924"><td class="memItemLeft" align="right" valign="top"><a id="a6f143dd8083c2602578e835a85679924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long int)</td></tr>
<tr class="separator:a6f143dd8083c2602578e835a85679924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memItemLeft" align="right" valign="top"><a id="a7057a83a6f3ffa962b32cd4dfa4d6f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (float)</td></tr>
<tr class="separator:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdad99801c6e370eff256ca98f69d0d"><td class="memItemLeft" align="right" valign="top"><a id="abfdad99801c6e370eff256ca98f69d0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (double)</td></tr>
<tr class="separator:abfdad99801c6e370eff256ca98f69d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1cc004aea95572df8e7b642713702"><td class="memTemplParams" colspan="2"><a id="a12d1cc004aea95572df8e7b642713702"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12d1cc004aea95572df8e7b642713702"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond &amp;&amp;(!<a class="el" href="structtfel_1_1typetraits_1_1_is_complex.html">tfel::typetraits::IsComplex</a>&lt; T &gt;::cond), T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const T src)</td></tr>
<tr class="separator:a12d1cc004aea95572df8e7b642713702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22f1af83e3f578825252bb298896415"><td class="memTemplParams" colspan="2"><a id="ae22f1af83e3f578825252bb298896415"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae22f1af83e3f578825252bb298896415"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond &amp;&amp;(!<a class="el" href="structtfel_1_1typetraits_1_1_is_complex.html">tfel::typetraits::IsComplex</a>&lt; T &gt;::cond), T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const T src)</td></tr>
<tr class="separator:ae22f1af83e3f578825252bb298896415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a9684e431c09324e6d2490d04fe1f"><td class="memItemLeft" align="right" valign="top"><a id="ad45a9684e431c09324e6d2490d04fe1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (unsigned short)</td></tr>
<tr class="separator:ad45a9684e431c09324e6d2490d04fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55125acfcbd8b87c19910bd8d2206521"><td class="memItemLeft" align="right" valign="top"><a id="a55125acfcbd8b87c19910bd8d2206521"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long unsigned int)</td></tr>
<tr class="separator:a55125acfcbd8b87c19910bd8d2206521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83096473d77d4510e274001696cf7e93"><td class="memItemLeft" align="right" valign="top"><a id="a83096473d77d4510e274001696cf7e93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (short)</td></tr>
<tr class="separator:a83096473d77d4510e274001696cf7e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0298a35d5c9042563024d87c13d10"><td class="memItemLeft" align="right" valign="top"><a id="a68d0298a35d5c9042563024d87c13d10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (int)</td></tr>
<tr class="separator:a68d0298a35d5c9042563024d87c13d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memItemLeft" align="right" valign="top"><a id="a65df6c4d94069e4d1b8e8dd5abffe167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long int)</td></tr>
<tr class="separator:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memItemLeft" align="right" valign="top"><a id="a15fbe6efcfe832a44bb6daa9f10d4cad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (float)</td></tr>
<tr class="separator:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memItemLeft" align="right" valign="top"><a id="a0f7c37a7d76aad42c64a8cb3d213861f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (double)</td></tr>
<tr class="separator:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplParams" colspan="2"><a id="a3a16b6504017630437c88d18d5f083d1"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a3a16b6504017630437c88d18d5f083d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplParams" colspan="2"><a id="a346d17d68f05b4977f74ee91415aae89"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a346d17d68f05b4977f74ee91415aae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade46bc6a5995edba2bfb2b918064608e"><td class="memItemLeft" align="right" valign="top"><a id="ade46bc6a5995edba2bfb2b918064608e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:ade46bc6a5995edba2bfb2b918064608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a12302918d196d6f451b96c4334097"><td class="memItemLeft" align="right" valign="top"><a id="ad0a12302918d196d6f451b96c4334097"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:ad0a12302918d196d6f451b96c4334097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a44d8364a7cc6de24932f2d1f677a78fb">init_floating_point_exceptions</a> ()</td></tr>
<tr class="separator:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74895994b09cd51df13c7d3533f3c03"><td class="memTemplParams" colspan="2"><a id="ac74895994b09cd51df13c7d3533f3c03"></a>
template&lt;typename A &gt; </td></tr>
<tr class="memitem:ac74895994b09cd51df13c7d3533f3c03"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt; &amp;p)</td></tr>
<tr class="separator:ac74895994b09cd51df13c7d3533f3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0469b4561fa3911e76c78e0d09b95ecd"><td class="memTemplParams" colspan="2"><a id="a0469b4561fa3911e76c78e0d09b95ecd"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a0469b4561fa3911e76c78e0d09b95ecd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:a0469b4561fa3911e76c78e0d09b95ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7425bbc57dbe0a8fd4169257549b17"><td class="memTemplParams" colspan="2"><a id="a0a7425bbc57dbe0a8fd4169257549b17"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a7425bbc57dbe0a8fd4169257549b17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getRandomRotationMatrix</b> ()</td></tr>
<tr class="separator:a0a7425bbc57dbe0a8fd4169257549b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba58aa97e4ec7981a6eacfc8d0e48f"><td class="memTemplParams" colspan="2"><a id="abdba58aa97e4ec7981a6eacfc8d0e48f"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:abdba58aa97e4ec7981a6eacfc8d0e48f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:abdba58aa97e4ec7981a6eacfc8d0e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad1d102088567d207309fae81519f54"><td class="memTemplParams" colspan="2"><a id="adad1d102088567d207309fae81519f54"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:adad1d102088567d207309fae81519f54"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:adad1d102088567d207309fae81519f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplParams" colspan="2"><a id="a6f20b955fc36abd1608525116ff7f696"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a6f20b955fc36abd1608525116ff7f696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplParams" colspan="2"><a id="ad8bc888c51e94431b3ea585559fd01b0"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:ad8bc888c51e94431b3ea585559fd01b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367de12487bb7adcf71d6a7489ecd94d"><td class="memTemplParams" colspan="2"><a id="a367de12487bb7adcf71d6a7489ecd94d"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a367de12487bb7adcf71d6a7489ecd94d"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m)</td></tr>
<tr class="separator:a367de12487bb7adcf71d6a7489ecd94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25da1a8b8d303250adcfc92447217d9c"><td class="memTemplParams" colspan="2"><a id="a25da1a8b8d303250adcfc92447217d9c"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a25da1a8b8d303250adcfc92447217d9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt;, Operation &gt; &amp;m)</td></tr>
<tr class="separator:a25da1a8b8d303250adcfc92447217d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23232b68210f16780029a97a920e7fb4"><td class="memTemplParams" colspan="2"><a id="a23232b68210f16780029a97a920e7fb4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23232b68210f16780029a97a920e7fb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt; &amp;m)</td></tr>
<tr class="separator:a23232b68210f16780029a97a920e7fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7509117a4eac253212b4bace0fa0bbd9"><td class="memTemplParams" colspan="2"><a id="a7509117a4eac253212b4bace0fa0bbd9"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a7509117a4eac253212b4bace0fa0bbd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt;, Operation &gt; &amp;m)</td></tr>
<tr class="separator:a7509117a4eac253212b4bace0fa0bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9332ffab2e0b8daf68112755dd1cea"><td class="memTemplParams" colspan="2"><a id="a4b9332ffab2e0b8daf68112755dd1cea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b9332ffab2e0b8daf68112755dd1cea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt; &amp;m)</td></tr>
<tr class="separator:a4b9332ffab2e0b8daf68112755dd1cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57959b3e12df3752b3cac6fe620c08e8"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a57959b3e12df3752b3cac6fe620c08e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a57959b3e12df3752b3cac6fe620c08e8">getRow</a> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m, const unsigned short i)</td></tr>
<tr class="separator:a57959b3e12df3752b3cac6fe620c08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0112c63107c34060f92af4389b61346"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:ae0112c63107c34060f92af4389b61346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae0112c63107c34060f92af4389b61346">getColumn</a> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m, const unsigned short)</td></tr>
<tr class="separator:ae0112c63107c34060f92af4389b61346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplParams" colspan="2"><a id="a7be8a39585878e40e7c7d67af203ec31"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;)</td></tr>
<tr class="separator:a7be8a39585878e40e7c7d67af203ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfd4fd23d09726d7a8b2367972f2bc9"><td class="memTemplParams" colspan="2"><a id="a9bfd4fd23d09726d7a8b2367972f2bc9"></a>
template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a9bfd4fd23d09726d7a8b2367972f2bc9"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T)</td></tr>
<tr class="separator:a9bfd4fd23d09726d7a8b2367972f2bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7f43d44036834e5cba9be40cb93077"><td class="memTemplParams" colspan="2"><a id="a0a7f43d44036834e5cba9be40cb93077"></a>
template&lt;int N, unsigned int D, typename T &gt; </td></tr>
<tr class="memitem:a0a7f43d44036834e5cba9be40cb93077"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T)</td></tr>
<tr class="separator:a0a7f43d44036834e5cba9be40cb93077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9b27582802d606bc8a1acf5ef2d1ac"><td class="memTemplParams" colspan="2"><a id="a8d9b27582802d606bc8a1acf5ef2d1ac"></a>
template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a8d9b27582802d606bc8a1acf5ef2d1ac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T x)</td></tr>
<tr class="separator:a8d9b27582802d606bc8a1acf5ef2d1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d5326067d9d2c9007c0db69f2690be"><td class="memTemplParams" colspan="2"><a id="a53d5326067d9d2c9007c0db69f2690be"></a>
template&lt;int N, unsigned int D, typename T &gt; </td></tr>
<tr class="memitem:a53d5326067d9d2c9007c0db69f2690be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T x)</td></tr>
<tr class="separator:a53d5326067d9d2c9007c0db69f2690be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memTemplParams" colspan="2"><a id="a5b5432b7ca1b84325ff3f8284111fd96"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memTemplParams" colspan="2"><a id="a25c57d4bfbf56ffa05d5222373433ea3"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb44f389cb1a3958b3ec44057372406"><td class="memTemplParams" colspan="2"><a id="aabb44f389cb1a3958b3ec44057372406"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:aabb44f389cb1a3958b3ec44057372406"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:aabb44f389cb1a3958b3ec44057372406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec8114eb0ef59bc9c74be078903e049"><td class="memTemplParams" colspan="2"><a id="a3ec8114eb0ef59bc9c74be078903e049"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a3ec8114eb0ef59bc9c74be078903e049"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a3ec8114eb0ef59bc9c74be078903e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2d3c737c1321c3ce9815ad83087ce"><td class="memTemplParams" colspan="2"><a id="afef2d3c737c1321c3ce9815ad83087ce"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:afef2d3c737c1321c3ce9815ad83087ce"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:afef2d3c737c1321c3ce9815ad83087ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memTemplParams" colspan="2"><a id="a1cbdc1b51868ca44151ba0cdc9e06afc"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb95981bf45b6b2924d2f77c173eb37"><td class="memTemplParams" colspan="2"><a id="afbb95981bf45b6b2924d2f77c173eb37"></a>
template&lt;typename Unit , typename Scal &gt; </td></tr>
<tr class="memitem:afbb95981bf45b6b2924d2f77c173eb37"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>, Scal &gt; &amp;)</td></tr>
<tr class="separator:afbb95981bf45b6b2924d2f77c173eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memTemplParams" colspan="2"><a id="a695c24d2cd8e004fcf4d89fa2cd453a4"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt; &amp;)</td></tr>
<tr class="separator:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc23d25438481db1298f2e53121ab3"><td class="memTemplParams" colspan="2"><a id="af0bc23d25438481db1298f2e53121ab3"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:af0bc23d25438481db1298f2e53121ab3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt; &amp;q)</td></tr>
<tr class="separator:af0bc23d25438481db1298f2e53121ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memTemplParams" colspan="2"><a id="a2ee96e4dbaf07d3f9539e7868e3e45d6"></a>
template&lt;typename unit , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T2 &gt;)</td></tr>
<tr class="separator:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6553175d8955e51c8eaeb3b023b321f2"><td class="memTemplParams" colspan="2"><a id="a6553175d8955e51c8eaeb3b023b321f2"></a>
template&lt;typename unit , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6553175d8955e51c8eaeb3b023b321f2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T2 &gt;)</td></tr>
<tr class="separator:a6553175d8955e51c8eaeb3b023b321f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7685502b766644a6e988d651bd90ff8e"><td class="memTemplParams" colspan="2"><a id="a7685502b766644a6e988d651bd90ff8e"></a>
template&lt;typename unit , typename T1 , typename unit2 , typename T2 &gt; </td></tr>
<tr class="memitem:a7685502b766644a6e988d651bd90ff8e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_add_unit__.html">AddUnit_</a>&lt; unit, unit2 &gt;::type, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit2, T2 &gt;)</td></tr>
<tr class="separator:a7685502b766644a6e988d651bd90ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memTemplParams" colspan="2"><a id="a322d48cb11ffcb916c67ec3f29cc6371"></a>
template&lt;typename unit , typename T1 , typename unit2 , typename T2 &gt; </td></tr>
<tr class="memitem:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_sub_unit__.html">SubUnit_</a>&lt; unit, unit2 &gt;::type, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit2, T2 &gt;)</td></tr>
<tr class="separator:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66351bbed161a09dc75fa160c96143ac"><td class="memItemLeft" align="right" valign="top"><a id="a66351bbed161a09dc75fa160c96143ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (unsigned short)</td></tr>
<tr class="separator:a66351bbed161a09dc75fa160c96143ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73c4f1db8504ee53e79c79a106b796"><td class="memItemLeft" align="right" valign="top"><a id="a8e73c4f1db8504ee53e79c79a106b796"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (long unsigned int)</td></tr>
<tr class="separator:a8e73c4f1db8504ee53e79c79a106b796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab0654e1776c718519143adfc08a9be"><td class="memItemLeft" align="right" valign="top"><a id="aaab0654e1776c718519143adfc08a9be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (short)</td></tr>
<tr class="separator:aaab0654e1776c718519143adfc08a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5673079fd79f7cd9f328c6409155c713"><td class="memItemLeft" align="right" valign="top"><a id="a5673079fd79f7cd9f328c6409155c713"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (int)</td></tr>
<tr class="separator:a5673079fd79f7cd9f328c6409155c713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad916a7a479dc3a128a387d4a4556b387"><td class="memItemLeft" align="right" valign="top"><a id="ad916a7a479dc3a128a387d4a4556b387"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (long int)</td></tr>
<tr class="separator:ad916a7a479dc3a128a387d4a4556b387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1c54a966b27a9d7f1e90ac3b615f05"><td class="memItemLeft" align="right" valign="top"><a id="acd1c54a966b27a9d7f1e90ac3b615f05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (float)</td></tr>
<tr class="separator:acd1c54a966b27a9d7f1e90ac3b615f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8bff81de76da439d0ebc29b0201010"><td class="memItemLeft" align="right" valign="top"><a id="a2c8bff81de76da439d0ebc29b0201010"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (double)</td></tr>
<tr class="separator:a2c8bff81de76da439d0ebc29b0201010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e71f31cfedb01955d11f2891991651c"><td class="memItemLeft" align="right" valign="top"><a id="a6e71f31cfedb01955d11f2891991651c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned short &gt;)</td></tr>
<tr class="separator:a6e71f31cfedb01955d11f2891991651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d04d032ce1b7bdc61b917b3271fda"><td class="memItemLeft" align="right" valign="top"><a id="a8d1d04d032ce1b7bdc61b917b3271fda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned int &gt;)</td></tr>
<tr class="separator:a8d1d04d032ce1b7bdc61b917b3271fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae861c64af756816827040e1dca134821"><td class="memItemLeft" align="right" valign="top"><a id="ae861c64af756816827040e1dca134821"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long unsigned int &gt;)</td></tr>
<tr class="separator:ae861c64af756816827040e1dca134821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed2a640a7a8d59356442936827c7c8"><td class="memItemLeft" align="right" valign="top"><a id="abeed2a640a7a8d59356442936827c7c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; short &gt;)</td></tr>
<tr class="separator:abeed2a640a7a8d59356442936827c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491fb279da58b5514c2f93e6b51bb5a2"><td class="memItemLeft" align="right" valign="top"><a id="a491fb279da58b5514c2f93e6b51bb5a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; int &gt;)</td></tr>
<tr class="separator:a491fb279da58b5514c2f93e6b51bb5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a1d6ffd360baca75e66dbdc6c5ef4c"><td class="memItemLeft" align="right" valign="top"><a id="aa2a1d6ffd360baca75e66dbdc6c5ef4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long int &gt;)</td></tr>
<tr class="separator:aa2a1d6ffd360baca75e66dbdc6c5ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5f6df114cd0e418f5a8c1dd28d3537"><td class="memItemLeft" align="right" valign="top"><a id="a8a5f6df114cd0e418f5a8c1dd28d3537"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; float &gt;)</td></tr>
<tr class="separator:a8a5f6df114cd0e418f5a8c1dd28d3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7873a2dcdb8e3d5b10f2198de948ad"><td class="memItemLeft" align="right" valign="top"><a id="a7f7873a2dcdb8e3d5b10f2198de948ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; double &gt;)</td></tr>
<tr class="separator:a7f7873a2dcdb8e3d5b10f2198de948ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a084db953adf9b2955ecec2c850ef6"><td class="memItemLeft" align="right" valign="top"><a id="a96a084db953adf9b2955ecec2c850ef6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long double &gt;)</td></tr>
<tr class="separator:a96a084db953adf9b2955ecec2c850ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92d3be3ace239c3d7fe658214341368"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:aa92d3be3ace239c3d7fe658214341368"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==1u)&amp;&amp;(StensorTraits&lt; StensorType &gt;::dime==1u)&amp;&amp;tfel::meta::Implements&lt; ST2toST2Type, tfel::math::ST2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; StensorType, tfel::math::StensorConcept &gt;::cond &amp;&amp;std::is_same&lt; ST2toST2NumType&lt; ST2toST2Type &gt;, StensorNumType&lt; StensorType &gt; &gt;::value), st2tost2&lt; 1u, ST2toST2NumType&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa92d3be3ace239c3d7fe658214341368">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;C_s, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;tau)</td></tr>
<tr class="memdesc:aa92d3be3ace239c3d7fe658214341368"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#aa92d3be3ace239c3d7fe658214341368">More...</a><br /></td></tr>
<tr class="separator:aa92d3be3ace239c3d7fe658214341368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b24f2fc1cd4b6b323e5ea4a5e91501"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:a74b24f2fc1cd4b6b323e5ea4a5e91501"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==2u)&amp;&amp;(StensorTraits&lt; StensorType &gt;::dime==2u)&amp;&amp;tfel::meta::Implements&lt; ST2toST2Type, tfel::math::ST2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; StensorType, tfel::math::StensorConcept &gt;::cond &amp;&amp;std::is_same&lt; ST2toST2NumType&lt; ST2toST2Type &gt;, StensorNumType&lt; StensorType &gt; &gt;::value), st2tost2&lt; 2u, ST2toST2NumType&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a74b24f2fc1cd4b6b323e5ea4a5e91501">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;C_s, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;tau)</td></tr>
<tr class="memdesc:a74b24f2fc1cd4b6b323e5ea4a5e91501"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#a74b24f2fc1cd4b6b323e5ea4a5e91501">More...</a><br /></td></tr>
<tr class="separator:a74b24f2fc1cd4b6b323e5ea4a5e91501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096a53744171021753f2e3cac6386413"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:a096a53744171021753f2e3cac6386413"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==3u)&amp;&amp;(StensorTraits&lt; StensorType &gt;::dime==3u)&amp;&amp;tfel::meta::Implements&lt; ST2toST2Type, tfel::math::ST2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; StensorType, tfel::math::StensorConcept &gt;::cond &amp;&amp;std::is_same&lt; ST2toST2NumType&lt; ST2toST2Type &gt;, StensorNumType&lt; StensorType &gt; &gt;::value), st2tost2&lt; 3u, ST2toST2NumType&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a096a53744171021753f2e3cac6386413">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;C_s, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;tau)</td></tr>
<tr class="memdesc:a096a53744171021753f2e3cac6386413"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#a096a53744171021753f2e3cac6386413">More...</a><br /></td></tr>
<tr class="separator:a096a53744171021753f2e3cac6386413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3b2f4ac11a48f7be4dd87e3f6c6294"><td class="memTemplParams" colspan="2"><a id="a2e3b2f4ac11a48f7be4dd87e3f6c6294"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a2e3b2f4ac11a48f7be4dd87e3f6c6294"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==1u)&amp;&amp;(TensorTraits&lt; TensorType &gt;::dime==1u)&amp;&amp;tfel::meta::Implements&lt; T2toST2Type, tfel::math::T2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; TensorType, tfel::math::TensorConcept &gt;::cond), st2tost2&lt; 1u, typename ResultType&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, TensorNumType&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;K, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a2e3b2f4ac11a48f7be4dd87e3f6c6294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a871d6bfdbe594df459b0441e2f44c"><td class="memTemplParams" colspan="2"><a id="a91a871d6bfdbe594df459b0441e2f44c"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a91a871d6bfdbe594df459b0441e2f44c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==2u)&amp;&amp;(TensorTraits&lt; TensorType &gt;::dime==2u)&amp;&amp;tfel::meta::Implements&lt; T2toST2Type, tfel::math::T2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; TensorType, tfel::math::TensorConcept &gt;::cond), st2tost2&lt; 2u, typename ResultType&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, TensorNumType&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;K, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a91a871d6bfdbe594df459b0441e2f44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1417f4652530feb6cf2717788782db18"><td class="memTemplParams" colspan="2"><a id="a1417f4652530feb6cf2717788782db18"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a1417f4652530feb6cf2717788782db18"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==3u)&amp;&amp;(TensorTraits&lt; TensorType &gt;::dime==3u)&amp;&amp;tfel::meta::Implements&lt; T2toST2Type, tfel::math::T2toST2Concept &gt;::cond &amp;&amp;tfel::meta::Implements&lt; TensorType, tfel::math::TensorConcept &gt;::cond), st2tost2&lt; 3u, typename ResultType&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, TensorNumType&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;K, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a1417f4652530feb6cf2717788782db18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745fdea659a8112ff55242cb5c831f21"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a745fdea659a8112ff55242cb5c831f21"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a745fdea659a8112ff55242cb5c831f21">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;s)</td></tr>
<tr class="separator:a745fdea659a8112ff55242cb5c831f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7971be7e717e9a9cf128ba7b193b5f75"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a7971be7e717e9a9cf128ba7b193b5f75"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7971be7e717e9a9cf128ba7b193b5f75">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;s, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; ST2toST2NumType&lt; ST2toST2Type &gt;&gt;&gt; &amp;r)</td></tr>
<tr class="separator:a7971be7e717e9a9cf128ba7b193b5f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6803d4f3f5a1e51537d6efd415cdb"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:adbf6803d4f3f5a1e51537d6efd415cdb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adbf6803d4f3f5a1e51537d6efd415cdb">push_forward</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;C, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:adbf6803d4f3f5a1e51537d6efd415cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83e7555ebe39da563c07912f639bd1"><td class="memTemplParams" colspan="2"><a id="a9a83e7555ebe39da563c07912f639bd1"></a>
template&lt;typename ST2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a9a83e7555ebe39da563c07912f639bd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_back</b> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;C, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a9a83e7555ebe39da563c07912f639bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4e4b763ec347c71640d32c62edf11f"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a5b4e4b763ec347c71640d32c62edf11f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5b4e4b763ec347c71640d32c62edf11f">computeDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a5b4e4b763ec347c71640d32c62edf11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a5b4e4b763ec347c71640d32c62edf11f">More...</a><br /></td></tr>
<tr class="separator:a5b4e4b763ec347c71640d32c62edf11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3a94084e251d7cbd3fc750619ad16b"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a3b3a94084e251d7cbd3fc750619ad16b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 2u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3b3a94084e251d7cbd3fc750619ad16b">computeDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a3b3a94084e251d7cbd3fc750619ad16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a3b3a94084e251d7cbd3fc750619ad16b">More...</a><br /></td></tr>
<tr class="separator:a3b3a94084e251d7cbd3fc750619ad16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03648e20ae9aa26c7b25f0f1942722e"><td class="memTemplParams" colspan="2"><a id="ae03648e20ae9aa26c7b25f0f1942722e"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ae03648e20ae9aa26c7b25f0f1942722e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 3u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeDeterminantSecondDerivative</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:ae03648e20ae9aa26c7b25f0f1942722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d1e170c96f723dcdb8d10efba56928"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac2d1e170c96f723dcdb8d10efba56928"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac2d1e170c96f723dcdb8d10efba56928">computeDeviatorDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:ac2d1e170c96f723dcdb8d10efba56928"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of the deviator of symmetric tensor.  <a href="#ac2d1e170c96f723dcdb8d10efba56928">More...</a><br /></td></tr>
<tr class="separator:ac2d1e170c96f723dcdb8d10efba56928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ebb9cd6ff24db0bd7211a9bfd2ec3"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a558ebb9cd6ff24db0bd7211a9bfd2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 2u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a558ebb9cd6ff24db0bd7211a9bfd2ec3">computeDeviatorDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a558ebb9cd6ff24db0bd7211a9bfd2ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of the deviator of symmetric tensor.  <a href="#a558ebb9cd6ff24db0bd7211a9bfd2ec3">More...</a><br /></td></tr>
<tr class="separator:a558ebb9cd6ff24db0bd7211a9bfd2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21fa3429224fc8efc6113232147e8d7"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ae21fa3429224fc8efc6113232147e8d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 3u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae21fa3429224fc8efc6113232147e8d7">computeDeviatorDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:ae21fa3429224fc8efc6113232147e8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of determinant of the deviator of a symmetric tensor with respect to this tensor.  <a href="#ae21fa3429224fc8efc6113232147e8d7">More...</a><br /></td></tr>
<tr class="separator:ae21fa3429224fc8efc6113232147e8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4b6f47ac96cc62338777f6fa7d9f11"><td class="memTemplParams" colspan="2"><a id="a7e4b6f47ac96cc62338777f6fa7d9f11"></a>
template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a7e4b6f47ac96cc62338777f6fa7d9f11"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::NumType &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;)</td></tr>
<tr class="separator:a7e4b6f47ac96cc62338777f6fa7d9f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b3f9286baa55fc527e7cc3c30b967"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:a357b3f9286baa55fc527e7cc3c30b967"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==1u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==1u &amp;TensorTraits&lt; TensorType &gt;::dime==1u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a357b3f9286baa55fc527e7cc3c30b967">push_forward</a> (<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;, const ST2toST2Type2 &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a357b3f9286baa55fc527e7cc3c30b967"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#a357b3f9286baa55fc527e7cc3c30b967">More...</a><br /></td></tr>
<tr class="separator:a357b3f9286baa55fc527e7cc3c30b967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1bcef9ebcd2b961781670aefa6c60"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:a63d1bcef9ebcd2b961781670aefa6c60"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==2u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==2u &amp;TensorTraits&lt; TensorType &gt;::dime==2u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a63d1bcef9ebcd2b961781670aefa6c60">push_forward</a> (<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;, const ST2toST2Type2 &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a63d1bcef9ebcd2b961781670aefa6c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#a63d1bcef9ebcd2b961781670aefa6c60">More...</a><br /></td></tr>
<tr class="separator:a63d1bcef9ebcd2b961781670aefa6c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95efc1da93b2f6e086b2abec32a260"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:a4a95efc1da93b2f6e086b2abec32a260"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==3u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==3u &amp;TensorTraits&lt; TensorType &gt;::dime==3u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4a95efc1da93b2f6e086b2abec32a260">push_forward</a> (<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;, const ST2toST2Type2 &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a4a95efc1da93b2f6e086b2abec32a260"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#a4a95efc1da93b2f6e086b2abec32a260">More...</a><br /></td></tr>
<tr class="separator:a4a95efc1da93b2f6e086b2abec32a260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c58824febade733eb6dc1ceaac3e0c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c58824febade733eb6dc1ceaac3e0c6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3c58824febade733eb6dc1ceaac3e0c6">transpose</a> (T &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; T &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&lt; typename std::decay&lt; T &gt;::type &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:a3c58824febade733eb6dc1ceaac3e0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7258b605bcdd8f7c2a78e7c5edd0115d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7258b605bcdd8f7c2a78e7c5edd0115d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7258b605bcdd8f7c2a78e7c5edd0115d">transpose</a> (T &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; T &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&lt; typename std::decay&lt; T &gt;::type &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:a7258b605bcdd8f7c2a78e7c5edd0115d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4df26ed2339327310966205d4c1c9"><td class="memTemplParams" colspan="2"><a id="a61a4df26ed2339327310966205d4c1c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61a4df26ed2339327310966205d4c1c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a61a4df26ed2339327310966205d4c1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317a6bbe58898146d2f28a098dd74e91"><td class="memTemplParams" colspan="2"><a id="a317a6bbe58898146d2f28a098dd74e91"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a317a6bbe58898146d2f28a098dd74e91"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a317a6bbe58898146d2f28a098dd74e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f24c80471ec38a5eba616f042ac230"><td class="memTemplParams" colspan="2"><a id="a57f24c80471ec38a5eba616f042ac230"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a57f24c80471ec38a5eba616f042ac230"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_da</b> (const StensorType1 &amp;a, const StensorType2 &amp;b) -&gt; typename std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==1u) &amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==1u)), st2tost2&lt; 1u, decltype(a[0] *b[0])&gt;&gt;::type</td></tr>
<tr class="separator:a57f24c80471ec38a5eba616f042ac230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9d14da2027a74d3cc8a4e90a2a308c"><td class="memTemplParams" colspan="2"><a id="aab9d14da2027a74d3cc8a4e90a2a308c"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:aab9d14da2027a74d3cc8a4e90a2a308c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_db</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;a) -&gt; typename std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u)), st2tost2&lt; 1u, decltype(a[0] *a[0])&gt;&gt;::type</td></tr>
<tr class="separator:aab9d14da2027a74d3cc8a4e90a2a308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e323743f1ba98ca8b53759c2d10948"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a90e323743f1ba98ca8b53759c2d10948"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a90e323743f1ba98ca8b53759c2d10948">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; ST2toST2NumType&lt; ST2toST2Type &gt;&gt;&gt; &amp;)</td></tr>
<tr class="separator:a90e323743f1ba98ca8b53759c2d10948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4828432a3c0a71a2050eb6819bfcef99"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a4828432a3c0a71a2050eb6819bfcef99"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4828432a3c0a71a2050eb6819bfcef99">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;)</td></tr>
<tr class="separator:a4828432a3c0a71a2050eb6819bfcef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc77334e442215e01a3a1a94645dced"><td class="memTemplParams" colspan="2"><a id="a8fc77334e442215e01a3a1a94645dced"></a>
template&lt;typename ST2toT2Type &gt; </td></tr>
<tr class="memitem:a8fc77334e442215e01a3a1a94645dced"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_type.html">ST2toT2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_traits.html">ST2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_type.html">ST2toT2Type</a> &gt;::NumType &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_type.html">ST2toT2Type</a> &amp;)</td></tr>
<tr class="separator:a8fc77334e442215e01a3a1a94645dced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a1c9732dd8712749e151d6a5df1b60"><td class="memTemplParams" colspan="2"><a id="a51a1c9732dd8712749e151d6a5df1b60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51a1c9732dd8712749e151d6a5df1b60"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a51a1c9732dd8712749e151d6a5df1b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16383052e573e67affd0a39ff8868d93"><td class="memTemplParams" colspan="2"><a id="a16383052e573e67affd0a39ff8868d93"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a16383052e573e67affd0a39ff8868d93"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a> &gt;::cond &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a16383052e573e67affd0a39ff8868d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e01564b9eaefb9ae07a96d49baeefe4"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a9e01564b9eaefb9ae07a96d49baeefe4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9e01564b9eaefb9ae07a96d49baeefe4">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:a9e01564b9eaefb9ae07a96d49baeefe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a9e01564b9eaefb9ae07a96d49baeefe4">More...</a><br /></td></tr>
<tr class="separator:a9e01564b9eaefb9ae07a96d49baeefe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8ec0deff3d579216e6d7216f323fe5"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a2f8ec0deff3d579216e6d7216f323fe5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2f8ec0deff3d579216e6d7216f323fe5">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:a2f8ec0deff3d579216e6d7216f323fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a2f8ec0deff3d579216e6d7216f323fe5">More...</a><br /></td></tr>
<tr class="separator:a2f8ec0deff3d579216e6d7216f323fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554002f1479e543b8bf164b6e2778b4f"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a554002f1479e543b8bf164b6e2778b4f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a554002f1479e543b8bf164b6e2778b4f">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:a554002f1479e543b8bf164b6e2778b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a554002f1479e543b8bf164b6e2778b4f">More...</a><br /></td></tr>
<tr class="separator:a554002f1479e543b8bf164b6e2778b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab352e027dc963ea8495a0c58eb8d9337"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:ab352e027dc963ea8495a0c58eb8d9337"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab352e027dc963ea8495a0c58eb8d9337">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:ab352e027dc963ea8495a0c58eb8d9337"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#ab352e027dc963ea8495a0c58eb8d9337">More...</a><br /></td></tr>
<tr class="separator:ab352e027dc963ea8495a0c58eb8d9337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb54d6568602a3841e69ce268a007d9"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a1fb54d6568602a3841e69ce268a007d9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1fb54d6568602a3841e69ce268a007d9">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:a1fb54d6568602a3841e69ce268a007d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#a1fb54d6568602a3841e69ce268a007d9">More...</a><br /></td></tr>
<tr class="separator:a1fb54d6568602a3841e69ce268a007d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9633e725d813af5e009e18fa34e309a4"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a9633e725d813af5e009e18fa34e309a4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9633e725d813af5e009e18fa34e309a4">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;)</td></tr>
<tr class="memdesc:a9633e725d813af5e009e18fa34e309a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#a9633e725d813af5e009e18fa34e309a4">More...</a><br /></td></tr>
<tr class="separator:a9633e725d813af5e009e18fa34e309a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad44f28d2b3d5eb797bd2a2c3d852f"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ac9ad44f28d2b3d5eb797bd2a2c3d852f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac9ad44f28d2b3d5eb797bd2a2c3d852f">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;s, OutputIterator p)</td></tr>
<tr class="separator:ac9ad44f28d2b3d5eb797bd2a2c3d852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956390f6acfa8185d8420636dc422898"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a956390f6acfa8185d8420636dc422898"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a956390f6acfa8185d8420636dc422898">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;s, const bool)</td></tr>
<tr class="separator:a956390f6acfa8185d8420636dc422898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b78db087c9dbda87742fa94d15e769"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ad2b78db087c9dbda87742fa94d15e769"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad2b78db087c9dbda87742fa94d15e769">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;s, const bool b)</td></tr>
<tr class="separator:ad2b78db087c9dbda87742fa94d15e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eade60bdbe549dcaebd1a3a9fc56b5"><td class="memTemplParams" colspan="2"><a id="a25eade60bdbe549dcaebd1a3a9fc56b5"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a25eade60bdbe549dcaebd1a3a9fc56b5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square_root</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:a25eade60bdbe549dcaebd1a3a9fc56b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ab69d39f27a9d604b32f04dac810f"><td class="memTemplParams" colspan="2"><a id="a6b9ab69d39f27a9d604b32f04dac810f"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a6b9ab69d39f27a9d604b32f04dac810f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:a6b9ab69d39f27a9d604b32f04dac810f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb4ad8cd2e8a31ed770d191de670fef"><td class="memTemplParams" colspan="2"><a id="a1fb4ad8cd2e8a31ed770d191de670fef"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a1fb4ad8cd2e8a31ed770d191de670fef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:a1fb4ad8cd2e8a31ed770d191de670fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ae8bf8c7712f24ab95c65e97f0c85d"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a76ae8bf8c7712f24ab95c65e97f0c85d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a76ae8bf8c7712f24ab95c65e97f0c85d">logarithm</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s, const bool)</td></tr>
<tr class="memdesc:a76ae8bf8c7712f24ab95c65e97f0c85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#a76ae8bf8c7712f24ab95c65e97f0c85d">More...</a><br /></td></tr>
<tr class="separator:a76ae8bf8c7712f24ab95c65e97f0c85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb39518aaac61328726676745c1ed424"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:abb39518aaac61328726676745c1ed424"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abb39518aaac61328726676745c1ed424">logarithm</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s_, const bool b)</td></tr>
<tr class="memdesc:abb39518aaac61328726676745c1ed424"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#abb39518aaac61328726676745c1ed424">More...</a><br /></td></tr>
<tr class="separator:abb39518aaac61328726676745c1ed424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d7f8a51d1334ee908052c599d65152"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac5d7f8a51d1334ee908052c599d65152"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac5d7f8a51d1334ee908052c599d65152">absolute_value</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:ac5d7f8a51d1334ee908052c599d65152"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the absolute value of a symmetric tensor  <a href="#ac5d7f8a51d1334ee908052c599d65152">More...</a><br /></td></tr>
<tr class="separator:ac5d7f8a51d1334ee908052c599d65152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2169810ee26a815468913ce8ddfc4c31"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a2169810ee26a815468913ce8ddfc4c31"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2169810ee26a815468913ce8ddfc4c31">absolute_value</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:a2169810ee26a815468913ce8ddfc4c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the absolute value of a symmetric tensor  <a href="#a2169810ee26a815468913ce8ddfc4c31">More...</a><br /></td></tr>
<tr class="separator:a2169810ee26a815468913ce8ddfc4c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f53217ac87c0397cd7ccfd51f3fa85"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac0f53217ac87c0397cd7ccfd51f3fa85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac0f53217ac87c0397cd7ccfd51f3fa85">positive_part</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:ac0f53217ac87c0397cd7ccfd51f3fa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the positive part of a symmetric tensor  <a href="#ac0f53217ac87c0397cd7ccfd51f3fa85">More...</a><br /></td></tr>
<tr class="separator:ac0f53217ac87c0397cd7ccfd51f3fa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994f8005c3876664ed1b96bd8a0ab863"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a994f8005c3876664ed1b96bd8a0ab863"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a994f8005c3876664ed1b96bd8a0ab863">positive_part</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:a994f8005c3876664ed1b96bd8a0ab863"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the positive part of a symmetric tensor  <a href="#a994f8005c3876664ed1b96bd8a0ab863">More...</a><br /></td></tr>
<tr class="separator:a994f8005c3876664ed1b96bd8a0ab863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1ef6d154557d4c704a3306675c32d7"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a1a1ef6d154557d4c704a3306675c32d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1a1ef6d154557d4c704a3306675c32d7">negative_part</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:a1a1ef6d154557d4c704a3306675c32d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the negative part of a symmetric tensor  <a href="#a1a1ef6d154557d4c704a3306675c32d7">More...</a><br /></td></tr>
<tr class="separator:a1a1ef6d154557d4c704a3306675c32d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa761c2187e151aaf9571f9fcbfb36391"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:aa761c2187e151aaf9571f9fcbfb36391"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa761c2187e151aaf9571f9fcbfb36391">negative_part</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:aa761c2187e151aaf9571f9fcbfb36391"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the negative part of a symmetric tensor  <a href="#aa761c2187e151aaf9571f9fcbfb36391">More...</a><br /></td></tr>
<tr class="separator:aa761c2187e151aaf9571f9fcbfb36391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b50fb717c5f8cae0ed0fff58501570"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a53b50fb717c5f8cae0ed0fff58501570"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u, stensor&lt; 1u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a53b50fb717c5f8cae0ed0fff58501570">square</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:a53b50fb717c5f8cae0ed0fff58501570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2ba18b1e3c19757add971dbb85d339"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:abc2ba18b1e3c19757add971dbb85d339"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u, stensor&lt; 2u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abc2ba18b1e3c19757add971dbb85d339">square</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:abc2ba18b1e3c19757add971dbb85d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bb1a209946ea8e6808cb78285d03cb"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:aa5bb1a209946ea8e6808cb78285d03cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u, stensor&lt; 3u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa5bb1a209946ea8e6808cb78285d03cb">square</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:aa5bb1a209946ea8e6808cb78285d03cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c79fd0ecece57dfbd922e1bab808ae7"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a5c79fd0ecece57dfbd922e1bab808ae7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5c79fd0ecece57dfbd922e1bab808ae7">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt;&gt;&gt; &amp;r)</td></tr>
<tr class="memdesc:a5c79fd0ecece57dfbd922e1bab808ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a symmetric tensor using a rotation matrix  <a href="#a5c79fd0ecece57dfbd922e1bab808ae7">More...</a><br /></td></tr>
<tr class="separator:a5c79fd0ecece57dfbd922e1bab808ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cd06e5ea0ac31879d2fe5f1f7976c8"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename StensorType &gt; </td></tr>
<tr class="memitem:a66cd06e5ea0ac31879d2fe5f1f7976c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a66cd06e5ea0ac31879d2fe5f1f7976c8">computeIsotropicFunction</a> (const Function &amp;f, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s, const bool b)</td></tr>
<tr class="separator:a66cd06e5ea0ac31879d2fe5f1f7976c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad157d56dc36fe1e815ed0032ddc1496b"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </td></tr>
<tr class="memitem:ad157d56dc36fe1e815ed0032ddc1496b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad157d56dc36fe1e815ed0032ddc1496b">computeIsotropicFunctionDerivative</a> (const Function &amp;f, const FunctionDerivative &amp;df, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; eps, const bool b)</td></tr>
<tr class="separator:ad157d56dc36fe1e815ed0032ddc1496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4742d68c54d3384ef417ba06d50f437e"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </td></tr>
<tr class="memitem:a4742d68c54d3384ef417ba06d50f437e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, std::pair&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4742d68c54d3384ef417ba06d50f437e">computeIsotropicFunctionDerivative</a> (const Function &amp;f, const FunctionDerivative &amp;df, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s, const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; eps, const bool b)</td></tr>
<tr class="separator:a4742d68c54d3384ef417ba06d50f437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9548efe16e0e0a3cb28210d7a8837a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a4d9548efe16e0e0a3cb28210d7a8837a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4d9548efe16e0e0a3cb28210d7a8837a">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:a4d9548efe16e0e0a3cb28210d7a8837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a4d9548efe16e0e0a3cb28210d7a8837a">More...</a><br /></td></tr>
<tr class="separator:a4d9548efe16e0e0a3cb28210d7a8837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c14367e6c2d075da58270b871dd7d4e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a2c14367e6c2d075da58270b871dd7d4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2c14367e6c2d075da58270b871dd7d4e">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:a2c14367e6c2d075da58270b871dd7d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a2c14367e6c2d075da58270b871dd7d4e">More...</a><br /></td></tr>
<tr class="separator:a2c14367e6c2d075da58270b871dd7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc1825843e750c2b0076a31ac02530d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:abcc1825843e750c2b0076a31ac02530d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abcc1825843e750c2b0076a31ac02530d">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:abcc1825843e750c2b0076a31ac02530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#abcc1825843e750c2b0076a31ac02530d">More...</a><br /></td></tr>
<tr class="separator:abcc1825843e750c2b0076a31ac02530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ecabe5b32b177a637bb3c6c928d82e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a92ecabe5b32b177a637bb3c6c928d82e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a92ecabe5b32b177a637bb3c6c928d82e">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:a92ecabe5b32b177a637bb3c6c928d82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a92ecabe5b32b177a637bb3c6c928d82e">More...</a><br /></td></tr>
<tr class="separator:a92ecabe5b32b177a637bb3c6c928d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9096a5172f2ed15dd22fe348ddff40"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a0f9096a5172f2ed15dd22fe348ddff40"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0f9096a5172f2ed15dd22fe348ddff40">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:a0f9096a5172f2ed15dd22fe348ddff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a0f9096a5172f2ed15dd22fe348ddff40">More...</a><br /></td></tr>
<tr class="separator:a0f9096a5172f2ed15dd22fe348ddff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dcc019e3f98e8a8c6c9da8c5364a7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a37dcc019e3f98e8a8c6c9da8c5364a7f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a37dcc019e3f98e8a8c6c9da8c5364a7f">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:a37dcc019e3f98e8a8c6c9da8c5364a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a37dcc019e3f98e8a8c6c9da8c5364a7f">More...</a><br /></td></tr>
<tr class="separator:a37dcc019e3f98e8a8c6c9da8c5364a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b3972a6f7884f27faa31c609b49632"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a11b3972a6f7884f27faa31c609b49632"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==1u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==1u)), stensor&lt; 3u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a11b3972a6f7884f27faa31c609b49632">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:a11b3972a6f7884f27faa31c609b49632"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#a11b3972a6f7884f27faa31c609b49632">More...</a><br /></td></tr>
<tr class="separator:a11b3972a6f7884f27faa31c609b49632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aeb3f9700f6821d5a1aa17b6ac0559"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a93aeb3f9700f6821d5a1aa17b6ac0559"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==2u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==2u)), stensor&lt; 2u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a93aeb3f9700f6821d5a1aa17b6ac0559">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:a93aeb3f9700f6821d5a1aa17b6ac0559"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor: </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#a93aeb3f9700f6821d5a1aa17b6ac0559">More...</a><br /></td></tr>
<tr class="separator:a93aeb3f9700f6821d5a1aa17b6ac0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfab666eac28771e9935c66037274ef"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a8dfab666eac28771e9935c66037274ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==3u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==3u)), stensor&lt; 3u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8dfab666eac28771e9935c66037274ef">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:a8dfab666eac28771e9935c66037274ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#a8dfab666eac28771e9935c66037274ef">More...</a><br /></td></tr>
<tr class="separator:a8dfab666eac28771e9935c66037274ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c79bd81d4b00e7aa495f6e84ad3216"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a43c79bd81d4b00e7aa495f6e84ad3216"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a43c79bd81d4b00e7aa495f6e84ad3216">computeDeterminantDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:a43c79bd81d4b00e7aa495f6e84ad3216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e08f6c5e1ced67af3738039404268a"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac8e08f6c5e1ced67af3738039404268a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac8e08f6c5e1ced67af3738039404268a">computeDeviatorDeterminantDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;s)</td></tr>
<tr class="separator:ac8e08f6c5e1ced67af3738039404268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb34598d2545a67b2cf071804c89d030"><td class="memTemplParams" colspan="2"><a id="afb34598d2545a67b2cf071804c89d030"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:afb34598d2545a67b2cf071804c89d030"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="separator:afb34598d2545a67b2cf071804c89d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3065a499de45fad1258edbb4fe10fdb"><td class="memTemplParams" colspan="2"><a id="ae3065a499de45fad1258edbb4fe10fdb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3065a499de45fad1258edbb4fe10fdb"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, StensorNumType&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const T &amp;s)</td></tr>
<tr class="separator:ae3065a499de45fad1258edbb4fe10fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7373a8ade95333fa1e284a5e30e6868f"><td class="memTemplParams" colspan="2"><a id="a7373a8ade95333fa1e284a5e30e6868f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7373a8ade95333fa1e284a5e30e6868f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, StensorNumType&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sigmaeq</b> (const T &amp;s)</td></tr>
<tr class="separator:a7373a8ade95333fa1e284a5e30e6868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09763698931916be009e1647bcaf53ef"><td class="memTemplParams" colspan="2"><a id="a09763698931916be009e1647bcaf53ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09763698931916be009e1647bcaf53ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u, typename StensorType&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deviator</b> (const T &amp;)</td></tr>
<tr class="separator:a09763698931916be009e1647bcaf53ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec87f837bce6400b6b4d45010f72eff1"><td class="memTemplParams" colspan="2"><a id="aec87f837bce6400b6b4d45010f72eff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec87f837bce6400b6b4d45010f72eff1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u, typename StensorType&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deviator</b> (const T &amp;)</td></tr>
<tr class="separator:aec87f837bce6400b6b4d45010f72eff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa32919d716a7ffffbb71722748ae9ed"><td class="memTemplParams" colspan="2"><a id="afa32919d716a7ffffbb71722748ae9ed"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa32919d716a7ffffbb71722748ae9ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u, typename StensorType&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deviator</b> (const T &amp;)</td></tr>
<tr class="separator:afa32919d716a7ffffbb71722748ae9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe30dbf021798da2b686fac6763c127"><td class="memItemLeft" align="right" valign="top">TFELMATH_VISIBILITY_EXPORT unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abfe30dbf021798da2b686fac6763c127">getStensorSize</a> (const unsigned short)</td></tr>
<tr class="memdesc:abfe30dbf021798da2b686fac6763c127"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of a symmetric tensor for the given dimension  <a href="#abfe30dbf021798da2b686fac6763c127">More...</a><br /></td></tr>
<tr class="separator:abfe30dbf021798da2b686fac6763c127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdd492d1e25faa303d381466b6bcaec"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a9fdd492d1e25faa303d381466b6bcaec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9fdd492d1e25faa303d381466b6bcaec">computeDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a9fdd492d1e25faa303d381466b6bcaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a9fdd492d1e25faa303d381466b6bcaec">More...</a><br /></td></tr>
<tr class="separator:a9fdd492d1e25faa303d381466b6bcaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1578038b0ba7f1a389cee4ee99854"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a78f1578038b0ba7f1a389cee4ee99854"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a78f1578038b0ba7f1a389cee4ee99854">computeDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a78f1578038b0ba7f1a389cee4ee99854"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a78f1578038b0ba7f1a389cee4ee99854">More...</a><br /></td></tr>
<tr class="separator:a78f1578038b0ba7f1a389cee4ee99854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d98eb3a12bbcc75337ad265d3de93b"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:ab8d98eb3a12bbcc75337ad265d3de93b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab8d98eb3a12bbcc75337ad265d3de93b">computeDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:ab8d98eb3a12bbcc75337ad265d3de93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#ab8d98eb3a12bbcc75337ad265d3de93b">More...</a><br /></td></tr>
<tr class="separator:ab8d98eb3a12bbcc75337ad265d3de93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68563659f50ac9407e7349dc2fceda51"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a68563659f50ac9407e7349dc2fceda51"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a68563659f50ac9407e7349dc2fceda51">computeDeviatorDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a68563659f50ac9407e7349dc2fceda51"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a68563659f50ac9407e7349dc2fceda51">More...</a><br /></td></tr>
<tr class="separator:a68563659f50ac9407e7349dc2fceda51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9428b6ac31588505a6ce0af11ca76b"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a4b9428b6ac31588505a6ce0af11ca76b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4b9428b6ac31588505a6ce0af11ca76b">computeDeviatorDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a4b9428b6ac31588505a6ce0af11ca76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a4b9428b6ac31588505a6ce0af11ca76b">More...</a><br /></td></tr>
<tr class="separator:a4b9428b6ac31588505a6ce0af11ca76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170f2faf600a8f4e18de8a686eff32d5"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a170f2faf600a8f4e18de8a686eff32d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a170f2faf600a8f4e18de8a686eff32d5">computeDeviatorDeterminantDerivative</a> (StensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="memdesc:a170f2faf600a8f4e18de8a686eff32d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a170f2faf600a8f4e18de8a686eff32d5">More...</a><br /></td></tr>
<tr class="separator:a170f2faf600a8f4e18de8a686eff32d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6db6b72188ec25ee54ad323941189b"><td class="memTemplParams" colspan="2"><a id="a8c6db6b72188ec25ee54ad323941189b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8c6db6b72188ec25ee54ad323941189b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, StensorNumType&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const T &amp;s)</td></tr>
<tr class="separator:a8c6db6b72188ec25ee54ad323941189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850dced2aca2f1441de7b0dfc826f68b"><td class="memTemplParams" colspan="2"><a id="a850dced2aca2f1441de7b0dfc826f68b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a850dced2aca2f1441de7b0dfc826f68b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, StensorNumType&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sigmaeq</b> (const T &amp;s)</td></tr>
<tr class="separator:a850dced2aca2f1441de7b0dfc826f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6e326869ee581a702c71f809ae43a"><td class="memTemplParams" colspan="2"><a id="ac0a6e326869ee581a702c71f809ae43a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0a6e326869ee581a702c71f809ae43a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac0a6e326869ee581a702c71f809ae43a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:ac0a6e326869ee581a702c71f809ae43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialisation operator. <br /></td></tr>
<tr class="separator:ac0a6e326869ee581a702c71f809ae43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca424c4df449d95cb2168c61f72a8c99"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aca424c4df449d95cb2168c61f72a8c99"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==1u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aca424c4df449d95cb2168c61f72a8c99">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:aca424c4df449d95cb2168c61f72a8c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35acc4c9564f0e79a83777bf61ac945"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af35acc4c9564f0e79a83777bf61ac945"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==2u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af35acc4c9564f0e79a83777bf61ac945">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:af35acc4c9564f0e79a83777bf61ac945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ed9f3df31262e05dd6eb3f9506e55e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a43ed9f3df31262e05dd6eb3f9506e55e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==3u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a43ed9f3df31262e05dd6eb3f9506e55e">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a43ed9f3df31262e05dd6eb3f9506e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccf8bc46a896d8955c103dc9d87589f"><td class="memTemplParams" colspan="2"><a id="a6ccf8bc46a896d8955c103dc9d87589f"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a6ccf8bc46a896d8955c103dc9d87589f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_aba</b> (const StensorType1 &amp;a, const StensorType2 &amp;b) -&gt; typename std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==1u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==1u)), stensor&lt; 1u, decltype(a[0] *b[0] *a[0])&gt;&gt;::type</td></tr>
<tr class="separator:a6ccf8bc46a896d8955c103dc9d87589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7daa8861aa92e086a2d9b5a6906f9178"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a7daa8861aa92e086a2d9b5a6906f9178"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7daa8861aa92e086a2d9b5a6906f9178">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt;&gt;&gt; &amp;)</td></tr>
<tr class="memdesc:a7daa8861aa92e086a2d9b5a6906f9178"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a symmetric tensor using a rotation matrix  <a href="#a7daa8861aa92e086a2d9b5a6906f9178">More...</a><br /></td></tr>
<tr class="separator:a7daa8861aa92e086a2d9b5a6906f9178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9111dc05758e201fd64067b1a6609091"><td class="memTemplParams" colspan="2"><a id="a9111dc05758e201fd64067b1a6609091"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a9111dc05758e201fd64067b1a6609091"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;)</td></tr>
<tr class="separator:a9111dc05758e201fd64067b1a6609091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac6d2617d4f5224304edb6300643fd"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:abdac6d2617d4f5224304edb6300643fd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abdac6d2617d4f5224304edb6300643fd">logarithm</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:abdac6d2617d4f5224304edb6300643fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#abdac6d2617d4f5224304edb6300643fd">More...</a><br /></td></tr>
<tr class="separator:abdac6d2617d4f5224304edb6300643fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb43eba06231944504c8793a4aaaf0"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a72fb43eba06231944504c8793a4aaaf0"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a72fb43eba06231944504c8793a4aaaf0">logarithm</a> (const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const bool=false)</td></tr>
<tr class="memdesc:a72fb43eba06231944504c8793a4aaaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#a72fb43eba06231944504c8793a4aaaf0">More...</a><br /></td></tr>
<tr class="separator:a72fb43eba06231944504c8793a4aaaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ac7440078fa924cd238d38f5d96c8f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ac1ac7440078fa924cd238d38f5d96c8f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac1ac7440078fa924cd238d38f5d96c8f">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:ac1ac7440078fa924cd238d38f5d96c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#ac1ac7440078fa924cd238d38f5d96c8f">More...</a><br /></td></tr>
<tr class="separator:ac1ac7440078fa924cd238d38f5d96c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd80d0368e82d2010fd62748ea10b0b8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:afd80d0368e82d2010fd62748ea10b0b8"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afd80d0368e82d2010fd62748ea10b0b8">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:afd80d0368e82d2010fd62748ea10b0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#afd80d0368e82d2010fd62748ea10b0b8">More...</a><br /></td></tr>
<tr class="separator:afd80d0368e82d2010fd62748ea10b0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6d56c7ad12f895bd715b5b7a660f1b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a8d6d56c7ad12f895bd715b5b7a660f1b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8d6d56c7ad12f895bd715b5b7a660f1b">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a8d6d56c7ad12f895bd715b5b7a660f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a8d6d56c7ad12f895bd715b5b7a660f1b">More...</a><br /></td></tr>
<tr class="separator:a8d6d56c7ad12f895bd715b5b7a660f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec9050f7f8c7d520d4451e67cdb1d7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a9ec9050f7f8c7d520d4451e67cdb1d7e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9ec9050f7f8c7d520d4451e67cdb1d7e">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a9ec9050f7f8c7d520d4451e67cdb1d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a9ec9050f7f8c7d520d4451e67cdb1d7e">More...</a><br /></td></tr>
<tr class="separator:a9ec9050f7f8c7d520d4451e67cdb1d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6d57ab7b526ccfaba2093dc17022d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a3f6d57ab7b526ccfaba2093dc17022d8"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3f6d57ab7b526ccfaba2093dc17022d8">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a3f6d57ab7b526ccfaba2093dc17022d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a3f6d57ab7b526ccfaba2093dc17022d8">More...</a><br /></td></tr>
<tr class="separator:a3f6d57ab7b526ccfaba2093dc17022d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541e04d9174f40694a656890dd014aa6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a541e04d9174f40694a656890dd014aa6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, StensorConcept &gt;::cond) &amp;&amp;(StensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a541e04d9174f40694a656890dd014aa6">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a541e04d9174f40694a656890dd014aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a541e04d9174f40694a656890dd014aa6">More...</a><br /></td></tr>
<tr class="separator:a541e04d9174f40694a656890dd014aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262d4c456e0a76d69c3f07bb78c622e4"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a262d4c456e0a76d69c3f07bb78c622e4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==1u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 1u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a262d4c456e0a76d69c3f07bb78c622e4">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;t)</td></tr>
<tr class="separator:a262d4c456e0a76d69c3f07bb78c622e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac8d82409ffb625580440560620fcb"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:ab0ac8d82409ffb625580440560620fcb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==2u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 2u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab0ac8d82409ffb625580440560620fcb">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;t)</td></tr>
<tr class="separator:ab0ac8d82409ffb625580440560620fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604b320098a6663c9d55178729fe371c"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a604b320098a6663c9d55178729fe371c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==3u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 3u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a604b320098a6663c9d55178729fe371c">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;t)</td></tr>
<tr class="separator:a604b320098a6663c9d55178729fe371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b95294acd87f2f2911a67ede6de6e"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aa04b95294acd87f2f2911a67ede6de6e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u), t2tost2&lt; 1u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa04b95294acd87f2f2911a67ede6de6e">computeRateOfDeformationDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:aa04b95294acd87f2f2911a67ede6de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88698b371152d85460a5da45dbf16f5a"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a88698b371152d85460a5da45dbf16f5a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u), t2tost2&lt; 2u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a88698b371152d85460a5da45dbf16f5a">computeRateOfDeformationDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a88698b371152d85460a5da45dbf16f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d2f30e1fba079ab33257ad9cc2c49b"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a74d2f30e1fba079ab33257ad9cc2c49b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u), t2tost2&lt; 3u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a74d2f30e1fba079ab33257ad9cc2c49b">computeRateOfDeformationDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a74d2f30e1fba079ab33257ad9cc2c49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293c74353557edd1f43dc1116383112a"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a293c74353557edd1f43dc1116383112a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a293c74353557edd1f43dc1116383112a">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a293c74353557edd1f43dc1116383112a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="#a293c74353557edd1f43dc1116383112a">More...</a><br /></td></tr>
<tr class="separator:a293c74353557edd1f43dc1116383112a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab205ca9f0bd230231ce30a86f9fd9c1b"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:ab205ca9f0bd230231ce30a86f9fd9c1b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab205ca9f0bd230231ce30a86f9fd9c1b">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:ab205ca9f0bd230231ce30a86f9fd9c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="#ab205ca9f0bd230231ce30a86f9fd9c1b">More...</a><br /></td></tr>
<tr class="separator:ab205ca9f0bd230231ce30a86f9fd9c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9c9628601da9b41f5ea71784675f91"><td class="memTemplParams" colspan="2"><a id="a7c9c9628601da9b41f5ea71784675f91"></a>
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a7c9c9628601da9b41f5ea71784675f91"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computePushForwardDerivative</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;K, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;S, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a7c9c9628601da9b41f5ea71784675f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5a3ac356e8780b98ea4fbb5386c64b"><td class="memTemplParams" colspan="2"><a id="a9b5a3ac356e8780b98ea4fbb5386c64b"></a>
template&lt;typename T2toST2Type &gt; </td></tr>
<tr class="memitem:a9b5a3ac356e8780b98ea4fbb5386c64b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;)</td></tr>
<tr class="separator:a9b5a3ac356e8780b98ea4fbb5386c64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd3a1b75130eb7e6eb635ab62ba13a7"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a9cd3a1b75130eb7e6eb635ab62ba13a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==1u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==1u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9cd3a1b75130eb7e6eb635ab62ba13a7">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a9cd3a1b75130eb7e6eb635ab62ba13a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#a9cd3a1b75130eb7e6eb635ab62ba13a7">More...</a><br /></td></tr>
<tr class="separator:a9cd3a1b75130eb7e6eb635ab62ba13a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adfb93509e4744f44572672a647991b"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a5adfb93509e4744f44572672a647991b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==2u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==2u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5adfb93509e4744f44572672a647991b">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a5adfb93509e4744f44572672a647991b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#a5adfb93509e4744f44572672a647991b">More...</a><br /></td></tr>
<tr class="separator:a5adfb93509e4744f44572672a647991b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf37eaee230e356d769ed087a8d9e9"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a96cf37eaee230e356d769ed087a8d9e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==3u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==3u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a96cf37eaee230e356d769ed087a8d9e9">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a96cf37eaee230e356d769ed087a8d9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#a96cf37eaee230e356d769ed087a8d9e9">More...</a><br /></td></tr>
<tr class="separator:a96cf37eaee230e356d769ed087a8d9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cd910684db930e8cda9bdbbbe63753"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a61cd910684db930e8cda9bdbbbe63753"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a61cd910684db930e8cda9bdbbbe63753">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (T2toST2ResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a61cd910684db930e8cda9bdbbbe63753"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative with respect to the deformation gradient  <a href="#a61cd910684db930e8cda9bdbbbe63753">More...</a><br /></td></tr>
<tr class="separator:a61cd910684db930e8cda9bdbbbe63753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20c8ff73ba6f9a3895d00451d5663f1"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:af20c8ff73ba6f9a3895d00451d5663f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af20c8ff73ba6f9a3895d00451d5663f1">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (T2toST2ResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:af20c8ff73ba6f9a3895d00451d5663f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient  <a href="#af20c8ff73ba6f9a3895d00451d5663f1">More...</a><br /></td></tr>
<tr class="separator:af20c8ff73ba6f9a3895d00451d5663f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3996c4fd98445b5408781edb2cabc11"><td class="memTemplParams" colspan="2"><a id="ad3996c4fd98445b5408781edb2cabc11"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3996c4fd98445b5408781edb2cabc11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:ad3996c4fd98445b5408781edb2cabc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f800ccaadd428488fc6e5c3faf124a"><td class="memTemplParams" colspan="2"><a id="ac1f800ccaadd428488fc6e5c3faf124a"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac1f800ccaadd428488fc6e5c3faf124a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:ac1f800ccaadd428488fc6e5c3faf124a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473dca9445ee038670ec24cf36bd04d8"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a473dca9445ee038670ec24cf36bd04d8"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==1u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 1u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a473dca9445ee038670ec24cf36bd04d8">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;)</td></tr>
<tr class="separator:a473dca9445ee038670ec24cf36bd04d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0a674f32e307e51a09669c15318831"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a0d0a674f32e307e51a09669c15318831"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==2u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 2u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0d0a674f32e307e51a09669c15318831">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;)</td></tr>
<tr class="separator:a0d0a674f32e307e51a09669c15318831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b953e4bd4cd17fb50389cb3cd59cd54"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a9b953e4bd4cd17fb50389cb3cd59cd54"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime==3u)&amp;&amp;tfel::meta::Implements&lt; T2toT2Type, tfel::math::T2toT2Concept &gt;::cond), t2tost2&lt; 3u, typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9b953e4bd4cd17fb50389cb3cd59cd54">convertToT2toST2</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;)</td></tr>
<tr class="separator:a9b953e4bd4cd17fb50389cb3cd59cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579991c89e94c54de38167191abdb24c"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a579991c89e94c54de38167191abdb24c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u), t2tost2&lt; 1u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a579991c89e94c54de38167191abdb24c">computeRateOfDeformationDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a579991c89e94c54de38167191abdb24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca87552de0f863d70b6a1d703d901d0"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a1ca87552de0f863d70b6a1d703d901d0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1ca87552de0f863d70b6a1d703d901d0">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;s, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, typename tfel::typetraits::BaseType&lt; typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt;::type &gt; &amp;r)</td></tr>
<tr class="separator:a1ca87552de0f863d70b6a1d703d901d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24942210fbf8076dfa462303a1ffae17"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a24942210fbf8076dfa462303a1ffae17"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a24942210fbf8076dfa462303a1ffae17">computeVelocityGradientDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a24942210fbf8076dfa462303a1ffae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04a8b8702b48d2b140d04e36906ff50"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ad04a8b8702b48d2b140d04e36906ff50"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad04a8b8702b48d2b140d04e36906ff50">computeSpinRateDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:ad04a8b8702b48d2b140d04e36906ff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725b637462fab4a4ac6a204c5501837"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a2725b637462fab4a4ac6a204c5501837"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 1u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2725b637462fab4a4ac6a204c5501837">computeDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a2725b637462fab4a4ac6a204c5501837"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a2725b637462fab4a4ac6a204c5501837">More...</a><br /></td></tr>
<tr class="separator:a2725b637462fab4a4ac6a204c5501837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccba02c18c51f533d918112b5c4d3c3"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a7ccba02c18c51f533d918112b5c4d3c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 2u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7ccba02c18c51f533d918112b5c4d3c3">computeDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a7ccba02c18c51f533d918112b5c4d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a7ccba02c18c51f533d918112b5c4d3c3">More...</a><br /></td></tr>
<tr class="separator:a7ccba02c18c51f533d918112b5c4d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe23a77442bfcee2b07b96fbe261280"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a2fe23a77442bfcee2b07b96fbe261280"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 3u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2fe23a77442bfcee2b07b96fbe261280">computeDeterminantSecondDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a2fe23a77442bfcee2b07b96fbe261280"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a2fe23a77442bfcee2b07b96fbe261280">More...</a><br /></td></tr>
<tr class="separator:a2fe23a77442bfcee2b07b96fbe261280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded0bc7d912095cd2f0be29ce98e4bb1"><td class="memTemplParams" colspan="2"><a id="aded0bc7d912095cd2f0be29ce98e4bb1"></a>
template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:aded0bc7d912095cd2f0be29ce98e4bb1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::NumType &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;)</td></tr>
<tr class="separator:aded0bc7d912095cd2f0be29ce98e4bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64a752e581d0e8d89bab0f465a3210"><td class="memTemplParams" colspan="2"><a id="a1c64a752e581d0e8d89bab0f465a3210"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c64a752e581d0e8d89bab0f465a3210"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a1c64a752e581d0e8d89bab0f465a3210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce418019d56f20075a3f3ebe3632019"><td class="memTemplParams" colspan="2"><a id="a2ce418019d56f20075a3f3ebe3632019"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2ce418019d56f20075a3f3ebe3632019"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a> &gt;::cond &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a2ce418019d56f20075a3f3ebe3632019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eb13f5515d8d389b0e66bf3f504990"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a64eb13f5515d8d389b0e66bf3f504990"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a64eb13f5515d8d389b0e66bf3f504990">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, typename tfel::typetraits::BaseType&lt; typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt;::type &gt; &amp;)</td></tr>
<tr class="separator:a64eb13f5515d8d389b0e66bf3f504990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6228a325afa6dbdd59b873dc407accfe"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a6228a325afa6dbdd59b873dc407accfe"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6228a325afa6dbdd59b873dc407accfe">computeVelocityGradientDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a6228a325afa6dbdd59b873dc407accfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b44f3563509d13b946e599a19835469"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a8b44f3563509d13b946e599a19835469"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8b44f3563509d13b946e599a19835469">computeSpinRateDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a8b44f3563509d13b946e599a19835469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb784ecd22b5019f98ff195c4d39fee"><td class="memTemplParams" colspan="2"><a id="a1eb784ecd22b5019f98ff195c4d39fee"></a>
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a1eb784ecd22b5019f98ff195c4d39fee"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exportToBaseTypeArray</b> (const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt; &amp;t, OutputIterator p)</td></tr>
<tr class="separator:a1eb784ecd22b5019f98ff195c4d39fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc675a80461d4371136c4cbd76867945"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:adc675a80461d4371136c4cbd76867945"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u, tensor&lt; 1u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adc675a80461d4371136c4cbd76867945">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;t)</td></tr>
<tr class="separator:adc675a80461d4371136c4cbd76867945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51d11f17bbfa033739eca4188283cb6"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:af51d11f17bbfa033739eca4188283cb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u, tensor&lt; 2u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af51d11f17bbfa033739eca4188283cb6">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;t)</td></tr>
<tr class="separator:af51d11f17bbfa033739eca4188283cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea36ee98bb5cfa56846e99bc1a21a85"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a8ea36ee98bb5cfa56846e99bc1a21a85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u, tensor&lt; 3u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8ea36ee98bb5cfa56846e99bc1a21a85">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;t)</td></tr>
<tr class="separator:a8ea36ee98bb5cfa56846e99bc1a21a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794813b1d594cedc1ddc1123d339962"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a8794813b1d594cedc1ddc1123d339962"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8794813b1d594cedc1ddc1123d339962">computeDeterminantDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;F)</td></tr>
<tr class="separator:a8794813b1d594cedc1ddc1123d339962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1def6259b4510387389264540f65bc"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ade1def6259b4510387389264540f65bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ade1def6259b4510387389264540f65bc">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;t, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt;&gt;&gt; &amp;r)</td></tr>
<tr class="memdesc:ade1def6259b4510387389264540f65bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a tensor using a rotation matrix  <a href="#ade1def6259b4510387389264540f65bc">More...</a><br /></td></tr>
<tr class="separator:ade1def6259b4510387389264540f65bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88298f3795208cb7a3f51b0f8c67461b"><td class="memTemplParams" colspan="2"><a id="a88298f3795208cb7a3f51b0f8c67461b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a88298f3795208cb7a3f51b0f8c67461b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)), tensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;s)</td></tr>
<tr class="separator:a88298f3795208cb7a3f51b0f8c67461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123702915d09d1a19e2867a893ecc439"><td class="memTemplParams" colspan="2"><a id="a123702915d09d1a19e2867a893ecc439"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a123702915d09d1a19e2867a893ecc439"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)), tensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;s)</td></tr>
<tr class="separator:a123702915d09d1a19e2867a893ecc439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d9efa5e9954b4086ba097e3c28bfe0"><td class="memTemplParams" colspan="2"><a id="a37d9efa5e9954b4086ba097e3c28bfe0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a37d9efa5e9954b4086ba097e3c28bfe0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)), tensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;s)</td></tr>
<tr class="separator:a37d9efa5e9954b4086ba097e3c28bfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb353d9c41dccfb56f143c425cf75598"><td class="memTemplParams" colspan="2"><a id="acb353d9c41dccfb56f143c425cf75598"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:acb353d9c41dccfb56f143c425cf75598"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:acb353d9c41dccfb56f143c425cf75598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ec21709d5872f3f402f68874e0a59c"><td class="memTemplParams" colspan="2"><a id="ab5ec21709d5872f3f402f68874e0a59c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab5ec21709d5872f3f402f68874e0a59c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const T &amp;s)</td></tr>
<tr class="separator:ab5ec21709d5872f3f402f68874e0a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4b8c6cfcef79c3a4ed3ce3bf5314"><td class="memTemplParams" colspan="2"><a id="ae73d4b8c6cfcef79c3a4ed3ce3bf5314"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae73d4b8c6cfcef79c3a4ed3ce3bf5314"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==1u)), stensor&lt; 1u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;)</td></tr>
<tr class="separator:ae73d4b8c6cfcef79c3a4ed3ce3bf5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724865a9ea9a6f309d3a6efea8a72ebd"><td class="memTemplParams" colspan="2"><a id="a724865a9ea9a6f309d3a6efea8a72ebd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a724865a9ea9a6f309d3a6efea8a72ebd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==2u)), stensor&lt; 2u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;)</td></tr>
<tr class="separator:a724865a9ea9a6f309d3a6efea8a72ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2ac810a8d158480b2c821750e5c63"><td class="memTemplParams" colspan="2"><a id="a89c2ac810a8d158480b2c821750e5c63"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a89c2ac810a8d158480b2c821750e5c63"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==3u)), stensor&lt; 3u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;)</td></tr>
<tr class="separator:a89c2ac810a8d158480b2c821750e5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fc8eca8d13e71d1f96a0b543ed1cce"><td class="memTemplParams" colspan="2"><a id="a85fc8eca8d13e71d1f96a0b543ed1cce"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85fc8eca8d13e71d1f96a0b543ed1cce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 1u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeRightCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:a85fc8eca8d13e71d1f96a0b543ed1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bac469310c38c1b0c89b6778eca6b9"><td class="memTemplParams" colspan="2"><a id="a51bac469310c38c1b0c89b6778eca6b9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a51bac469310c38c1b0c89b6778eca6b9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 2u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeRightCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:a51bac469310c38c1b0c89b6778eca6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3467e9fcff1080e96e480b310fee702"><td class="memTemplParams" colspan="2"><a id="af3467e9fcff1080e96e480b310fee702"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af3467e9fcff1080e96e480b310fee702"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 3u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeRightCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:af3467e9fcff1080e96e480b310fee702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a970d09ceb50964e267f4d721cf16d"><td class="memTemplParams" colspan="2"><a id="ab2a970d09ceb50964e267f4d721cf16d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab2a970d09ceb50964e267f4d721cf16d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 1u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeLeftCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:ab2a970d09ceb50964e267f4d721cf16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cfdec1a16e17d683bbd33b63e5f0df"><td class="memTemplParams" colspan="2"><a id="a80cfdec1a16e17d683bbd33b63e5f0df"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a80cfdec1a16e17d683bbd33b63e5f0df"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 2u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeLeftCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:a80cfdec1a16e17d683bbd33b63e5f0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738f4aabcdd7018498b27e79670abd11"><td class="memTemplParams" colspan="2"><a id="a738f4aabcdd7018498b27e79670abd11"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a738f4aabcdd7018498b27e79670abd11"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 3u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeLeftCauchyGreenTensor</b> (const T &amp;)</td></tr>
<tr class="separator:a738f4aabcdd7018498b27e79670abd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac495f11d6170b1420b5d7d798dfa93fb"><td class="memTemplParams" colspan="2"><a id="ac495f11d6170b1420b5d7d798dfa93fb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac495f11d6170b1420b5d7d798dfa93fb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 1u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeGreenLagrangeTensor</b> (const T &amp;)</td></tr>
<tr class="separator:ac495f11d6170b1420b5d7d798dfa93fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d016e6cf225f92bfe26636e4eae379e"><td class="memTemplParams" colspan="2"><a id="a3d016e6cf225f92bfe26636e4eae379e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d016e6cf225f92bfe26636e4eae379e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 2u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeGreenLagrangeTensor</b> (const T &amp;)</td></tr>
<tr class="separator:a3d016e6cf225f92bfe26636e4eae379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e928b5c8d5c863dc33a8f10ca6651"><td class="memTemplParams" colspan="2"><a id="ace8e928b5c8d5c863dc33a8f10ca6651"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ace8e928b5c8d5c863dc33a8f10ca6651"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T &gt; &gt;::cond)), stensor&lt; 3u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeGreenLagrangeTensor</b> (const T &amp;)</td></tr>
<tr class="separator:ace8e928b5c8d5c863dc33a8f10ca6651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535198e44ccd223d50999bd79717df40"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a535198e44ccd223d50999bd79717df40"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a535198e44ccd223d50999bd79717df40">pushForward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a535198e44ccd223d50999bd79717df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc499d8825dbef42f03b63c76cff4b8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:afc499d8825dbef42f03b63c76cff4b8d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afc499d8825dbef42f03b63c76cff4b8d">pushForward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:afc499d8825dbef42f03b63c76cff4b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea6477448c90c8afd48dd0b3deda6fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a1ea6477448c90c8afd48dd0b3deda6fa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1ea6477448c90c8afd48dd0b3deda6fa">pushForward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a1ea6477448c90c8afd48dd0b3deda6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aee2955e4236a72590f8e344a440df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:aa4aee2955e4236a72590f8e344a440df"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa4aee2955e4236a72590f8e344a440df">push_forward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:aa4aee2955e4236a72590f8e344a440df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7925ab7557ee1c76de9ac549463ab4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a3f7925ab7557ee1c76de9ac549463ab4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3f7925ab7557ee1c76de9ac549463ab4">push_forward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a3f7925ab7557ee1c76de9ac549463ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdc53907f4decca8b784f36b0837292"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:affdc53907f4decca8b784f36b0837292"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#affdc53907f4decca8b784f36b0837292">push_forward</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:affdc53907f4decca8b784f36b0837292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b88bdf677c6033d0273b63af31abf1"><td class="memTemplParams" colspan="2"><a id="a61b88bdf677c6033d0273b63af31abf1"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a61b88bdf677c6033d0273b63af31abf1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertCauchyStressToSecondPiolaKirchhoffStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a61b88bdf677c6033d0273b63af31abf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f076d1b549485c7beedaccc4fdd0f0"><td class="memTemplParams" colspan="2"><a id="a30f076d1b549485c7beedaccc4fdd0f0"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a30f076d1b549485c7beedaccc4fdd0f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertCauchyStressToSecondPiolaKirchhoffStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a30f076d1b549485c7beedaccc4fdd0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f44345525868502761a4d7f150faef7"><td class="memTemplParams" colspan="2"><a id="a2f44345525868502761a4d7f150faef7"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a2f44345525868502761a4d7f150faef7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertCauchyStressToSecondPiolaKirchhoffStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a2f44345525868502761a4d7f150faef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f4cfd891eb15b7bbc5403b0b707fa3"><td class="memTemplParams" colspan="2"><a id="a83f4cfd891eb15b7bbc5403b0b707fa3"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a83f4cfd891eb15b7bbc5403b0b707fa3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertSecondPiolaKirchhoffStressToCauchyStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a83f4cfd891eb15b7bbc5403b0b707fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7e182df2d935a9de7e1a8556ca262c"><td class="memTemplParams" colspan="2"><a id="abb7e182df2d935a9de7e1a8556ca262c"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:abb7e182df2d935a9de7e1a8556ca262c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertSecondPiolaKirchhoffStressToCauchyStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:abb7e182df2d935a9de7e1a8556ca262c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631e8f691e12f2ae7f1c8fe66a5ebdee"><td class="memTemplParams" colspan="2"><a id="a631e8f691e12f2ae7f1c8fe66a5ebdee"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a631e8f691e12f2ae7f1c8fe66a5ebdee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertSecondPiolaKirchhoffStressToCauchyStress</b> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a631e8f691e12f2ae7f1c8fe66a5ebdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9852ec0e55f90e8baf001d5f44aa4e"><td class="memTemplParams" colspan="2"><a id="a3d9852ec0e55f90e8baf001d5f44aa4e"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a3d9852ec0e55f90e8baf001d5f44aa4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u, typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 3 &gt; &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a3d9852ec0e55f90e8baf001d5f44aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac020927948137a3f42e65fe6d58b8368"><td class="memTemplParams" colspan="2"><a id="ac020927948137a3f42e65fe6d58b8368"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ac020927948137a3f42e65fe6d58b8368"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u, typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 3 &gt; &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:ac020927948137a3f42e65fe6d58b8368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adc7a37a5e7e46e1e6a3cd23bc79a47"><td class="memTemplParams" colspan="2"><a id="a8adc7a37a5e7e46e1e6a3cd23bc79a47"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a8adc7a37a5e7e46e1e6a3cd23bc79a47"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u, typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 3 &gt; &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a8adc7a37a5e7e46e1e6a3cd23bc79a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef29ab009e320aafbe56640b1138d5"><td class="memTemplParams" colspan="2">template&lt;typename TensorResultType , typename TensorType &gt; </td></tr>
<tr class="memitem:a30ef29ab009e320aafbe56640b1138d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a30ef29ab009e320aafbe56640b1138d5">computeDeterminantDerivative</a> (TensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a30ef29ab009e320aafbe56640b1138d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a30ef29ab009e320aafbe56640b1138d5">More...</a><br /></td></tr>
<tr class="separator:a30ef29ab009e320aafbe56640b1138d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1542d42d4bc710bb45a18a51f1f6c49"><td class="memTemplParams" colspan="2">template&lt;typename TensorResultType , typename TensorType &gt; </td></tr>
<tr class="memitem:ac1542d42d4bc710bb45a18a51f1f6c49"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac1542d42d4bc710bb45a18a51f1f6c49">computeDeterminantDerivative</a> (TensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:ac1542d42d4bc710bb45a18a51f1f6c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#ac1542d42d4bc710bb45a18a51f1f6c49">More...</a><br /></td></tr>
<tr class="separator:ac1542d42d4bc710bb45a18a51f1f6c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34af96e08aed6a15c8993b5314a08abc"><td class="memTemplParams" colspan="2">template&lt;typename TensorResultType , typename TensorType &gt; </td></tr>
<tr class="memitem:a34af96e08aed6a15c8993b5314a08abc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a34af96e08aed6a15c8993b5314a08abc">computeDeterminantDerivative</a> (TensorResultType &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="memdesc:a34af96e08aed6a15c8993b5314a08abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a34af96e08aed6a15c8993b5314a08abc">More...</a><br /></td></tr>
<tr class="separator:a34af96e08aed6a15c8993b5314a08abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7199a1f17a66fb132f8d26ef51b559e"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </td></tr>
<tr class="memitem:aa7199a1f17a66fb132f8d26ef51b559e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorType2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;std::is_same&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt;::value &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; TensorType2 &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa7199a1f17a66fb132f8d26ef51b559e">polar_decomposition</a> (<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;, <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const TensorType2 &amp;)</td></tr>
<tr class="memdesc:aa7199a1f17a66fb132f8d26ef51b559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the polar decomposition of a tensor  <a href="#aa7199a1f17a66fb132f8d26ef51b559e">More...</a><br /></td></tr>
<tr class="separator:aa7199a1f17a66fb132f8d26ef51b559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf56171bc3bac63092798ba9a02e250d"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </td></tr>
<tr class="memitem:adf56171bc3bac63092798ba9a02e250d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorType2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;std::is_same&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt;::value &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; TensorType2 &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u)||(TensorTraits&lt; TensorType &gt;::dime==3u)), void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adf56171bc3bac63092798ba9a02e250d">polar_decomposition</a> (<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;, <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;, const TensorType2 &amp;)</td></tr>
<tr class="memdesc:adf56171bc3bac63092798ba9a02e250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the polar decomposition of a tensor  <a href="#adf56171bc3bac63092798ba9a02e250d">More...</a><br /></td></tr>
<tr class="separator:adf56171bc3bac63092798ba9a02e250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f942543869730a5ee2c6edf9aa40a7"><td class="memTemplParams" colspan="2"><a id="aa6f942543869730a5ee2c6edf9aa40a7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa6f942543869730a5ee2c6edf9aa40a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const T &amp;s)</td></tr>
<tr class="separator:aa6f942543869730a5ee2c6edf9aa40a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9288f3aea948a1147306a867cb2f498"><td class="memTemplParams" colspan="2"><a id="ab9288f3aea948a1147306a867cb2f498"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab9288f3aea948a1147306a867cb2f498"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==1u)), stensor&lt; 1u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;t)</td></tr>
<tr class="separator:ab9288f3aea948a1147306a867cb2f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f34f6ff12dc9f852c7ea6c2376903dc"><td class="memTemplParams" colspan="2"><a id="a2f34f6ff12dc9f852c7ea6c2376903dc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f34f6ff12dc9f852c7ea6c2376903dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==2u)), stensor&lt; 2u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;t)</td></tr>
<tr class="separator:a2f34f6ff12dc9f852c7ea6c2376903dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b9d9cc69377271b7ceab5f550f50f1"><td class="memTemplParams" colspan="2"><a id="a18b9d9cc69377271b7ceab5f550f50f1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a18b9d9cc69377271b7ceab5f550f50f1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T &gt;::dime==3u)), stensor&lt; 3u, TensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const T &amp;t)</td></tr>
<tr class="separator:a18b9d9cc69377271b7ceab5f550f50f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43274179e8c8bc2699ce0382dfff522f"><td class="memTemplParams" colspan="2"><a id="a43274179e8c8bc2699ce0382dfff522f"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a43274179e8c8bc2699ce0382dfff522f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>matrix_view</b> (<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::type, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, TensorNumType&lt; typename std::decay&lt; decltype(t)&gt;::type &gt;&gt;, MatrixViewFromTensorExpr&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:a43274179e8c8bc2699ce0382dfff522f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4647c6ff8c75ae54c586b04942131d4"><td class="memTemplParams" colspan="2"><a id="aa4647c6ff8c75ae54c586b04942131d4"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aa4647c6ff8c75ae54c586b04942131d4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::type, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; typename std::decay&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::type &gt;::dime==1u), Expr&lt; tensor&lt; 1u, TensorNumType&lt; typename std::decay&lt; decltype(t)&gt;::type &gt;&gt;, TensorTransposeExpr1D&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:aa4647c6ff8c75ae54c586b04942131d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171ceede8daa6d044991e62768ed67ee"><td class="memTemplParams" colspan="2"><a id="a171ceede8daa6d044991e62768ed67ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a171ceede8daa6d044991e62768ed67ee"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a171ceede8daa6d044991e62768ed67ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa243e677b22eccdea1b41ba55b1507f3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa243e677b22eccdea1b41ba55b1507f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==1u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa243e677b22eccdea1b41ba55b1507f3">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:aa243e677b22eccdea1b41ba55b1507f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543c1830d1119e6d6335f362df35c633"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a543c1830d1119e6d6335f362df35c633"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==2u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a543c1830d1119e6d6335f362df35c633">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a543c1830d1119e6d6335f362df35c633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfa3fedcc396f6093a70c4b45814235"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abcfa3fedcc396f6093a70c4b45814235"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==3u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abcfa3fedcc396f6093a70c4b45814235">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:abcfa3fedcc396f6093a70c4b45814235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a74e56e19ca534fc78e8e2f20f99825"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a1a74e56e19ca534fc78e8e2f20f99825"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u, tensor&lt; 1u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1a74e56e19ca534fc78e8e2f20f99825">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a1a74e56e19ca534fc78e8e2f20f99825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1131967a86e0cba214e77bdbd68f760e"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a1131967a86e0cba214e77bdbd68f760e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u, tensor&lt; 2u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1131967a86e0cba214e77bdbd68f760e">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:a1131967a86e0cba214e77bdbd68f760e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83ca5ff0a3b4070beea83ef90f2e75e"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:af83ca5ff0a3b4070beea83ef90f2e75e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u, tensor&lt; 3u, typename ComputeBinaryResult&lt; tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt; &gt;, TensorNumType&lt; TensorType &gt;, OpDiv &gt;::Result &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af83ca5ff0a3b4070beea83ef90f2e75e">invert</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;)</td></tr>
<tr class="separator:af83ca5ff0a3b4070beea83ef90f2e75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72f7599fdd99f41c76daaf770eecb77"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ad72f7599fdd99f41c76daaf770eecb77"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad72f7599fdd99f41c76daaf770eecb77">change_basis</a> (const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt;&gt;&gt; &amp;)</td></tr>
<tr class="memdesc:ad72f7599fdd99f41c76daaf770eecb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a tensor using a rotation matrix  <a href="#ad72f7599fdd99f41c76daaf770eecb77">More...</a><br /></td></tr>
<tr class="separator:ad72f7599fdd99f41c76daaf770eecb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24378dd0da25482ebd26bcf483d48dc9"><td class="memTemplParams" colspan="2"><a id="a24378dd0da25482ebd26bcf483d48dc9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24378dd0da25482ebd26bcf483d48dc9"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)), tensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;)</td></tr>
<tr class="separator:a24378dd0da25482ebd26bcf483d48dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a65cf8f88cf84af4a0dfe567a73c5fd"><td class="memTemplParams" colspan="2"><a id="a2a65cf8f88cf84af4a0dfe567a73c5fd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2a65cf8f88cf84af4a0dfe567a73c5fd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)), tensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;)</td></tr>
<tr class="separator:a2a65cf8f88cf84af4a0dfe567a73c5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f1e14d2f33d15ffdfcbc6cd0af9f43"><td class="memTemplParams" colspan="2"><a id="a00f1e14d2f33d15ffdfcbc6cd0af9f43"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a00f1e14d2f33d15ffdfcbc6cd0af9f43"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)), tensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsyme</b> (const T &amp;)</td></tr>
<tr class="separator:a00f1e14d2f33d15ffdfcbc6cd0af9f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memTemplParams" colspan="2"><a id="a05f4e4b81aa24f4b7a034c15c08ae69a"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efb662f0e25b4e9876e32cafe589108"><td class="memTemplParams" colspan="2"><a id="a4efb662f0e25b4e9876e32cafe589108"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4efb662f0e25b4e9876e32cafe589108"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt; &amp;)</td></tr>
<tr class="separator:a4efb662f0e25b4e9876e32cafe589108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memTemplParams" colspan="2"><a id="a16e6bf086ae830e33cd39fcafdc29f37"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memTemplParams" colspan="2"><a id="a14e2f92a9b08a94e2cca7ee54b556a33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt; &amp;)</td></tr>
<tr class="separator:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , unsigned short N&gt; </td></tr>
<tr class="memitem:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, typename std::result_of&lt; F(T)&gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a302fcc3dcd4eab55fb584c3465e2e8aa">map</a> (F, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new tvector by applying a functor  <a href="#a302fcc3dcd4eab55fb584c3465e2e8aa">More...</a><br /></td></tr>
<tr class="separator:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e9be366d6ab137da2a090ac3b97754"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a05e9be366d6ab137da2a090ac3b97754"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a05e9be366d6ab137da2a090ac3b97754">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, OutputIterator)</td></tr>
<tr class="separator:a05e9be366d6ab137da2a090ac3b97754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffaaab80f308d5fd407efcecf405178"><td class="memTemplParams" colspan="2"><a id="a6ffaaab80f308d5fd407efcecf405178"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a6ffaaab80f308d5fd407efcecf405178"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a6ffaaab80f308d5fd407efcecf405178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5de08fae58f6088ce519ec296c0a67"><td class="memTemplParams" colspan="2"><a id="a0e5de08fae58f6088ce519ec296c0a67"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e5de08fae58f6088ce519ec296c0a67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 1u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector1D</b> (const T)</td></tr>
<tr class="separator:a0e5de08fae58f6088ce519ec296c0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memTemplParams" colspan="2"><a id="a3048a1ee4df7868d5c78f1c490eb998e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector2D</b> (const T, const T)</td></tr>
<tr class="separator:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32e06c219189f4e88c71c4f6311938"><td class="memTemplParams" colspan="2"><a id="add32e06c219189f4e88c71c4f6311938"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add32e06c219189f4e88c71c4f6311938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector3D</b> (const T, const T, const T)</td></tr>
<tr class="separator:add32e06c219189f4e88c71c4f6311938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memTemplParams" colspan="2"><a id="a5631275fe3ba3b491e6dd7e6f3147cf9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt; &amp;, const tvector&lt; 2u, T &gt; &amp;)</td></tr>
<tr class="separator:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memTemplParams" colspan="2"><a id="aaddef4e732fbd8c38d696fdc530e90fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const tvector&lt; 3u, T &gt; &amp;)</td></tr>
<tr class="separator:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b7ba97d16e5ab2f5b2efa56b6640bf3">find_perpendicular_vector</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const tvector&lt; 3u, T &gt; &amp;)</td></tr>
<tr class="separator:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00319af6a24fdc8c05a3ed6d827c7523"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a00319af6a24fdc8c05a3ed6d827c7523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N-I, N, I, T, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a00319af6a24fdc8c05a3ed6d827c7523">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:a00319af6a24fdc8c05a3ed6d827c7523"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#a00319af6a24fdc8c05a3ed6d827c7523">More...</a><br /></td></tr>
<tr class="separator:a00319af6a24fdc8c05a3ed6d827c7523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8d1e317a1e54c271c32421ae9166e3"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a8e8d1e317a1e54c271c32421ae9166e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J-I, N, I, T, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8e8d1e317a1e54c271c32421ae9166e3">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:a8e8d1e317a1e54c271c32421ae9166e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#a8e8d1e317a1e54c271c32421ae9166e3">More...</a><br /></td></tr>
<tr class="separator:a8e8d1e317a1e54c271c32421ae9166e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae353f051ba77ffcefd1d9f3e9f35245a"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ae353f051ba77ffcefd1d9f3e9f35245a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N-I, N, I, T, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae353f051ba77ffcefd1d9f3e9f35245a">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:ae353f051ba77ffcefd1d9f3e9f35245a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#ae353f051ba77ffcefd1d9f3e9f35245a">More...</a><br /></td></tr>
<tr class="separator:ae353f051ba77ffcefd1d9f3e9f35245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa566d4ddc064aefa69aaa820d9aa315"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:aaa566d4ddc064aefa69aaa820d9aa315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J-I, N, I, T, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaa566d4ddc064aefa69aaa820d9aa315">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:aaa566d4ddc064aefa69aaa820d9aa315"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector (const version)  <a href="#aaa566d4ddc064aefa69aaa820d9aa315">More...</a><br /></td></tr>
<tr class="separator:aaa566d4ddc064aefa69aaa820d9aa315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memTemplParams" colspan="2"><a id="a3afa7af5d0f55bb8b74a9a5383ec6e38"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, typename T , bool b&gt; </td></tr>
<tr class="memitem:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N, Mn, In, T, b &gt; &gt; &amp;)</td></tr>
<tr class="separator:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d1c6351f7f9aaef376d03446012741"><td class="memTemplParams" colspan="2"><a id="a75d1c6351f7f9aaef376d03446012741"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, unsigned short Nn, typename T &gt; </td></tr>
<tr class="memitem:a75d1c6351f7f9aaef376d03446012741"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; Nn, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view_expr.html">TinyVectorOfStensorFromTinyVectorViewExpr</a>&lt; N, Mn, In, Nn, T &gt; &gt; &amp;)</td></tr>
<tr class="separator:a75d1c6351f7f9aaef376d03446012741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bba9b97fe1241ad76a414704f426f97"><td class="memTemplParams" colspan="2"><a id="a0bba9b97fe1241ad76a414704f426f97"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, unsigned short Nn, typename T &gt; </td></tr>
<tr class="memitem:a0bba9b97fe1241ad76a414704f426f97"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; Nn, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorOfTinyVectorFromTinyVectorViewExpr</a>&lt; N, Mn, In, Nn, T &gt; &gt; &amp;)</td></tr>
<tr class="separator:a0bba9b97fe1241ad76a414704f426f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682abb0b99c9cbf6cc9d0c33efbc4ed0"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a682abb0b99c9cbf6cc9d0c33efbc4ed0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a682abb0b99c9cbf6cc9d0c33efbc4ed0">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v, OutputIterator p)</td></tr>
<tr class="separator:a682abb0b99c9cbf6cc9d0c33efbc4ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b26e86325177b517960e9c99f8ad84"><td class="memTemplParams" colspan="2"><a id="a80b26e86325177b517960e9c99f8ad84"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a80b26e86325177b517960e9c99f8ad84"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;vec)</td></tr>
<tr class="separator:a80b26e86325177b517960e9c99f8ad84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfd390603da694737c9329a6120b74e"><td class="memTemplParams" colspan="2"><a id="afdfd390603da694737c9329a6120b74e"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:afdfd390603da694737c9329a6120b74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:afdfd390603da694737c9329a6120b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplParams" colspan="2"><a id="a8170997bd1d8dec188c9438e592ae222"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="separator:a8170997bd1d8dec188c9438e592ae222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce98d089c934be02b3240c0637c724a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ce98d089c934be02b3240c0637c724a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1ce98d089c934be02b3240c0637c724a">norm</a> (const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a1ce98d089c934be02b3240c0637c724a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a vector  <a href="#a1ce98d089c934be02b3240c0637c724a">More...</a><br /></td></tr>
<tr class="separator:a1ce98d089c934be02b3240c0637c724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9784cd1acd370b527848ad084af32"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6cf9784cd1acd370b527848ad084af32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6cf9784cd1acd370b527848ad084af32">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a6cf9784cd1acd370b527848ad084af32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc650bafc400ecfc2740b09eb0dfad"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a12fc650bafc400ecfc2740b09eb0dfad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a>&lt; T1 &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T1, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a12fc650bafc400ecfc2740b09eb0dfad">norm</a> (const T1 &amp;)</td></tr>
<tr class="memdesc:a12fc650bafc400ecfc2740b09eb0dfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a tvector  <a href="#a12fc650bafc400ecfc2740b09eb0dfad">More...</a><br /></td></tr>
<tr class="separator:a12fc650bafc400ecfc2740b09eb0dfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f443c0e09b6facab40820e2d94ca33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26f443c0e09b6facab40820e2d94ca33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a26f443c0e09b6facab40820e2d94ca33">norm</a> (const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a26f443c0e09b6facab40820e2d94ca33"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a vector  <a href="#a26f443c0e09b6facab40820e2d94ca33">More...</a><br /></td></tr>
<tr class="separator:a26f443c0e09b6facab40820e2d94ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains various classes and functions dÃ©fining mathematical objects and numerical algorithms. </p>
<h1><a class="anchor" id="Tensorial"></a>
Tensorial objects</h1>
<p>The <code>TFEL/Math</code> library provides two classes for second order tensors:</p><ul>
<li>The <code>stensor</code> class which describes <em>symmetric</em> second order tensors.</li>
<li>The <code>tensor</code> class which describes general second order (symmetric and unsymmetric) tensors.</li>
</ul>
<p>Fourth order tensors are linear transformations of second order tensors. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab0ea413b09d061d87404c592457b8214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ea413b09d061d87404c592457b8214">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ab0ea413b09d061d87404c592457b8214">tfel::math::acceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an acceleration. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e" title="Declares the Acceleration unit. ">Acceleration</a> </dd></dl>

</div>
</div>
<a id="a8e7809b7b7e3800ebc6fea939690938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7809b7b7e3800ebc6fea939690938e">&#9670;&nbsp;</a></span>Acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">tfel::math::Acceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Acceleration unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="afca7dcdc304bb2813a61e03b923ad68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7dcdc304bb2813a61e03b923ad68a">&#9670;&nbsp;</a></span>ampere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a>&gt; <a class="el" href="namespacetfel_1_1math.html#afca7dcdc304bb2813a61e03b923ad68a">tfel::math::ampere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an ampere. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e" title="Declares the Ampere unit. ">Ampere</a> </dd></dl>

</div>
</div>
<a id="a4c502ed4a6dd50e17f17022f7327d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c502ed4a6dd50e17f17022f7327d74e">&#9670;&nbsp;</a></span>Ampere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,1,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">tfel::math::Ampere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Ampere unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a3ed3cb42e97e262d9a0aedcd40bf0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed3cb42e97e262d9a0aedcd40bf0aca">&#9670;&nbsp;</a></span>candela</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a3ed3cb42e97e262d9a0aedcd40bf0aca">tfel::math::candela</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a candela. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992" title="Declares the Candela unit. ">Candela</a> </dd></dl>

</div>
</div>
<a id="a6c9f10c92636c52b23d750dc1d146992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9f10c92636c52b23d750dc1d146992">&#9670;&nbsp;</a></span>Candela</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,0,1,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">tfel::math::Candela</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Candela unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a037360e732078b2d8b6bee5f80a0c819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037360e732078b2d8b6bee5f80a0c819">&#9670;&nbsp;</a></span>Complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">tfel::math::Complex</a> = typedef <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt;ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValueType,underlying</td><td>type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structstd_1_1complex.html">std::complex</a>. </dd></dl>

</div>
</div>
<a id="a7aac068b26a121174ac002a67805e86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac068b26a121174ac002a67805e86c">&#9670;&nbsp;</a></span>Density</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-3,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a7aac068b26a121174ac002a67805e86c">tfel::math::Density</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Density unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ade22387cb208d66abb4cf8cf1bcbd76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22387cb208d66abb4cf8cf1bcbd76f">&#9670;&nbsp;</a></span>Energy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,2,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ade22387cb208d66abb4cf8cf1bcbd76f">tfel::math::Energy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Energy unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a31a34e2674b7e7563d24f1550c17f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a34e2674b7e7563d24f1550c17f649">&#9670;&nbsp;</a></span>EnergyDensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a31a34e2674b7e7563d24f1550c17f649">tfel::math::EnergyDensity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the EnergyDensity unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ae4753cbd852f9c874ade45013232ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4753cbd852f9c874ade45013232ba78">&#9670;&nbsp;</a></span>force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ae4753cbd852f9c874ade45013232ba78">tfel::math::force</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a force. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e" title="Declares the Momentum unit. ">Force</a> </dd></dl>

</div>
</div>
<a id="a898eea1d4e2c1327c6234c96102c970e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898eea1d4e2c1327c6234c96102c970e">&#9670;&nbsp;</a></span>Force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">tfel::math::Force</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a4ec6d506c79e1d01840880bc03a54df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec6d506c79e1d01840880bc03a54df4">&#9670;&nbsp;</a></span>Frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4ec6d506c79e1d01840880bc03a54df4">tfel::math::Frequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Frequency unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a780717c8aea48d1f920aabd64af09270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780717c8aea48d1f920aabd64af09270">&#9670;&nbsp;</a></span>invlength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a780717c8aea48d1f920aabd64af09270">tfel::math::invlength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a invlength. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130" title="Declares the InvLength unit. ">InvLength</a> </dd></dl>

</div>
</div>
<a id="a4cafc93655e0e08a3438947be78f1130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafc93655e0e08a3438947be78f1130">&#9670;&nbsp;</a></span>InvLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,-1,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130">tfel::math::InvLength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvLength unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a9a1838b2eecf37fb347a5efb709afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1838b2eecf37fb347a5efb709afed4">&#9670;&nbsp;</a></span>InvTemperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,-1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a9a1838b2eecf37fb347a5efb709afed4">tfel::math::InvTemperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvTemperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8b7684b7496f5c9bd09f2947b5b8d537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7684b7496f5c9bd09f2947b5b8d537">&#9670;&nbsp;</a></span>Kelvin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8b7684b7496f5c9bd09f2947b5b8d537">tfel::math::Kelvin</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Kelvin unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a06d97ccd2592515a92ba2a4eb662bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d97ccd2592515a92ba2a4eb662bb4b">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a06d97ccd2592515a92ba2a4eb662bb4b">tfel::math::length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a length. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f" title="Declares the Length unit. ">Length</a> </dd></dl>

</div>
</div>
<a id="aeab4cd4dbbabfa81beade7e23a81aa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab4cd4dbbabfa81beade7e23a81aa9f">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">tfel::math::Length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Length unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a1b9fe942a2790b56c3082717ed99ef2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9fe942a2790b56c3082717ed99ef2b">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a1b9fe942a2790b56c3082717ed99ef2b">tfel::math::mass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a mass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f" title="Declares the Mass unit. ">Mass</a> </dd></dl>

</div>
</div>
<a id="a0f6aaddfab53e1c567c1f210d3031d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6aaddfab53e1c567c1f210d3031d7f">&#9670;&nbsp;</a></span>Mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,0,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">tfel::math::Mass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mass unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a60efadb57e60e9757e189196f3667e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60efadb57e60e9757e189196f3667e68">&#9670;&nbsp;</a></span>mole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a60efadb57e60e9757e189196f3667e68">tfel::math::mole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a mole. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4" title="Declares the Mole unit. ">Mole</a> </dd></dl>

</div>
</div>
<a id="af22c96cecfa5347958619e2672a9e0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c96cecfa5347958619e2672a9e0e4">&#9670;&nbsp;</a></span>Mole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,0,0,1&gt;::type <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">tfel::math::Mole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mole unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8ff986de4d5db9845fdb1ed04f5ba6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff986de4d5db9845fdb1ed04f5ba6f2">&#9670;&nbsp;</a></span>momentum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a8ff986de4d5db9845fdb1ed04f5ba6f2">tfel::math::momentum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a momentum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6" title="Declares the Momentum unit. ">Momentum</a> </dd></dl>

</div>
</div>
<a id="a95dd04d79c3a9114074eda5a6080fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd04d79c3a9114074eda5a6080fbc6">&#9670;&nbsp;</a></span>Momentum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">tfel::math::Momentum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="adc5a1bcf7b721fde538e7a19f99bbd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5a1bcf7b721fde538e7a19f99bbd36">&#9670;&nbsp;</a></span>Newton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#adc5a1bcf7b721fde538e7a19f99bbd36">tfel::math::Newton</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Newton unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a0066b6a6803bbb311c229240d6b6263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0066b6a6803bbb311c229240d6b6263b">&#9670;&nbsp;</a></span>Pressure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a0066b6a6803bbb311c229240d6b6263b">tfel::math::Pressure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Pressure unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a5240f42645c61228638106cf2724850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5240f42645c61228638106cf2724850a">&#9670;&nbsp;</a></span>Stress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a5240f42645c61228638106cf2724850a">tfel::math::Stress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Stress unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a9e5861e18a76bb1552c699bdebe327c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5861e18a76bb1552c699bdebe327c2">&#9670;&nbsp;</a></span>StressRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-3,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a9e5861e18a76bb1552c699bdebe327c2">tfel::math::StressRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the StressRate unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ad522fc0823cac19370b9ade552cc679f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad522fc0823cac19370b9ade552cc679f">&#9670;&nbsp;</a></span>temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ad522fc0823cac19370b9ade552cc679f">tfel::math::temperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a temperature. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7" title="Declares the Temperature unit. ">Temperature</a> </dd></dl>

</div>
</div>
<a id="aaf2a11fc25b0491377347962a2219cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a11fc25b0491377347962a2219cf7">&#9670;&nbsp;</a></span>Temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">tfel::math::Temperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Temperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a3215b75eb5815603d8919a02502241da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3215b75eb5815603d8919a02502241da">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a3215b75eb5815603d8919a02502241da">tfel::math::time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5" title="Declares the Time unit. ">Time</a> </dd></dl>

</div>
</div>
<a id="ad1f1c4734361bfe475e361a040a1ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1c4734361bfe475e361a040a1ece5">&#9670;&nbsp;</a></span>Time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">tfel::math::Time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Time unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a30a10ed49c61273a39121565bb011e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a10ed49c61273a39121565bb011e11">&#9670;&nbsp;</a></span>velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a30a10ed49c61273a39121565bb011e11">tfel::math::velocity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a velocity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed" title="Declares the Velocity unit. ">Velocity</a> </dd></dl>

</div>
</div>
<a id="a6b4c6c3374a01fa6e86eadcf85cb55ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c6c3374a01fa6e86eadcf85cb55ed">&#9670;&nbsp;</a></span>Velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">tfel::math::Velocity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Velocity unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac5d7f8a51d1334ee908052c599d65152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d7f8a51d1334ee908052c599d65152">&#9670;&nbsp;</a></span>absolute_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::absolute_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the absolute value of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2169810ee26a815468913ce8ddfc4c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2169810ee26a815468913ce8ddfc4c31">&#9670;&nbsp;</a></span>absolute_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::absolute_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the absolute value of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25be866f4fe5021c58672780177c7825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25be866f4fe5021c58672780177c7825">&#9670;&nbsp;</a></span>broyden() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a8437c41fb14f7fbda25b1f07c9dcbf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8437c41fb14f7fbda25b1f07c9dcbf94">&#9670;&nbsp;</a></span>broyden() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a7d43a352f91a795ab4c35cc9cdb69d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d43a352f91a795ab4c35cc9cdb69d44">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the second Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="ab12b80ec6e7aad8e4d37e970ecdc0a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12b80ec6e7aad8e4d37e970ecdc0a9d">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a64eb13f5515d8d389b0e66bf3f504990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eb13f5515d8d389b0e66bf3f504990">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>,<a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::NumType&gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, typename tfel::typetraits::BaseType&lt; typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e323743f1ba98ca8b53759c2d10948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e323743f1ba98ca8b53759c2d10948">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>,<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; ST2toST2NumType&lt; ST2toST2Type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72f7599fdd99f41c76daaf770eecb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72f7599fdd99f41c76daaf770eecb77">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate a tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated tensor </dd></dl>

</div>
</div>
<a id="a7971be7e717e9a9cf128ba7b193b5f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7971be7e717e9a9cf128ba7b193b5f75">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>,<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; ST2toST2NumType&lt; ST2toST2Type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade1def6259b4510387389264540f65bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1def6259b4510387389264540f65bc">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; TensorNumType&lt; TensorType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate a tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated tensor </dd></dl>

</div>
</div>
<a id="a1ca87552de0f863d70b6a1d703d901d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca87552de0f863d70b6a1d703d901d0">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>,<a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::NumType&gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a>&lt; 3u, 3u, typename tfel::typetraits::BaseType&lt; typename T2toT2Traits&lt; T2toT2Type &gt;::NumType &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7daa8861aa92e086a2d9b5a6906f9178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daa8861aa92e086a2d9b5a6906f9178">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime, StensorNumType&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate a symmetric tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated symmetric tensor </dd></dl>

</div>
</div>
<a id="a5c79fd0ecece57dfbd922e1bab808ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c79fd0ecece57dfbd922e1bab808ae7">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime, StensorNumType&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt; &gt; &gt;::type tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate a symmetric tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated symmetric tensor </dd></dl>

</div>
</div>
<a id="a61cd910684db930e8cda9bdbbbe63753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cd910684db930e8cda9bdbbbe63753">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>dt_K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative with respect to the deformation gradient </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a293c74353557edd1f43dc1116383112a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293c74353557edd1f43dc1116383112a">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;::type tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fdd492d1e25faa303d381466b6bcaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdd492d1e25faa303d381466b6bcaec">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78f1578038b0ba7f1a389cee4ee99854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f1578038b0ba7f1a389cee4ee99854">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8d98eb3a12bbcc75337ad265d3de93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d98eb3a12bbcc75337ad265d3de93b">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8794813b1d594cedc1ddc1123d339962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794813b1d594cedc1ddc1123d339962">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ef29ab009e320aafbe56640b1138d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ef29ab009e320aafbe56640b1138d5">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorResultType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">TensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1542d42d4bc710bb45a18a51f1f6c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1542d42d4bc710bb45a18a51f1f6c49">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorResultType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">TensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34af96e08aed6a15c8993b5314a08abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34af96e08aed6a15c8993b5314a08abc">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorResultType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorResultType, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u &amp;&amp;TensorTraits&lt; TensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; TensorNumType&lt; TensorType &gt;, Power&lt; 2 &gt; &gt;::Result, TensorNumType&lt; TensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">TensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43c79bd81d4b00e7aa495f6e84ad3216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c79bd81d4b00e7aa495f6e84ad3216">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b4e4b763ec347c71640d32c62edf11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4e4b763ec347c71640d32c62edf11f">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b3a94084e251d7cbd3fc750619ad16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3a94084e251d7cbd3fc750619ad16b">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 2u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2725b637462fab4a4ac6a204c5501837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725b637462fab4a4ac6a204c5501837">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 1u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ccba02c18c51f533d918112b5c4d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccba02c18c51f533d918112b5c4d3c3">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 2u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe23a77442bfcee2b07b96fbe261280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe23a77442bfcee2b07b96fbe261280">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsScalar&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond, t2tot2&lt; 3u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68563659f50ac9407e7349dc2fceda51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68563659f50ac9407e7349dc2fceda51">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b9428b6ac31588505a6ce0af11ca76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9428b6ac31588505a6ce0af11ca76b">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a170f2faf600a8f4e18de8a686eff32d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170f2faf600a8f4e18de8a686eff32d5">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorResultType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorResultType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeUnaryResult&lt; StensorNumType&lt; StensorType &gt;, Power&lt; 2 &gt; &gt;::Result, StensorNumType&lt; StensorResultType &gt; &gt;::cond, void &gt;::type tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e08f6c5e1ced67af3738039404268a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e08f6c5e1ced67af3738039404268a">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;::type tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant of the deviator of symmetric tensor.</dd></dl>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial J_{3}}{\partial \underline{\sigma}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d1e170c96f723dcdb8d10efba56928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d1e170c96f723dcdb8d10efba56928">&#9670;&nbsp;</a></span>computeDeviatorDeterminantSecondDerivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::computeDeviatorDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of the deviator of symmetric tensor. </p>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a558ebb9cd6ff24db0bd7211a9bfd2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ebb9cd6ff24db0bd7211a9bfd2ec3">&#9670;&nbsp;</a></span>computeDeviatorDeterminantSecondDerivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 2u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::computeDeviatorDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of the deviator of symmetric tensor. </p>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae21fa3429224fc8efc6113232147e8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21fa3429224fc8efc6113232147e8d7">&#9670;&nbsp;</a></span>computeDeviatorDeterminantSecondDerivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsScalar&lt; StensorNumType&lt; StensorType &gt; &gt;::cond, st2tost2&lt; 3u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::computeDeviatorDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of determinant of the deviator of a symmetric tensor with respect to this tensor. </p>
<p>compute the second derivative of the determinant of the deviator of symmetric tensor.</p>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<p>[ </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor</td></tr>
  </table>
  </dd>
</dl>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66cd06e5ea0ac31879d2fe5f1f7976c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cd06e5ea0ac31879d2fe5f1f7976c8">&#9670;&nbsp;</a></span>computeIsotropicFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type tfel::math::computeIsotropicFunction </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad157d56dc36fe1e815ed0032ddc1496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad157d56dc36fe1e815ed0032ddc1496b">&#9670;&nbsp;</a></span>computeIsotropicFunctionDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt;::type tfel::math::computeIsotropicFunctionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4742d68c54d3384ef417ba06d50f437e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4742d68c54d3384ef417ba06d50f437e">&#9670;&nbsp;</a></span>computeIsotropicFunctionDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond, std::pair&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime, StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt; &gt; &gt; &gt;::type tfel::math::computeIsotropicFunctionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20c8ff73ba6f9a3895d00451d5663f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20c8ff73ba6f9a3895d00451d5663f1">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dt_K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab205ca9f0bd230231ce30a86f9fd9c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab205ca9f0bd230231ce30a86f9fd9c1b">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::NumType &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &gt;::NumType, typename <a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::NumType, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;::type tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd3a1b75130eb7e6eb635ab62ba13a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd3a1b75130eb7e6eb635ab62ba13a7">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==1u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==1u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==1u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==1u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adfb93509e4744f44572672a647991b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adfb93509e4744f44572672a647991b">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==2u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==2u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==2u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==2u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96cf37eaee230e356d769ed087a8d9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf37eaee230e356d769ed087a8d9e9">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2toST2ResultType, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_traits.html">T2toST2Traits</a>&lt; T2toST2ResultType &gt;::dime==3u &amp;&amp;T2toST2Traits&lt; T2toST2Type &gt;::dime==3u &amp;&amp;StensorTraits&lt; StensorType &gt;::dime==3u &amp;&amp;TensorTraits&lt; TensorType &gt;::dime==3u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; typename TensorTraits&lt; TensorType &gt;::NumType &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; typename T2toST2Traits&lt; T2toST2Type &gt;::NumType, typename StensorTraits&lt; StensorType &gt;::NumType, OpPlus &gt;::Result, typename T2toST2Traits&lt; T2toST2ResultType &gt;::NumType &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_type.html">T2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a579991c89e94c54de38167191abdb24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579991c89e94c54de38167191abdb24c">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u), t2tost2&lt; 1u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa04b95294acd87f2f2911a67ede6de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04b95294acd87f2f2911a67ede6de6e">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; (<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond)&amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime==1u), t2tost2&lt;1u,typename TensorTraits&lt;TensorType&gt;::NumType&gt; &gt;::type tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88698b371152d85460a5da45dbf16f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88698b371152d85460a5da45dbf16f5a">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u), t2tost2&lt; 2u, typename TensorTraits&lt; TensorType &gt;::NumType &gt; &gt;::type tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74d2f30e1fba079ab33257ad9cc2c49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d2f30e1fba079ab33257ad9cc2c49b">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; (<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond)&amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime==3u), t2tost2&lt;3u,typename TensorTraits&lt;TensorType&gt;::NumType&gt; &gt;::type tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b44f3563509d13b946e599a19835469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b44f3563509d13b946e599a19835469">&#9670;&nbsp;</a></span>computeSpinRateDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::NumType&gt; &gt;::type tfel::math::computeSpinRateDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the spin rate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04a8b8702b48d2b140d04e36906ff50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04a8b8702b48d2b140d04e36906ff50">&#9670;&nbsp;</a></span>computeSpinRateDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::NumType&gt; &gt;::type tfel::math::computeSpinRateDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the spin rate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab352e027dc963ea8495a0c58eb8d9337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab352e027dc963ea8495a0c58eb8d9337">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a1fb54d6568602a3841e69ce268a007d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb54d6568602a3841e69ce268a007d9">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a9633e725d813af5e009e18fa34e309a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9633e725d813af5e009e18fa34e309a4">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DNPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; NPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DNPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; NPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DNPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a9e01564b9eaefb9ae07a96d49baeefe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e01564b9eaefb9ae07a96d49baeefe4">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a2f8ec0deff3d579216e6d7216f323fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8ec0deff3d579216e6d7216f323fe5">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a554002f1479e543b8bf164b6e2778b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554002f1479e543b8bf164b6e2778b4f">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; DPPType, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; PPType, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; DPPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; PPType &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; tfel::typetraits::base_type&lt; StensorNumType&lt; StensorType &gt; &gt;, ST2toST2NumType&lt; DPPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a></td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a6228a325afa6dbdd59b873dc407accfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6228a325afa6dbdd59b873dc407accfe">&#9670;&nbsp;</a></span>computeVelocityGradientDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::NumType&gt; &gt;::type tfel::math::computeVelocityGradientDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the velocity gradient </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24942210fbf8076dfa462303a1ffae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24942210fbf8076dfa462303a1ffae17">&#9670;&nbsp;</a></span>computeVelocityGradientDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime, typename <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::NumType&gt; &gt;::type tfel::math::computeVelocityGradientDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the velocity gradient </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d9548efe16e0e0a3cb28210d7a8837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9548efe16e0e0a3cb28210d7a8837a">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==1u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==1u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a2c14367e6c2d075da58270b871dd7d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c14367e6c2d075da58270b871dd7d4e">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==2u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==2u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;2u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="ac1ac7440078fa924cd238d38f5d96c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ac7440078fa924cd238d38f5d96c8f">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==1u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==1u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="abcc1825843e750c2b0076a31ac02530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc1825843e750c2b0076a31ac02530d">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==3u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==3u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;3u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="afd80d0368e82d2010fd62748ea10b0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd80d0368e82d2010fd62748ea10b0b8">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==2u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==2u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;2u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a8d6d56c7ad12f895bd715b5b7a660f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6d56c7ad12f895bd715b5b7a660f1b">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==3u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==3u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;3u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a92ecabe5b32b177a637bb3c6c928d82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ecabe5b32b177a637bb3c6c928d82e">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==1u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==1u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a0f9096a5172f2ed15dd22fe348ddff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9096a5172f2ed15dd22fe348ddff40">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==2u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==2u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;2u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a37dcc019e3f98e8a8c6c9da8c5364a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dcc019e3f98e8a8c6c9da8c5364a7f">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==3u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==3u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;3u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a9ec9050f7f8c7d520d4451e67cdb1d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec9050f7f8c7d520d4451e67cdb1d7e">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==1u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==1u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a3f6d57ab7b526ccfaba2093dc17022d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6d57ab7b526ccfaba2093dc17022d8">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==2u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==2u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;2u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a541e04d9174f40694a656890dd014aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541e04d9174f40694a656890dd014aa6">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;T,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond) &amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;T&gt;::dime==3u)&amp;&amp; (tfel::meta::Implements&lt;T2,StensorConcept&gt;::cond) &amp;&amp; (StensorTraits&lt;T2&gt;::dime==3u)&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;T2&gt; &gt;::cond)), stensor&lt;3u,StensorNumType&lt;T&gt; &gt; &gt;::type tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="aa92d3be3ace239c3d7fe658214341368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92d3be3ace239c3d7fe658214341368">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime==1u)&amp;&amp; (StensorTraits&lt;StensorType&gt;::dime==1u)&amp;&amp; tfel::meta::Implements&lt;ST2toST2Type,tfel::math::ST2toST2Concept&gt;::cond&amp;&amp; tfel::meta::Implements&lt;StensorType,tfel::math::StensorConcept&gt;::cond&amp;&amp; std::is_same&lt;ST2toST2NumType&lt;ST2toST2Type&gt;, StensorNumType&lt;StensorType&gt; &gt;::value), st2tost2&lt;1u,ST2toST2NumType&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a74b24f2fc1cd4b6b323e5ea4a5e91501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b24f2fc1cd4b6b323e5ea4a5e91501">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime==2u)&amp;&amp; (StensorTraits&lt;StensorType&gt;::dime==2u)&amp;&amp; tfel::meta::Implements&lt;ST2toST2Type,tfel::math::ST2toST2Concept&gt;::cond&amp;&amp; tfel::meta::Implements&lt;StensorType,tfel::math::StensorConcept&gt;::cond&amp;&amp; std::is_same&lt;ST2toST2NumType&lt;ST2toST2Type&gt;, StensorNumType&lt;StensorType&gt; &gt;::value), st2tost2&lt;2u,ST2toST2NumType&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a096a53744171021753f2e3cac6386413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096a53744171021753f2e3cac6386413">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime==3u)&amp;&amp; (StensorTraits&lt;StensorType&gt;::dime==3u)&amp;&amp; tfel::meta::Implements&lt;ST2toST2Type,tfel::math::ST2toST2Concept&gt;::cond&amp;&amp; tfel::meta::Implements&lt;StensorType,tfel::math::StensorConcept&gt;::cond&amp;&amp; std::is_same&lt;ST2toST2NumType&lt;ST2toST2Type&gt;, StensorNumType&lt;StensorType&gt; &gt;::value), st2tost2&lt;3u,ST2toST2NumType&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a262d4c456e0a76d69c3f07bb78c622e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262d4c456e0a76d69c3f07bb78c622e4">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==1u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;1u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="a473dca9445ee038670ec24cf36bd04d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473dca9445ee038670ec24cf36bd04d8">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==1u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;1u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="ab0ac8d82409ffb625580440560620fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac8d82409ffb625580440560620fcb">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==2u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;2u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="a0d0a674f32e307e51a09669c15318831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0a674f32e307e51a09669c15318831">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==2u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;2u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="a9b953e4bd4cd17fb50389cb3cd59cd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b953e4bd4cd17fb50389cb3cd59cd54">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==3u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;3u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="a604b320098a6663c9d55178729fe371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604b320098a6663c9d55178729fe371c">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1math_1_1_t2to_t2_traits.html">T2toT2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a>&gt;::dime==3u)&amp;&amp; tfel::meta::Implements&lt;T2toT2Type,tfel::math::T2toT2Concept&gt;::cond), t2tost2&lt;3u,typename T2toT2Traits&lt;T2toT2Type&gt;::NumType&gt; &gt;::type tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_type.html">T2toT2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a> </p>

</div>
</div>
<a id="a5ce654ea4324ea12243df2df8283582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce654ea4324ea12243df2df8283582e">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a> tfel::math::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate an expression </p>
<dl class="section return"><dt>Returns</dt><dd>the computed value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682abb0b99c9cbf6cc9d0c33efbc4ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682abb0b99c9cbf6cc9d0c33efbc4ed0">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, void&gt;::type tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="a05e9be366d6ab137da2a090ac3b97754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e9be366d6ab137da2a090ac3b97754">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, void&gt;::type tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="ac9ad44f28d2b3d5eb797bd2a2c3d852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ad44f28d2b3d5eb797bd2a2c3d852f">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, void &gt;::type tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="a1b7ba97d16e5ab2f5b2efa56b6640bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ba97d16e5ab2f5b2efa56b6640bf3">&#9670;&nbsp;</a></span>find_perpendicular_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tfel::math::find_perpendicular_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find a vector perpendicular to the second one </p>

</div>
</div>
<a id="add78759d62a38f9554085c8ecf781d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add78759d62a38f9554085c8ecf781d4d">&#9670;&nbsp;</a></span>geometricDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tfel::math::geometricDiscretization </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>de</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>: a "stl vector like" container </td></tr>
    <tr><td class="paramname">xb</td><td>: starting point </td></tr>
    <tr><td class="paramname">xe</td><td>: last point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the starting point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the last point </td></tr>
    <tr><td class="paramname">n</td><td>: number of elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0112c63107c34060f92af4389b61346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0112c63107c34060f92af4389b61346">&#9670;&nbsp;</a></span>getColumn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; tfel::math::getColumn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the column of the matrix with the given number; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57959b3e12df3752b3cac6fe620c08e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57959b3e12df3752b3cac6fe620c08e8">&#9670;&nbsp;</a></span>getRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; M, T &gt; tfel::math::getRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the row of the matrix with the given number; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>row number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe30dbf021798da2b686fac6763c127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe30dbf021798da2b686fac6763c127">&#9670;&nbsp;</a></span>getStensorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFELMATH_VISIBILITY_EXPORT unsigned short tfel::math::getStensorSize </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the size of a symmetric tensor for the given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>space dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d8364a7cc6de24932f2d1f677a78fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d8364a7cc6de24932f2d1f677a78fb">&#9670;&nbsp;</a></span>init_floating_point_exceptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tfel::math::init_floating_point_exceptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this function enables C99 floating point rounding and exception handling:</p><ul>
<li>FE_DIVBYZERO: the DivideByZero exception occurs when an operation on finite numbers produces infinity as exact answer.</li>
<li>FE_UNDERFLOW: the Overflow exception occurs when a result has to be represented as a floating point number, but has (much) larger absolute value than the largest (finite) floating point number that is representable.</li>
<li>FE_OVERFLOW: the Underflow exception occurs when a result has to be represented as a floating point number, but has smaller absolute value than the smallest positive normalized floating point number (and would lose much accuracy when represented as a denormalized number).</li>
<li>FE_INEXACT: the Inexact exception occurs when the rounded result of an operation is not equal to the infinite precision result. It may occur whenever Overflow or Underflow occurs. </li>
</ul>

</div>
</div>
<a id="a1a74e56e19ca534fc78e8e2f20f99825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a74e56e19ca534fc78e8e2f20f99825">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 1u, tensor&lt;1u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1131967a86e0cba214e77bdbd68f760e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1131967a86e0cba214e77bdbd68f760e">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 2u, tensor&lt;2u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 2D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af83ca5ff0a3b4070beea83ef90f2e75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83ca5ff0a3b4070beea83ef90f2e75e">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 3u, tensor&lt;3u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 3D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4828432a3c0a71a2050eb6819bfcef99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4828432a3c0a71a2050eb6819bfcef99">&#9670;&nbsp;</a></span>invert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>,<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;typename <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;,<a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc675a80461d4371136c4cbd76867945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc675a80461d4371136c4cbd76867945">&#9670;&nbsp;</a></span>invert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 1u, tensor&lt;1u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af51d11f17bbfa033739eca4188283cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51d11f17bbfa033739eca4188283cb6">&#9670;&nbsp;</a></span>invert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 2u, tensor&lt;2u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745fdea659a8112ff55242cb5c831f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745fdea659a8112ff55242cb5c831f21">&#9670;&nbsp;</a></span>invert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>,<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;<a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&gt;,<a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a> to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea36ee98bb5cfa56846e99bc1a21a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea36ee98bb5cfa56846e99bc1a21a85">&#9670;&nbsp;</a></span>invert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>,<a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&gt;::cond &amp;&amp; <a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>&gt;::dime == 3u, tensor&lt;3u,typename ComputeBinaryResult&lt;tfel::typetraits::base_type&lt;TensorNumType&lt;TensorType&gt; &gt;, TensorNumType&lt;TensorType&gt;,OpDiv&gt;::Result&gt; &gt;::type tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a 1D tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76ae8bf8c7712f24ab95c65e97f0c85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ae8bf8c7712f24ab95c65e97f0c85d">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond)&amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime==1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;StensorType&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;StensorType&gt; &gt; &gt;::type tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb39518aaac61328726676745c1ed424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb39518aaac61328726676745c1ed424">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond)&amp;&amp; ((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime==2u)|| (StensorTraits&lt;StensorType&gt;::dime==3u))&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;StensorType&gt; &gt;::cond)), stensor&lt;StensorTraits&lt;StensorType&gt;::dime,StensorNumType&lt;StensorType&gt; &gt; &gt;::type tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdac6d2617d4f5224304edb6300643fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdac6d2617d4f5224304edb6300643fd">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond)&amp;&amp; (<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime==1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;StensorType&gt; &gt;::cond)), stensor&lt;1u,StensorNumType&lt;StensorType&gt; &gt; &gt;::type tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72fb43eba06231944504c8793a4aaaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fb43eba06231944504c8793a4aaaf0">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; ((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>,<a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&gt;::cond)&amp;&amp; ((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt;<a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>&gt;::dime==2u)|| (StensorTraits&lt;StensorType&gt;::dime==3u))&amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;StensorNumType&lt;StensorType&gt; &gt;::cond)), stensor&lt;StensorTraits&lt;StensorType&gt;::dime,StensorNumType&lt;StensorType&gt; &gt; &gt;::type tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302fcc3dcd4eab55fb584c3465e2e8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302fcc3dcd4eab55fb584c3465e2e8aa">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , unsigned short N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, typename std::result_of&lt; F(T)&gt;::type &gt; tfel::math::map </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new tvector by applying a functor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>functor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>inital value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a1ef6d154557d4c704a3306675c32d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1ef6d154557d4c704a3306675c32d7">&#9670;&nbsp;</a></span>negative_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::negative_part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the negative part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa761c2187e151aaf9571f9fcbfb36391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa761c2187e151aaf9571f9fcbfb36391">&#9670;&nbsp;</a></span>negative_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::negative_part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the negative part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce98d089c934be02b3240c0637c724a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce98d089c934be02b3240c0637c724a">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt;T&gt;::type &gt;::type tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>vector&lt;T&gt;&amp;, the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="a12fc650bafc400ecfc2740b09eb0dfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc650bafc400ecfc2740b09eb0dfad">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a>&lt; T1 &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T1, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type &gt;::type tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a tvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>: the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="a26f443c0e09b6facab40820e2d94ca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f443c0e09b6facab40820e2d94ca33">&#9670;&nbsp;</a></span>norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt;T&gt;::type &gt;::type tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>vector&lt;T&gt;&amp;, the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="a696e7e924df758f77ce3bedbb4e36553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696e7e924df758f77ce3bedbb4e36553">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::value&amp;&amp;
                                 (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T1&gt;::type&gt;::cond)&amp;&amp;
				    (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T2&gt;::type&gt;::cond))),
                                 <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiply to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMult&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a91c7287fc490b8d1ac4964f7e1c8a671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c7287fc490b8d1ac4964f7e1c8a671">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a>&gt;::value&amp;&amp;
                                 (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T1&gt;::type&gt;::cond)&amp;&amp;
				    (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T2&gt;::type&gt;::cond))),
                                 <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a38bd98b192d32d075ee257f3a3901764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bd98b192d32d075ee257f3a3901764">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a>&lt;decltype(a),<a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a>&gt;::value,
                                 <a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a>&lt;decltype(a),<a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>negate a mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation.</dd></dl>
<p>This operator is defined if the ComputeUnaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="ab19b33749f7cc2c1f30fb6415bc52e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19b33749f7cc2c1f30fb6415bc52e4b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a>&gt;::value&amp;&amp;
                                 (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T1&gt;::type&gt;::cond)&amp;&amp;
				    (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T2&gt;::type&gt;::cond))),
                                 <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>substract to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMinus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a74068221a11b17cc6a044c1e31d19278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74068221a11b17cc6a044c1e31d19278">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::value&amp;&amp;
                                 (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T1&gt;::type&gt;::cond)&amp;&amp;
				    (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T2&gt;::type&gt;::cond))),
                                 <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>divide a mathematical object by another </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiv&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="ab1c12688608b5a3b089ccd4df6bd3865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c12688608b5a3b089ccd4df6bd3865">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator^ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a>&gt;::value&amp;&amp;
                                 (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T1&gt;::type&gt;::cond)&amp;&amp;
				    (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;typename std::decay&lt;T2&gt;::type&gt;::cond))),
                                 <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a),decltype(b),<a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a>&gt;&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>diadic product between two mathematical objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiadicProduct&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="aca424c4df449d95cb2168c61f72a8c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca424c4df449d95cb2168c61f72a8c99">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==1u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a6cf9784cd1acd370b527848ad084af32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf9784cd1acd370b527848ad084af32">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="af35acc4c9564f0e79a83777bf61ac945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35acc4c9564f0e79a83777bf61ac945">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==2u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a43ed9f3df31262e05dd6eb3f9506e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ed9f3df31262e05dd6eb3f9506e55e">&#9670;&nbsp;</a></span>operator|() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T1 &gt;::dime==3u &amp;&amp;StensorTraits&lt; T2 &gt;::dime==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="aa243e677b22eccdea1b41ba55b1507f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243e677b22eccdea1b41ba55b1507f3">&#9670;&nbsp;</a></span>operator|() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==1u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left tensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a543c1830d1119e6d6335f362df35c633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543c1830d1119e6d6335f362df35c633">&#9670;&nbsp;</a></span>operator|() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==2u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left tensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="abcfa3fedcc396f6093a70c4b45814235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfa3fedcc396f6093a70c4b45814235">&#9670;&nbsp;</a></span>operator|() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T1, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; T1 &gt;::dime==3u &amp;&amp;TensorTraits&lt; T2 &gt;::dime==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left tensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename <a class="el" href="structtfel_1_1math_1_1_result_type.html#a05ac885693f6096c80d2473632629c48" title="Result. ">ResultType&lt;T,T2,OpMult&gt;::type</a>, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="aa7199a1f17a66fb132f8d26ef51b559e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7199a1f17a66fb132f8d26ef51b559e">&#9670;&nbsp;</a></span>polar_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorType2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;std::is_same&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt;::value &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; TensorType2 &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==1u), void &gt;::type tfel::math::polar_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide the polar decomposition of a tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rotation</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stretch</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf56171bc3bac63092798ba9a02e250d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf56171bc3bac63092798ba9a02e250d">&#9670;&nbsp;</a></span>polar_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; TensorType2, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;std::is_same&lt; StensorNumType&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt; &gt;::value &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; TensorType2 &gt;::dime)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime==2u)||(TensorTraits&lt; TensorType &gt;::dime==3u)), void &gt;::type tfel::math::polar_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide the polar decomposition of a tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rotation</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stretch</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0f53217ac87c0397cd7ccfd51f3fa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f53217ac87c0397cd7ccfd51f3fa85">&#9670;&nbsp;</a></span>positive_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::positive_part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the positive part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a994f8005c3876664ed1b96bd8a0ab863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994f8005c3876664ed1b96bd8a0ab863">&#9670;&nbsp;</a></span>positive_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;((<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u)||(StensorTraits&lt; StensorType &gt;::dime==3u))&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; StensorNumType&lt; StensorType &gt; &gt;::cond)), stensor&lt; StensorTraits&lt; StensorType &gt;::dime, StensorNumType&lt; StensorType &gt; &gt; &gt;::type tfel::math::positive_part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the positive part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357b3f9286baa55fc527e7cc3c30b967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b3f9286baa55fc527e7cc3c30b967">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==1u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==1u &amp;TensorTraits&lt; TensorType &gt;::dime==1u, void &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>Ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d1bcef9ebcd2b961781670aefa6c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d1bcef9ebcd2b961781670aefa6c60">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==2u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==2u &amp;TensorTraits&lt; TensorType &gt;::dime==2u, void &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>Ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a95efc1da93b2f6e086b2abec32a260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95efc1da93b2f6e086b2abec32a260">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; ST2toST2Type2, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==3u &amp;&amp;ST2toST2Traits&lt; ST2toST2Type2 &gt;::dime==3u &amp;TensorTraits&lt; TensorType &gt;::dime==3u, void &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname"><em>Ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4aee2955e4236a72590f8e344a440df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aee2955e4236a72590f8e344a440df">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the same as pushForward </dd></dl>

</div>
</div>
<a id="a3f7925ab7557ee1c76de9ac549463ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7925ab7557ee1c76de9ac549463ab4">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the same as pushForward </dd></dl>

</div>
</div>
<a id="affdc53907f4decca8b784f36b0837292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdc53907f4decca8b784f36b0837292">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the same as pushForward </dd></dl>

</div>
</div>
<a id="adbf6803d4f3f5a1e51537d6efd415cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6803d4f3f5a1e51537d6efd415cdb">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a>, <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime==<a class="el" href="structtfel_1_1math_1_1_tensor_traits.html">TensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;::dime, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_traits.html">ST2toST2Traits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;::dime, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a109ba474ff596e4c0e28f0057dc9235e">ST2toST2NumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &gt;, <a class="el" href="namespacetfel_1_1math.html#ac4eedd12532aa85bbeb5b64c63d5f2dc">TensorNumType</a>&lt; <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_tensor_type.html">TensorType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>: <p class="formulaDsp">
\[ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} \]
</p>
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a535198e44ccd223d50999bd79717df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535198e44ccd223d50999bd79717df40">&#9670;&nbsp;</a></span>pushForward() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==1u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==1u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::pushForward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc499d8825dbef42f03b63c76cff4b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc499d8825dbef42f03b63c76cff4b8d">&#9670;&nbsp;</a></span>pushForward() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==2u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==2u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::pushForward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea6477448c90c8afd48dd0b3deda6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea6477448c90c8afd48dd0b3deda6fa">&#9670;&nbsp;</a></span>pushForward() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; T &gt;::dime==3u)&amp;&amp;(tfel::meta::Implements&lt; T2, TensorConcept &gt;::cond) &amp;&amp;(TensorTraits&lt; T2 &gt;::dime==3u)&amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; TensorNumType&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, StensorNumType&lt; T &gt; &gt; &gt;::type tfel::math::pushForward </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00319af6a24fdc8c05a3ed6d827c7523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00319af6a24fdc8c05a3ed6d827c7523">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N-I, N, I, T, false &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="a8e8d1e317a1e54c271c32421ae9166e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8d1e317a1e54c271c32421ae9166e3">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J-I, N, I, T, false &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="ae353f051ba77ffcefd1d9f3e9f35245a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae353f051ba77ffcefd1d9f3e9f35245a">&#9670;&nbsp;</a></span>slice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N-I, N, I, T, true &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="aaa566d4ddc064aefa69aaa820d9aa315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa566d4ddc064aefa69aaa820d9aa315">&#9670;&nbsp;</a></span>slice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J-I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J-I, N, I, T, true &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector (const version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="a53b50fb717c5f8cae0ed0fff58501570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b50fb717c5f8cae0ed0fff58501570">&#9670;&nbsp;</a></span>square() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==1u, stensor&lt; 1u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc2ba18b1e3c19757add971dbb85d339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2ba18b1e3c19757add971dbb85d339">&#9670;&nbsp;</a></span>square() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==2u, stensor&lt; 2u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5bb1a209946ea8e6808cb78285d03cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bb1a209946ea8e6808cb78285d03cb">&#9670;&nbsp;</a></span>square() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a>, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &gt;::dime==3u, stensor&lt; 3u, typename ComputeBinaryResult&lt; StensorNumType&lt; StensorType &gt;, StensorNumType&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;::type tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_stensor_type.html">StensorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11b3972a6f7884f27faa31c609b49632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b3972a6f7884f27faa31c609b49632">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==1u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==1u)), stensor&lt; 3u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93aeb3f9700f6821d5a1aa17b6ac0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93aeb3f9700f6821d5a1aa17b6ac0559">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==2u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==2u)), stensor&lt; 2u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor: </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfab666eac28771e9935c66037274ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfab666eac28771e9935c66037274ef">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType1, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; StensorType2, <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> &gt;::cond)&amp;&amp;(<a class="el" href="structtfel_1_1math_1_1_stensor_traits.html">StensorTraits</a>&lt; StensorType1 &gt;::dime==3u)&amp;&amp;(StensorTraits&lt; StensorType2 &gt;::dime==3u)), stensor&lt; 3u, typename ResultType&lt; StensorNumType&lt; StensorType1 &gt;, StensorNumType&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;::type tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7258b605bcdd8f7c2a78e7c5edd0115d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7258b605bcdd8f7c2a78e7c5edd0115d">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt;  typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; T &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&lt; typename std::decay&lt; T &gt;::type &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a transposed view of the tensor </dd></dl>

</div>
</div>
<a id="a3c58824febade733eb6dc1ceaac3e0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c58824febade733eb6dc1ceaac3e0c6">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt;  typename std::enable_if&lt; <a class="el" href="structtfel_1_1meta_1_1_implements.html">tfel::meta::Implements</a>&lt; typename std::decay&lt; T &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> &gt;::cond, <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_type.html">ST2toST2Type</a>&lt; typename std::decay&lt; T &gt;::type &gt;::type, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a transposed view of the tensor </dd></dl>

</div>
</div>
<a id="a956390f6acfa8185d8420636dc422898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956390f6acfa8185d8420636dc422898">&#9670;&nbsp;</a></span>tresca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor.</p>
<p>Partial specialisation in 1D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b78db087c9dbda87742fa94d15e769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b78db087c9dbda87742fa94d15e769">&#9670;&nbsp;</a></span>tresca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 18 2018 20:55:03 for tfel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
