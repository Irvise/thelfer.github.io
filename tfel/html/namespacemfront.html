<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <title>tfel: mfront Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">The TFEL project </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mfront Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains material used to build the <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> code generator.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_explicit_interface.html">AbaqusExplicitInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_explicit_symbols_generator.html">AbaqusExplicitSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_interface.html">AbaqusInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the Abaqus Standard finite element solver  <a href="structmfront_1_1_abaqus_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_interface_base.html">AbaqusInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for the interfaces to:  <a href="structmfront_1_1_abaqus_interface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_symbols_generator.html">AbaqusSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_brick.html">AbstractBehaviourBrick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an a behaviour' brick is a way to alleviate to build a complex behaviour.  <a href="structmfront_1_1_abstract_behaviour_brick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_d_s_l.html">AbstractBehaviourDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_interface.html">AbstractBehaviourInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_d_s_l.html">AbstractDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_material_property_interface.html">AbstractMaterialPropertyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for material property interface.  <a href="structmfront_1_1_abstract_material_property_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_model_interface.html">AbstractModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_ansys_interface.html">AnsysInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provide an interface to the Ansys/APDL finite element solver.  <a href="structmfront_1_1_ansys_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_ansys_symbols_generator.html">AnsysSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_aster_interface.html">AsterInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_aster_symbols_generator.html">AsterSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_brick_base.html">BehaviourBrickBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_brick_description.html">BehaviourBrickDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure holding the main characteristics of a behaviour brick.  <a href="structmfront_1_1_behaviour_brick_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_brick_factory.html">BehaviourBrickFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract factor for behaviour bricks  <a href="structmfront_1_1_behaviour_brick_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_data.html">BehaviourData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_documentation_generator.html">BehaviourDocumentationGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_d_s_l_base.html">BehaviourDSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure. In versions of <code>TFEL</code> prior to 3.3, keywords were associated with member functions and CRTP was used to provide this functionnality. This mechanism has been deprecated in favor of using <code>std::function</code>. As a consequence, <code><a class="el" href="structmfront_1_1_behaviour_d_s_l_base.html" title="an helper structure. In versions of TFEL prior to 3.3, keywords were associated with member functions...">BehaviourDSLBase</a></code> is now mostly useless.  <a href="structmfront_1_1_behaviour_d_s_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_d_s_l_common.html">BehaviourDSLCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class provides most functionnalities used by mechanical behaviour parsers.  <a href="structmfront_1_1_behaviour_d_s_l_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure used to give information about a DSL.  <a href="structmfront_1_1_behaviour_d_s_l_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_interface_factory.html">BehaviourInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_interface_proxy.html">BehaviourInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_profiler.html">BehaviourProfiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_query.html">BehaviourQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_calculi_x_interface.html">CalculiXInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the CalculiX Standard finite element solver  <a href="structmfront_1_1_calculi_x_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_calculi_x_symbols_generator.html">CalculiXSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_castem_interface.html">CastemInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_castem_material_property_interface.html">CastemMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_castem_symbols_generator.html">CastemSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_c_material_property_interface.html">CMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_c_material_property_interface_base.html">CMaterialPropertyInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a set of material properties interface.  <a href="structmfront_1_1_c_material_property_interface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describing a raw code block  <a href="structmfront_1_1_code_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_compiled_target_description_base.html">CompiledTargetDescriptionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to build the compilation rules for an compiled target.  <a href="structmfront_1_1_compiled_target_description_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_comsol_interface.html">ComsolInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface to Comsol  <a href="structmfront_1_1_comsol_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cpp_material_property_interface.html">CppMaterialPropertyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for C++ material properties.  <a href="structmfront_1_1_cpp_material_property_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cpp_test_material_property_interface.html">CppTestMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cyrano_interface.html">CyranoInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cyrano_material_property_interface.html">CyranoMaterialPropertyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">material properties' interface for EDF' <code>Cyrano</code> fuel performance code.  <a href="structmfront_1_1_cyrano_material_property_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cyrano_symbols_generator.html">CyranoSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_d_i_f2_brick.html">DDIF2Brick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_c_z_m_d_s_l.html">DefaultCZMDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSL associated with Cohesive Zone Models.  <a href="structmfront_1_1_default_c_z_m_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_d_s_l.html">DefaultDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a DSL handling strain based behaviours integrated using an user defined scheme.  <a href="structmfront_1_1_default_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_d_s_l_base.html">DefaultDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_finite_strain_d_s_l.html">DefaultFiniteStrainDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_generic_behaviour_d_s_l.html">DefaultGenericBehaviourDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic behaviour.  <a href="structmfront_1_1_default_generic_behaviour_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_diana_f_e_a_interface.html">DianaFEAInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the DianaFEA Standard finite element solver  <a href="structmfront_1_1_diana_f_e_a_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_diana_f_e_a_symbols_generator.html">DianaFEASymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_base.html">DSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base structure for domain specific languages  <a href="structmfront_1_1_d_s_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_factory.html">DSLFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_proxy.html">DSLProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_europlexus_interface.html">EuroplexusInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the Europlexus Standard finite element solver  <a href="structmfront_1_1_europlexus_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_europlexus_symbols_generator.html">EuroplexusSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_excel_material_property_interface.html">ExcelMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_excel_material_property_internal_interface.html">ExcelMaterialPropertyInternalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to build the compilation rules for an executable.  <a href="structmfront_1_1_executable_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_file_description.html">FileDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class gathers some information about the <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> file being treated  <a href="structmfront_1_1_file_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_behaviour_tangent_operator_conversion.html">FiniteStrainBehaviourTangentOperatorConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describing a conversion between two tangent operator  <a href="structmfront_1_1_finite_strain_behaviour_tangent_operator_conversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_behaviour_tangent_operator_conversion_path.html">FiniteStrainBehaviourTangentOperatorConversionPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_single_crystal_brick.html">FiniteStrainSingleCrystalBrick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_fortran03_material_property_interface.html">Fortran03MaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_fortran_material_property_interface.html">FortranMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generic_behaviour_finite_strain_m_test_file_generator.html">GenericBehaviourFiniteStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generic_behaviour_interface.html">GenericBehaviourInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a generic behaviour interface See <a href="https://github.com/thelfer/MFrontGenericInterfaceSupport">https://github.com/thelfer/MFrontGenericInterfaceSupport</a>  <a href="structmfront_1_1_generic_behaviour_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generic_behaviour_small_strain_m_test_file_generator.html">GenericBehaviourSmallStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generic_behaviour_symbols_generator.html">GenericBehaviourSymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_gnuplot_material_property_interface.html">GnuplotMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_gradient.html">Gradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l.html">ImplicitDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a DSL handling strain based behaviours integrated using an implicit scheme.  <a href="structmfront_1_1_implicit_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l_base.html">ImplicitDSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all parser based on an implicit scheme.  <a href="structmfront_1_1_implicit_d_s_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l_i_i.html">ImplicitDSLII</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a DSLII handling strain base behaviours integrated using an implicit scheme.  <a href="structmfront_1_1_implicit_d_s_l_i_i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_finite_strain_d_s_l.html">ImplicitFiniteStrainDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a DSL handling finite strain behaviours integrated using an implicit scheme.  <a href="structmfront_1_1_implicit_finite_strain_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_generic_behaviour_d_s_l.html">ImplicitGenericBehaviourDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic behaviour.  <a href="structmfront_1_1_implicit_generic_behaviour_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_interface_base.html">InterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_behaviour_d_s_l_base.html">IsotropicBehaviourDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_mises_creep_d_s_l.html">IsotropicMisesCreepDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_mises_plastic_flow_d_s_l.html">IsotropicMisesPlasticFlowDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a dsl dedicated to isotropic mises plastic flows  <a href="structmfront_1_1_isotropic_mises_plastic_flow_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_strain_hardening_mises_creep_d_s_l.html">IsotropicStrainHardeningMisesCreepDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_java_material_property_interface.html">JavaMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_law_function.html">LawFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple structure wrapping the body of a material property  <a href="structmfront_1_1_law_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_numerical_jacobian_solver.html">LevenbergMarquardtNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_solver.html">LevenbergMarquardtSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_solver_base.html">LevenbergMarquardtSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to build the compilation rules for a shared library or a module.  <a href="structmfront_1_1_library_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_local_data_structure.html">LocalDataStructure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_l_s_d_y_n_a_interface.html">LSDYNAInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_l_s_d_y_n_a_symbols_generator.html">LSDYNASymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describing a material property  <a href="structmfront_1_1_material_property_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_d_s_l.html">MaterialPropertyDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">domain specific language handling material properties  <a href="structmfront_1_1_material_property_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_interface_factory.html">MaterialPropertyInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_interface_proxy.html">MaterialPropertyInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_query.html">MaterialPropertyQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front.html">MFront</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the main class of <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a>  <a href="structmfront_1_1_m_front.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_base.html">MFrontBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> and MFrontQuery classes.  <a href="structmfront_1_1_m_front_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_broyden_solver.html">MFrontBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_broyden_solver_base.html">MFrontBroydenSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_germinal_model_interface.html">MFrontGerminalModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_header.html">MFrontHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_lock.html">MFrontLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Great Mfront Lock.  <a href="structmfront_1_1_m_front_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_lock_guard.html">MFrontLockGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_material_property_interface.html">MFrontMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_model_interface.html">MFrontModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_numerical_jacobian_solver.html">MFrontNewtonRaphsonNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_solver.html">MFrontNewtonRaphsonSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_solver_base.html">MFrontNewtonRaphsonSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for non linear system solver based on the Newton-Raphson algorithm. The Newton-Raphson algorithm can be coupled with the PowellDogLegAlgorithm for increased robustness.  <a href="structmfront_1_1_m_front_newton_raphson_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_pleiades_model_interface_base.html">MFrontPleiadesModelInterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_broyden_solver.html">MFrontPowellDogLegBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_newton_raphson_numerical_jacobian_solver.html">MFrontPowellDogLegNewtonRaphsonNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_newton_raphson_solver.html">MFrontPowellDogLegNewtonRaphsonSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_template_generation_options.html">MFrontTemplateGenerationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure holding various options used for the generation of code templates.  <a href="structmfront_1_1_m_front_template_generation_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_description.html">ModelDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a model.  <a href="structmfront_1_1_model_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l.html">ModelDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default class for analysing models  <a href="structmfront_1_1_model_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l_base.html">ModelDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l_common.html">ModelDSLCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for domain specific languages for models  <a href="structmfront_1_1_model_d_s_l_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_interface_factory.html">ModelInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_interface_proxy.html">ModelInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_query.html">ModelQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_test_file_generator_base.html">MTestFileGeneratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mtest files generation  <a href="structmfront_1_1_m_test_file_generator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_multiple_isotropic_mises_flows_d_s_l.html">MultipleIsotropicMisesFlowsDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver.html">NonLinearSystemSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non linear system solver used in by implicit parser.  <a href="structmfront_1_1_non_linear_system_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver_base.html">NonLinearSystemSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver_factory.html">NonLinearSystemSolverFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_octave_material_property_interface.html">OctaveMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_overridable_implementation.html">OverridableImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a data structure representing the implementation of a material knowledge based on <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>.  <a href="structmfront_1_1_overridable_implementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_overridable_string_information.html">OverridableStringInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">overridable string valuated information  <a href="structmfront_1_1_overridable_string_information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_overridable_string_information_tags.html">OverridableStringInformationTags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure that contains an enumeration list the string valuated information in a <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> file that can be overriden.  <a href="structmfront_1_1_overridable_string_information_tags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure allowing to specify paths of <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> implementations in a file.  <a href="structmfront_1_1_path_specifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_pleiades_material_property_interface.html">PleiadesMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_pleiades_model_interface.html">PleiadesModelInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a interface for the <code>PLEIADES 2.0</code> kernel.  <a href="structmfront_1_1_pleiades_model_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_powell_dog_leg_algorithm_base.html">PowellDogLegAlgorithmBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_python_material_property_interface.html">PythonMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_d_s_l.html">RungeKuttaDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSL for integrating a mechanical behaviour using Runge-Kutta algorithms.  <a href="structmfront_1_1_runge_kutta_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_d_s_l_base.html">RungeKuttaDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_finite_strain_d_s_l.html">RungeKuttaFiniteStrainDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure describing a dsl dedicated to the implementation of finite strain behaviours using explicit algorithms.  <a href="structmfront_1_1_runge_kutta_finite_strain_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_generic_behaviour_d_s_l.html">RungeKuttaGenericBehaviourDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic behaviour using explicit algorithms.  <a href="structmfront_1_1_runge_kutta_generic_behaviour_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_search_paths_handler.html">SearchPathsHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_second_broyden_solver.html">SecondBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_standard_behaviour_interface.html">StandardBehaviourInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_standard_elasticity_brick.html">StandardElasticityBrick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html">StandardElastoViscoPlasticityBrick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html" title="The StandardElastoViscoPlasticityBrick is meant to describe a behaviour based on: ...">StandardElastoViscoPlasticityBrick</a></code> is meant to describe a behaviour based on:  <a href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_static_variable_description.html">StaticVariableDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class representing a static variable  <a href="structmfront_1_1_static_variable_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around the std::vector class  <a href="structmfront_1_1_static_variable_description_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_supported_types.html">SupportedTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class handling all type variables types supported by <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a>  <a href="structmfront_1_1_supported_types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_symbols_generator.html">SymbolsGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure containing the results of the analysis of a <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> file. This structure is used to build the compilation rules for the libraries and specific targets defined by <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> interfaces.  <a href="structmfront_1_1_targets_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_thermodynamic_force.html">ThermodynamicForce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describes the thermodynamic force associated with a driving variable.  <a href="structmfront_1_1_thermodynamic_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_umat_finite_strain_m_test_file_generator.html">UmatFiniteStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_u_m_a_t_interface_base.html">UMATInterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_umat_small_strain_m_test_file_generator.html">UmatSmallStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure in charge of describing bounds on a variable. Two kinds of bounds are considered:  <a href="structmfront_1_1_variable_bounds_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure standing for a standard (non static) variable  <a href="structmfront_1_1_variable_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description_base.html">VariableDescriptionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure standing for a variable. The support of fixed-sized arrays has been added lately. This variable is considered as an array if arraySize is greater than 1.  <a href="structmfront_1_1_variable_description_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around the std::vector class  <a href="structmfront_1_1_variable_description_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_z_m_a_t_interface.html">ZMATInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0f70cb281429504b602314a88f96d7e3"><td class="memItemLeft" align="right" valign="top"><a id="a0f70cb281429504b602314a88f96d7e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0f70cb281429504b602314a88f96d7e3">BehaviourAttributeTypes</a> = tfel::meta::GenerateTypeList&lt; bool, unsigned short, std::string, std::vector&lt; std::string &gt; &gt;::type</td></tr>
<tr class="memdesc:a0f70cb281429504b602314a88f96d7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">types that can be stored in a behaviour attribute <br /></td></tr>
<tr class="separator:a0f70cb281429504b602314a88f96d7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd45b37d80e46e14adea35f8f1b20a49"><td class="memItemLeft" align="right" valign="top"><a id="acd45b37d80e46e14adea35f8f1b20a49"></a>
typedef <a class="el" href="structtfel_1_1utilities_1_1_gen_type_base.html">tfel::utilities::GenTypeBase</a>&lt; <a class="el" href="namespacemfront.html#a0f70cb281429504b602314a88f96d7e3">BehaviourAttributeTypes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#acd45b37d80e46e14adea35f8f1b20a49">BehaviourAttribute</a></td></tr>
<tr class="memdesc:acd45b37d80e46e14adea35f8f1b20a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class storing mechanical behaviour attribute <br /></td></tr>
<tr class="separator:acd45b37d80e46e14adea35f8f1b20a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b089943bf593c40430546d099a595f7"><td class="memItemLeft" align="right" valign="top"><a id="a0b089943bf593c40430546d099a595f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b089943bf593c40430546d099a595f7">GenericData</a> = <a class="el" href="structmfront_1_1_file_description.html">FileDescription</a></td></tr>
<tr class="memdesc:a0b089943bf593c40430546d099a595f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef provided for backward compatibility <br /></td></tr>
<tr class="separator:a0b089943bf593c40430546d099a595f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="memItemLeft" align="right" valign="top"><a id="a7bad4d0575ebdf6169ea12e9b817e1e9"></a>
typedef <a class="el" href="structmfront_1_1_static_variable_description.html">StaticVariableDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7bad4d0575ebdf6169ea12e9b817e1e9">StaticVarHandler</a></td></tr>
<tr class="memdesc:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752ce8c483746dbd61bdbff711bc28a6"><td class="memItemLeft" align="right" valign="top"><a id="a752ce8c483746dbd61bdbff711bc28a6"></a>
typedef <a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a752ce8c483746dbd61bdbff711bc28a6">StaticVarContainer</a></td></tr>
<tr class="memdesc:a752ce8c483746dbd61bdbff711bc28a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:a752ce8c483746dbd61bdbff711bc28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5621195b0f22a982221797669d042a"><td class="memItemLeft" align="right" valign="top"><a id="a0b5621195b0f22a982221797669d042a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b5621195b0f22a982221797669d042a">VariableAttributeTypes</a> = tfel::meta::GenerateTypeList&lt; bool, unsigned short, int, double, std::string, std::vector&lt; double &gt;, std::vector&lt; std::string &gt; &gt;::type</td></tr>
<tr class="memdesc:a0b5621195b0f22a982221797669d042a"><td class="mdescLeft">&#160;</td><td class="mdescRight">types that can be stored in a variable attribute <br /></td></tr>
<tr class="separator:a0b5621195b0f22a982221797669d042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="memItemLeft" align="right" valign="top"><a id="a5d945de16a5c5534aa7d75bd6e6f0a4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5d945de16a5c5534aa7d75bd6e6f0a4f">VariableAttribute</a> = <a class="el" href="structtfel_1_1utilities_1_1_gen_type_base.html">tfel::utilities::GenTypeBase</a>&lt; <a class="el" href="namespacemfront.html#a0b5621195b0f22a982221797669d042a">VariableAttributeTypes</a> &gt;</td></tr>
<tr class="memdesc:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class used to store a variable attribute <br /></td></tr>
<tr class="separator:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e4994078c9ba950e27558af93eabc"><td class="memItemLeft" align="right" valign="top"><a id="ac14e4994078c9ba950e27558af93eabc"></a>
typedef <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ac14e4994078c9ba950e27558af93eabc">VarHandler</a></td></tr>
<tr class="memdesc:ac14e4994078c9ba950e27558af93eabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:ac14e4994078c9ba950e27558af93eabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57293a292505942e5dcd42149817fff"><td class="memItemLeft" align="right" valign="top"><a id="af57293a292505942e5dcd42149817fff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af57293a292505942e5dcd42149817fff">VarContainer</a> = <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a></td></tr>
<tr class="memdesc:af57293a292505942e5dcd42149817fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:af57293a292505942e5dcd42149817fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a037bb09752bcfbdea96d56ba051c71cd"><td class="memItemLeft" align="right" valign="top"><a id="a037bb09752bcfbdea96d56ba051c71cd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a> { <b>ISOTROPIC</b>, 
<b>ORTHOTROPIC</b>
 }<tr class="memdesc:a037bb09752bcfbdea96d56ba051c71cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetry of a behaviour <br /></td></tr>
</td></tr>
<tr class="separator:a037bb09752bcfbdea96d56ba051c71cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15b0888f12e362dc6b5181e88500190"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190">IntegrationScheme</a> { <br />
&#160;&#160;<a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190a662f619ea357853446d94c8c14a84bfc">IntegrationScheme::IMPLICITSCHEME</a>, 
<a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190a7c43b318555eaa4d00e0cf6173788c77">IntegrationScheme::EXPLICITSCHEME</a>, 
<a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190aaae6e19dc090b38da8456e6979ecd58c">IntegrationScheme::SPECIFICSCHEME</a>, 
<a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190a8bab2c810619cd054bdd963204d48bee">IntegrationScheme::USERDEFINEDSCHEME</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190a47d4e8f298f5eb3a2c214939f88cf9f5">IntegrationScheme::UNDEFINEDINTEGRATIONSCHEME</a>
<br />
 }<tr class="memdesc:ab15b0888f12e362dc6b5181e88500190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available integration schemes. One of the first thing a dsl shall do is to set the integration scheme it uses.  <a href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab15b0888f12e362dc6b5181e88500190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d27b6a665a341871201e8ecb345ef"><td class="memItemLeft" align="right" valign="top"><a id="aec8d27b6a665a341871201e8ecb345ef"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> { <b>MATERIALPROPERTY</b> = 0, 
<b>BEHAVIOUR</b> = 1, 
<b>MODEL</b> = 2
 }<tr class="memdesc:aec8d27b6a665a341871201e8ecb345ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple structure describing the type of material knowledge treated. <br /></td></tr>
</td></tr>
<tr class="separator:aec8d27b6a665a341871201e8ecb345ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ac1ef6016bdc993a52f0602919353"><td class="memItemLeft" align="right" valign="top"><a id="a4c0ac1ef6016bdc993a52f0602919353"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a> { <br />
&#160;&#160;<b>VERBOSE_QUIET</b> = -1, 
<b>VERBOSE_LEVEL0</b> = 0, 
<b>VERBOSE_LEVEL1</b> = 1, 
<b>VERBOSE_LEVEL2</b> = 2, 
<br />
&#160;&#160;<b>VERBOSE_LEVEL3</b> = 3, 
<b>VERBOSE_DEBUG</b> = 4, 
<b>VERBOSE_FULL</b> = 5
<br />
 }<tr class="memdesc:a4c0ac1ef6016bdc993a52f0602919353"><td class="mdescLeft">&#160;</td><td class="mdescRight">list the possible values for the logging facilities provided by the getVerboseMode/getLogStream functions <br /></td></tr>
</td></tr>
<tr class="separator:a4c0ac1ef6016bdc993a52f0602919353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3fe4e872769b9f12c59241b0503495af"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a3fe4e872769b9f12c59241b0503495af">areCompatible</a> (<a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;, const <a class="el" href="structmfront_1_1_behaviour_brick_description.html">BehaviourBrickDescription</a> &amp;)</td></tr>
<tr class="memdesc:a3fe4e872769b9f12c59241b0503495af"><td class="mdescLeft">&#160;</td><td class="mdescRight">check of if the the DSL' description is compatible with the description of the brick. This is mostly an hint provided to build the behaviour wizard of <code>tfel-editor</code>: additional checks are performed when the brick is added to the behaviour description.  <a href="#a3fe4e872769b9f12c59241b0503495af">More...</a><br /></td></tr>
<tr class="separator:a3fe4e872769b9f12c59241b0503495af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e302a9710157218d755de839a78e6f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad7e302a9710157218d755de839a78e6f">complete</a> (<a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;, const <a class="el" href="structmfront_1_1_behaviour_brick_description.html">BehaviourBrickDescription</a> &amp;)</td></tr>
<tr class="memdesc:ad7e302a9710157218d755de839a78e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">complete the DSL' description using the description of the brick. The resulting description mixes both information.  <a href="#ad7e302a9710157218d755de839a78e6f">More...</a><br /></td></tr>
<tr class="separator:ad7e302a9710157218d755de839a78e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b3f0af9335c86f4943427f26f49e02"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a17b3f0af9335c86f4943427f26f49e02">getParametersFileName</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;)</td></tr>
<tr class="separator:a17b3f0af9335c86f4943427f26f49e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09142b388b5c02dd9763d2f5082a25"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a1d09142b388b5c02dd9763d2f5082a25">getParametersFileName</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourDescription::Hypothesis</a>)</td></tr>
<tr class="separator:a1d09142b388b5c02dd9763d2f5082a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89c928d3f25c909d1234e3c8e09104"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7a89c928d3f25c909d1234e3c8e09104">setElasticSymmetryType</a> (<a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const <a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a>)</td></tr>
<tr class="memdesc:a7a89c928d3f25c909d1234e3c8e09104"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the elastic symmetry of a material if not already defined. If already defined, check that the symmetry is the same as the one given in argument  <a href="#a7a89c928d3f25c909d1234e3c8e09104">More...</a><br /></td></tr>
<tr class="separator:a7a89c928d3f25c909d1234e3c8e09104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0ccbb48b35815c668014be1573004"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a83d0ccbb48b35815c668014be1573004">checkIsStrictlyPositive</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;)</td></tr>
<tr class="memdesc:a83d0ccbb48b35815c668014be1573004"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the given material property description is strictly positive, when described by a constant material property  <a href="#a83d0ccbb48b35815c668014be1573004">More...</a><br /></td></tr>
<tr class="separator:a83d0ccbb48b35815c668014be1573004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a4e2a85b67be2d042e0917cf199ac5"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a80a4e2a85b67be2d042e0917cf199ac5">checkIsStrictlyNegative</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;)</td></tr>
<tr class="memdesc:a80a4e2a85b67be2d042e0917cf199ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the given material property description is strictly negative,when described by a constant material property  <a href="#a80a4e2a85b67be2d042e0917cf199ac5">More...</a><br /></td></tr>
<tr class="separator:a80a4e2a85b67be2d042e0917cf199ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d0dd87827c91e6db9f0620131dd9be"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a07d0dd87827c91e6db9f0620131dd9be">isValidBehaviourName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a07d0dd87827c91e6db9f0620131dd9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ed06a17df55b65b84f41eccc9f312e"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a12ed06a17df55b65b84f41eccc9f312e">getDefaultStrainBasedBehaviourDSLDescription</a> ()</td></tr>
<tr class="separator:a12ed06a17df55b65b84f41eccc9f312e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc1f9e80952f4d823e233a845b3559"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a26dc1f9e80952f4d823e233a845b3559">getDefaultFiniteStrainBehaviourDSLDescription</a> ()</td></tr>
<tr class="separator:a26dc1f9e80952f4d823e233a845b3559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad025dfa2bf6f9ac6710cb8a43ea4b367"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad025dfa2bf6f9ac6710cb8a43ea4b367">supportAllModellingHypothes</a> (const <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;)</td></tr>
<tr class="memdesc:ad025dfa2bf6f9ac6710cb8a43ea4b367"><td class="mdescLeft">&#160;</td><td class="mdescRight">a small function checking of all the modelling hypotheses can be supported.  <a href="#ad025dfa2bf6f9ac6710cb8a43ea4b367">More...</a><br /></td></tr>
<tr class="separator:ad025dfa2bf6f9ac6710cb8a43ea4b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f8c6afadb0248f44c349d91616887"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt;, <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8b5f8c6afadb0248f44c349d91616887">buildMaterialPropertiesList</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const std::set&lt; <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourMaterialProperty::Hypothesis</a> &gt; &amp;)</td></tr>
<tr class="separator:a8b5f8c6afadb0248f44c349d91616887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb83bb6d161df92950b1701de8b8893"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::pair&lt; std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt;, <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#adcb83bb6d161df92950b1701de8b8893">buildMaterialPropertiesList</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">tfel::material::ModellingHypothesis::Hypothesis</a>)</td></tr>
<tr class="separator:adcb83bb6d161df92950b1701de8b8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab6c6547a1443547cecfa4783d65ae"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae9ab6c6547a1443547cecfa4783d65ae">appendToMaterialPropertiesList</a> (std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;, const bool)</td></tr>
<tr class="memdesc:ae9ab6c6547a1443547cecfa4783d65ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a variable to material property list  <a href="#ae9ab6c6547a1443547cecfa4783d65ae">More...</a><br /></td></tr>
<tr class="separator:ae9ab6c6547a1443547cecfa4783d65ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b3b47c91a077981141799370751a1c"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a92b3b47c91a077981141799370751a1c">completeMaterialPropertiesList</a> (std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;, const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourMaterialProperty::Hypothesis</a>)</td></tr>
<tr class="memdesc:a92b3b47c91a077981141799370751a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">complete the list of material properties. This method shall be called by the buildMaterialPropertiesList after that the mandatory material properties list have been filled.  <a href="#a92b3b47c91a077981141799370751a1c">More...</a><br /></td></tr>
<tr class="separator:a92b3b47c91a077981141799370751a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399de278a2dba0810b79d6f576a276c"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT const <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a3399de278a2dba0810b79d6f576a276c">findBehaviourMaterialProperty</a> (const std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a3399de278a2dba0810b79d6f576a276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22ed7643448068ef626cc999f71af4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5e22ed7643448068ef626cc999f71af4">generateCMakeListsFile</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;, const std::string &amp;=&quot;src&quot;)</td></tr>
<tr class="memdesc:a5e22ed7643448068ef626cc999f71af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function generating a standard CMake from a target description.  <a href="#a5e22ed7643448068ef626cc999f71af4">More...</a><br /></td></tr>
<tr class="separator:a5e22ed7643448068ef626cc999f71af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b7a794b72a2644ad38294fb159ee96"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa9b7a794b72a2644ad38294fb159ee96">callCMake</a> (const std::string &amp;, const std::string &amp;=&quot;src&quot;)</td></tr>
<tr class="memdesc:aa9b7a794b72a2644ad38294fb159ee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function calling the <code>make</code> utility in the given directory using the specified file.  <a href="#aa9b7a794b72a2644ad38294fb159ee96">More...</a><br /></td></tr>
<tr class="separator:aa9b7a794b72a2644ad38294fb159ee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e79b7a233f1116b7a780da831876980"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e79b7a233f1116b7a780da831876980"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6e79b7a233f1116b7a780da831876980">hasAttribute</a> (const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a6e79b7a233f1116b7a780da831876980"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if an attribute of the given type is defined  <a href="#a6e79b7a233f1116b7a780da831876980">More...</a><br /></td></tr>
<tr class="separator:a6e79b7a233f1116b7a780da831876980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7385b2a646de41b06aeeb82ee3526f79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7385b2a646de41b06aeeb82ee3526f79"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7385b2a646de41b06aeeb82ee3526f79">getAttribute</a> (const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a7385b2a646de41b06aeeb82ee3526f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of an attribute.  <a href="#a7385b2a646de41b06aeeb82ee3526f79">More...</a><br /></td></tr>
<tr class="separator:a7385b2a646de41b06aeeb82ee3526f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d75ad64d4b6c1096b538b088db442"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a143d75ad64d4b6c1096b538b088db442"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a143d75ad64d4b6c1096b538b088db442">getAttribute</a> (const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;, const std::string &amp;, const T &amp;)</td></tr>
<tr class="memdesc:a143d75ad64d4b6c1096b538b088db442"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of an attribute or a default value if the attribute is not defined.  <a href="#a143d75ad64d4b6c1096b538b088db442">More...</a><br /></td></tr>
<tr class="separator:a143d75ad64d4b6c1096b538b088db442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38131df5337431a7e793bfaf2b764511"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a38131df5337431a7e793bfaf2b764511">isValidMaterialName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a38131df5337431a7e793bfaf2b764511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d7f395d1933b21bef545e56834337"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a1a9d7f395d1933b21bef545e56834337">isValidLibraryName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a1a9d7f395d1933b21bef545e56834337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caee17bbd486656c694cba5e690c5f1"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5caee17bbd486656c694cba5e690c5f1">writeVariablesNamesSymbol</a> (std::ostream &amp;, const std::string &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">mfront::MaterialPropertyDescription</a> &amp;)</td></tr>
<tr class="memdesc:a5caee17bbd486656c694cba5e690c5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the name of the variable  <a href="#a5caee17bbd486656c694cba5e690c5f1">More...</a><br /></td></tr>
<tr class="separator:a5caee17bbd486656c694cba5e690c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1144501725a9ae6b63d0ce17c0298b"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6d1144501725a9ae6b63d0ce17c0298b">writeBoundsSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;, const <a class="el" href="structmfront_1_1_variable_bounds_description.html">mfront::VariableBoundsDescription</a> &amp;)</td></tr>
<tr class="memdesc:a6d1144501725a9ae6b63d0ce17c0298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the bounds  <a href="#a6d1144501725a9ae6b63d0ce17c0298b">More...</a><br /></td></tr>
<tr class="separator:a6d1144501725a9ae6b63d0ce17c0298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c7693694edddaedd98500b26eb81b5"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af8c7693694edddaedd98500b26eb81b5">writeVariablesBoundsSymbols</a> (std::ostream &amp;, const std::string &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">mfront::MaterialPropertyDescription</a> &amp;)</td></tr>
<tr class="memdesc:af8c7693694edddaedd98500b26eb81b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the name of the variable  <a href="#af8c7693694edddaedd98500b26eb81b5">More...</a><br /></td></tr>
<tr class="separator:af8c7693694edddaedd98500b26eb81b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f2ac74804568b167aeef08b15bacc"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a1c7f2ac74804568b167aeef08b15bacc">writeEntryPointSymbol</a> (std::ostream &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a1c7f2ac74804568b167aeef08b15bacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>.  <a href="#a1c7f2ac74804568b167aeef08b15bacc">More...</a><br /></td></tr>
<tr class="separator:a1c7f2ac74804568b167aeef08b15bacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9d11ccdde7e9feaef71c7f040c122ea6">writeTFELVersionSymbol</a> (std::ostream &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol giving the version of <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> used to generate the given entry point.  <a href="#a9d11ccdde7e9feaef71c7f040c122ea6">More...</a><br /></td></tr>
<tr class="separator:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877674ed58972534a1152a8b0c9294ea"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a877674ed58972534a1152a8b0c9294ea">writeEntryPointSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a877674ed58972534a1152a8b0c9294ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>.  <a href="#a877674ed58972534a1152a8b0c9294ea">More...</a><br /></td></tr>
<tr class="separator:a877674ed58972534a1152a8b0c9294ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3deeabbd453cda378526fab72776315"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab3deeabbd453cda378526fab72776315">writeInterfaceSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:ab3deeabbd453cda378526fab72776315"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol for the interface of an entry point.  <a href="#ab3deeabbd453cda378526fab72776315">More...</a><br /></td></tr>
<tr class="separator:ab3deeabbd453cda378526fab72776315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3495723da98686aea2857131ccbf60"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aab3495723da98686aea2857131ccbf60">writeMaterialSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:aab3495723da98686aea2857131ccbf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a symbol stating that a given entry point is associated to a material.  <a href="#aab3495723da98686aea2857131ccbf60">More...</a><br /></td></tr>
<tr class="separator:aab3495723da98686aea2857131ccbf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5efc4c35497979e9ff3b9c3593670d4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa5efc4c35497979e9ff3b9c3593670d4">writeMaterialKnowledgeTypeSymbol</a> (std::ostream &amp;, const std::string &amp;, const <a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> &amp;)</td></tr>
<tr class="memdesc:aa5efc4c35497979e9ff3b9c3593670d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the symbol giving the material knowledge type.  <a href="#aa5efc4c35497979e9ff3b9c3593670d4">More...</a><br /></td></tr>
<tr class="separator:aa5efc4c35497979e9ff3b9c3593670d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518d849f7d0dc844f724f8a9a906bbb"><td class="memItemLeft" align="right" valign="top"><a id="a3518d849f7d0dc844f724f8a9a906bbb"></a>
MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>writeMaterialLaws</b> (std::ostream &amp;, const std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="separator:a3518d849f7d0dc844f724f8a9a906bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af927e8d4859643f8af58246a967f1fe6"><td class="memItemLeft" align="right" valign="top"><a id="af927e8d4859643f8af58246a967f1fe6"></a>
MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>writeStaticVariables</b> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:af927e8d4859643f8af58246a967f1fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be1ee7db5018d5e8f0e10bcd4dc4bdd"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0be1ee7db5018d5e8f0e10bcd4dc4bdd">getMaterialLawLibraryNameBase</a> (const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;)</td></tr>
<tr class="separator:a0be1ee7db5018d5e8f0e10bcd4dc4bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c8df3da487cf59581619b7c0a3742"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae51c8df3da487cf59581619b7c0a3742">writeF77FUNCMacros</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:ae51c8df3da487cf59581619b7c0a3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">define the F77_FUNC and F77_FUNC_ macros. We support the GNU (gfortran) and the intel compilers. By default, the GNU fortran naming scheme is used. This can be changed when compiling mfront generated sources by defining the INTEL_FORTRAN_COMPILER flag.  <a href="#ae51c8df3da487cf59581619b7c0a3742">More...</a><br /></td></tr>
<tr class="separator:ae51c8df3da487cf59581619b7c0a3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69beba34c391ed35ef95d7e8fba3960a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a69beba34c391ed35ef95d7e8fba3960a">writeExportDirectives</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a69beba34c391ed35ef95d7e8fba3960a"><td class="mdescLeft">&#160;</td><td class="mdescRight">define export directives (visibility attributes) and calling conventions through the MFRONT_SHAREDOBJ and the MFRONT_CALLING_CONVENTION macros  <a href="#a69beba34c391ed35ef95d7e8fba3960a">More...</a><br /></td></tr>
<tr class="separator:a69beba34c391ed35ef95d7e8fba3960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d9b3422b4d320e01a21f042b3573f1"><td class="memItemLeft" align="right" valign="top"><a id="a62d9b3422b4d320e01a21f042b3573f1"></a>
MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>makeUpperCase</b> (const std::string &amp;)</td></tr>
<tr class="separator:a62d9b3422b4d320e01a21f042b3573f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d5f0592762c89afcec5993c02a9a55"><td class="memItemLeft" align="right" valign="top"><a id="ad5d5f0592762c89afcec5993c02a9a55"></a>
MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>makeLowerCase</b> (const std::string &amp;)</td></tr>
<tr class="separator:ad5d5f0592762c89afcec5993c02a9a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f9aff040570406503c4bd6c1f0c013"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a98f9aff040570406503c4bd6c1f0c013">addSymbol</a> (std::map&lt; std::string, std::string &gt; &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a98f9aff040570406503c4bd6c1f0c013"><td class="mdescLeft">&#160;</td><td class="mdescRight">add the given symbol.  <a href="#a98f9aff040570406503c4bd6c1f0c013">More...</a><br /></td></tr>
<tr class="separator:a98f9aff040570406503c4bd6c1f0c013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6ab40d59605edf43f1da6c21152d03"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6b6ab40d59605edf43f1da6c21152d03">displayGlossaryEntryCompleteDescription</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1glossary_1_1_glossary_entry.html">tfel::glossary::GlossaryEntry</a> &amp;)</td></tr>
<tr class="memdesc:a6b6ab40d59605edf43f1da6c21152d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">display the complete description of a glossary entry  <a href="#a6b6ab40d59605edf43f1da6c21152d03">More...</a><br /></td></tr>
<tr class="separator:a6b6ab40d59605edf43f1da6c21152d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4078717d72cc5b4cd87aeb490a498212"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4078717d72cc5b4cd87aeb490a498212">mergeExecutableDescription</a> (<a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;, const <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;)</td></tr>
<tr class="memdesc:a4078717d72cc5b4cd87aeb490a498212"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two executable description  <a href="#a4078717d72cc5b4cd87aeb490a498212">More...</a><br /></td></tr>
<tr class="separator:a4078717d72cc5b4cd87aeb490a498212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86690a612ac4e7720ff974c0d53d14f1"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a86690a612ac4e7720ff974c0d53d14f1">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;)</td></tr>
<tr class="memdesc:a86690a612ac4e7720ff974c0d53d14f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a executable description to a stream  <a href="#a86690a612ac4e7720ff974c0d53d14f1">More...</a><br /></td></tr>
<tr class="separator:a86690a612ac4e7720ff974c0d53d14f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4907839604bbff6c63df574686107563"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4907839604bbff6c63df574686107563"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4907839604bbff6c63df574686107563">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a4907839604bbff6c63df574686107563"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a <a class="el" href="structmfront_1_1_executable_description.html" title="This structure is used to build the compilation rules for an executable. ">ExecutableDescription</a> from a stream created by the CxxTokenizer class  <a href="#a4907839604bbff6c63df574686107563">More...</a><br /></td></tr>
<tr class="separator:a4907839604bbff6c63df574686107563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f314f8ad542d78a287bdb5cefdc5326"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6f314f8ad542d78a287bdb5cefdc5326">initDSLs</a> ()</td></tr>
<tr class="memdesc:a6f314f8ad542d78a287bdb5cefdc5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare dls's delivered with mfront  <a href="#a6f314f8ad542d78a287bdb5cefdc5326">More...</a><br /></td></tr>
<tr class="separator:a6f314f8ad542d78a287bdb5cefdc5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadc97fc84786a8a784094ead66d830"><td class="memItemLeft" align="right" valign="top"><a id="a9fadc97fc84786a8a784094ead66d830"></a>
MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>initInterfaces</b> ()</td></tr>
<tr class="separator:a9fadc97fc84786a8a784094ead66d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35f8a7af0b6fd66680dbccb1dc316f6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af35f8a7af0b6fd66680dbccb1dc316f6">setInstallPath</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:af35f8a7af0b6fd66680dbccb1dc316f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the installation path  <a href="#af35f8a7af0b6fd66680dbccb1dc316f6">More...</a><br /></td></tr>
<tr class="separator:af35f8a7af0b6fd66680dbccb1dc316f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c85949184bf0dc0a34b3bdabba8d7"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8f3c85949184bf0dc0a34b3bdabba8d7">getInstallPath</a> ()</td></tr>
<tr class="separator:a8f3c85949184bf0dc0a34b3bdabba8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2342f3b523092875283f92a8ce591d3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab2342f3b523092875283f92a8ce591d3">convert</a> (const <a class="el" href="structmfront_1_1_library_description.html#a04d5489883402187075df9f5ddf1dc0b">LibraryDescription::LibraryType</a>)</td></tr>
<tr class="separator:ab2342f3b523092875283f92a8ce591d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5930af55734e78bbe4ca6bc6c31c3ac4">mergeLibraryDescription</a> (<a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;, const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;)</td></tr>
<tr class="memdesc:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two library description  <a href="#a5930af55734e78bbe4ca6bc6c31c3ac4">More...</a><br /></td></tr>
<tr class="separator:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161fd946add05bb2e18d11e897882fb6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a161fd946add05bb2e18d11e897882fb6">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;)</td></tr>
<tr class="memdesc:a161fd946add05bb2e18d11e897882fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a library description to a stream  <a href="#a161fd946add05bb2e18d11e897882fb6">More...</a><br /></td></tr>
<tr class="separator:a161fd946add05bb2e18d11e897882fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a0a09dcf58231a483127d6a60e2173"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af7a0a09dcf58231a483127d6a60e2173"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af7a0a09dcf58231a483127d6a60e2173">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:af7a0a09dcf58231a483127d6a60e2173"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a <a class="el" href="structmfront_1_1_library_description.html" title="This structure is used to build the compilation rules for a shared library or a module. ">LibraryDescription</a> from a stream created by the CxxTokenizer class  <a href="#af7a0a09dcf58231a483127d6a60e2173">More...</a><br /></td></tr>
<tr class="separator:af7a0a09dcf58231a483127d6a60e2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d07a094c859ff0db93fa5cc1f909db6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9d07a094c859ff0db93fa5cc1f909db6">generateMakeFile</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;, const std::string &amp;=&quot;src&quot;, const std::string &amp;=&quot;Makefile.mfront&quot;)</td></tr>
<tr class="memdesc:a9d07a094c859ff0db93fa5cc1f909db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function generating a standard Makefile from a target description.  <a href="#a9d07a094c859ff0db93fa5cc1f909db6">More...</a><br /></td></tr>
<tr class="separator:a9d07a094c859ff0db93fa5cc1f909db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58ad5a8c4a1231be6f634b96d196c41"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad58ad5a8c4a1231be6f634b96d196c41">callMake</a> (const std::string &amp;, const std::string &amp;=&quot;src&quot;, const std::string &amp;=&quot;Makefile.mfront&quot;)</td></tr>
<tr class="memdesc:ad58ad5a8c4a1231be6f634b96d196c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function calling the <code>make</code> utility in the given directory using the specified file.  <a href="#ad58ad5a8c4a1231be6f634b96d196c41">More...</a><br /></td></tr>
<tr class="separator:ad58ad5a8c4a1231be6f634b96d196c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf04f44574868f25f6263ca7f08869a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0cf04f44574868f25f6263ca7f08869a">isValidMaterialPropertyName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a0cf04f44574868f25f6263ca7f08869a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8984a87917b2fac70f1e29179d5fd2a4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8984a87917b2fac70f1e29179d5fd2a4">writeMaterialPropertyParametersHandler</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a8984a87917b2fac70f1e29179d5fd2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aeab415213e0f01d6d4bcc733c34fd"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a69aeab415213e0f01d6d4bcc733c34fd">writeAssignMaterialPropertyParameters</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a69aeab415213e0f01d6d4bcc733c34fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a9206c7828318e999580ad2d95d535"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a61a9206c7828318e999580ad2d95d535">getMaterialPropertyParametersHandlerClassName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a61a9206c7828318e999580ad2d95d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af771366e22a74d5f1a7096f63b4cc1"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5af771366e22a74d5f1a7096f63b4cc1">getDebugMode</a> ()</td></tr>
<tr class="separator:a5af771366e22a74d5f1a7096f63b4cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777635dcafa05755620e3bf934b8c2e3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a777635dcafa05755620e3bf934b8c2e3">setDebugMode</a> (const bool)</td></tr>
<tr class="memdesc:a777635dcafa05755620e3bf934b8c2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or diable the debug mode  <a href="#a777635dcafa05755620e3bf934b8c2e3">More...</a><br /></td></tr>
<tr class="separator:a777635dcafa05755620e3bf934b8c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff1d91d7e2e9e79bac2c3459070307"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae0ff1d91d7e2e9e79bac2c3459070307">getVerboseMode</a> ()</td></tr>
<tr class="separator:ae0ff1d91d7e2e9e79bac2c3459070307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6fb5de8a983c43f315404947ba71bb"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b6fb5de8a983c43f315404947ba71bb">setVerboseMode</a> (const <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>=VERBOSE_LEVEL0)</td></tr>
<tr class="separator:a0b6fb5de8a983c43f315404947ba71bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ba2b8a568f40c639c7306103f1d99e"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae0ba2b8a568f40c639c7306103f1d99e">setVerboseMode</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae0ba2b8a568f40c639c7306103f1d99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the verbose level  <a href="#ae0ba2b8a568f40c639c7306103f1d99e">More...</a><br /></td></tr>
<tr class="separator:ae0ba2b8a568f40c639c7306103f1d99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d053fd3da3fd9ae82f6010d08c18d4"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a36d053fd3da3fd9ae82f6010d08c18d4">getLogStream</a> ()</td></tr>
<tr class="separator:a36d053fd3da3fd9ae82f6010d08c18d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2d23ca5d808da874d2d4a4c8656fb"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a14c2d23ca5d808da874d2d4a4c8656fb">setLogStream</a> (const std::string &amp;f)</td></tr>
<tr class="separator:a14c2d23ca5d808da874d2d4a4c8656fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42cdcd4cbf373b3b5e5990f834f0d6b"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af42cdcd4cbf373b3b5e5990f834f0d6b">setLogStream</a> (std::ostream &amp;)</td></tr>
<tr class="separator:af42cdcd4cbf373b3b5e5990f834f0d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c1f7a848b435b49c83824f18e6eb41"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a75c1f7a848b435b49c83824f18e6eb41">setUnicodeOutputOption</a> (const bool)</td></tr>
<tr class="memdesc:a75c1f7a848b435b49c83824f18e6eb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">set if <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> shall use unicode characters on output. In particular:  <a href="#a75c1f7a848b435b49c83824f18e6eb41">More...</a><br /></td></tr>
<tr class="separator:a75c1f7a848b435b49c83824f18e6eb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523af729e011a19b4c8a022517975b3"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8523af729e011a19b4c8a022517975b3">getUnicodeOutputOption</a> ()</td></tr>
<tr class="separator:a8523af729e011a19b4c8a022517975b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32f28338a561dc636c5f04a0f5fcb7"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a8b32f28338a561dc636c5f04a0f5fcb7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8b32f28338a561dc636c5f04a0f5fcb7">getKeys</a> (const std::map&lt; std::string, Value &gt; &amp;)</td></tr>
<tr class="separator:a8b32f28338a561dc636c5f04a0f5fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad670e75ef4c065bd76ec0dd3c25cacfa">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditionnally insert a string into a vector of string : an element is inserted if not already present or empty.  <a href="#ad670e75ef4c065bd76ec0dd3c25cacfa">More...</a><br /></td></tr>
<tr class="separator:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992daf2984c030fad89d9dd584776a99"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a992daf2984c030fad89d9dd584776a99">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const char *const)</td></tr>
<tr class="memdesc:a992daf2984c030fad89d9dd584776a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditionnally insert a string into a vector of string : an element is inserted if not already present or has zero size or is nulltpr.  <a href="#a992daf2984c030fad89d9dd584776a99">More...</a><br /></td></tr>
<tr class="separator:a992daf2984c030fad89d9dd584776a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6f2952665cd1e6ab855be493999b2f"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a9c6f2952665cd1e6ab855be493999b2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9c6f2952665cd1e6ab855be493999b2f">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const Container &amp;)</td></tr>
<tr class="memdesc:a9c6f2952665cd1e6ab855be493999b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">call insert_if on every element of a container.  <a href="#a9c6f2952665cd1e6ab855be493999b2f">More...</a><br /></td></tr>
<tr class="separator:a9c6f2952665cd1e6ab855be493999b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aea7969df45cbaf9df0028b0aafa5f73a">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const std::initializer_list&lt; Value &gt; &amp;)</td></tr>
<tr class="memdesc:aea7969df45cbaf9df0028b0aafa5f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">call insert_if on every element of an initializer_list.  <a href="#aea7969df45cbaf9df0028b0aafa5f73a">More...</a><br /></td></tr>
<tr class="separator:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97d148fe6f8bb16ce41c62e153521a7"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af97d148fe6f8bb16ce41c62e153521a7">write</a> (std::ostream &amp;, const std::vector&lt; std::string &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:af97d148fe6f8bb16ce41c62e153521a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a vector of string to the output stream  <a href="#af97d148fe6f8bb16ce41c62e153521a7">More...</a><br /></td></tr>
<tr class="separator:af97d148fe6f8bb16ce41c62e153521a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8a01ab1f7a5376fe356b65ea8b3fb655">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an object of type T from a stream created by the CxxTokenizer class  <a href="#a8a01ab1f7a5376fe356b65ea8b3fb655">More...</a><br /></td></tr>
<tr class="separator:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e1e998786548791706c7e410bbd5f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20e1e998786548791706c7e410bbd5f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a20e1e998786548791706c7e410bbd5f8">read</a> (T &amp;, <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a20e1e998786548791706c7e410bbd5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an object of type T from a stream created by the CxxTokenizer class  <a href="#a20e1e998786548791706c7e410bbd5f8">More...</a><br /></td></tr>
<tr class="separator:a20e1e998786548791706c7e410bbd5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42669badf4c7388d3632014efcaedc38"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a42669badf4c7388d3632014efcaedc38"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a42669badf4c7388d3632014efcaedc38">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a42669badf4c7388d3632014efcaedc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from a stream created by the CxxTokenizer class  <a href="#a42669badf4c7388d3632014efcaedc38">More...</a><br /></td></tr>
<tr class="separator:a42669badf4c7388d3632014efcaedc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0af8872222ac7437a786f54982927"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a16a0af8872222ac7437a786f54982927"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a16a0af8872222ac7437a786f54982927">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a16a0af8872222ac7437a786f54982927"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from a stream created by the CxxTokenizer class  <a href="#a16a0af8872222ac7437a786f54982927">More...</a><br /></td></tr>
<tr class="separator:a16a0af8872222ac7437a786f54982927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aba14060c12a5afc8ad04d71eba1a9c4d">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a vector of strings from a stream created by the CxxTokenizer class  <a href="#aba14060c12a5afc8ad04d71eba1a9c4d">More...</a><br /></td></tr>
<tr class="separator:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1795a2f279445553fdcfae905b1292"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::pair&lt; std::string, <a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0c1795a2f279445553fdcfae905b1292">readVariableBounds</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;p, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> pe)</td></tr>
<tr class="memdesc:a0c1795a2f279445553fdcfae905b1292"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the bounds associated to a variable  <a href="#a0c1795a2f279445553fdcfae905b1292">More...</a><br /></td></tr>
<tr class="separator:a0c1795a2f279445553fdcfae905b1292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1cc837a74220e8c41c580bb5cb4976"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::tuple&lt; std::string, bool, unsigned short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8d1cc837a74220e8c41c580bb5cb4976">extractVariableNameAndArrayPosition</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a8d1cc837a74220e8c41c580bb5cb4976"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the name of a variable and an array position from a string.  <a href="#a8d1cc837a74220e8c41c580bb5cb4976">More...</a><br /></td></tr>
<tr class="separator:a8d1cc837a74220e8c41c580bb5cb4976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb89ff87fa4b9b0bc1870c00e262e092"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#acb89ff87fa4b9b0bc1870c00e262e092">isValidModelName</a> (const std::string &amp;)</td></tr>
<tr class="separator:acb89ff87fa4b9b0bc1870c00e262e092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73626a1584d069b10ab02f768b62237"><td class="memItemLeft" align="right" valign="top"><a id="ad73626a1584d069b10ab02f768b62237"></a>
MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad73626a1584d069b10ab02f768b62237">throwOverridenValueAlreadySet</a> ()</td></tr>
<tr class="memdesc:ad73626a1584d069b10ab02f768b62237"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function <br /></td></tr>
<tr class="separator:ad73626a1584d069b10ab02f768b62237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd13959929e294d2c99d294d1f33ac4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#acdd13959929e294d2c99d294d1f33ac4">write</a> (const <a class="el" href="structmfront_1_1_overridable_implementation.html">OverridableImplementation</a> &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:acdd13959929e294d2c99d294d1f33ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the implementation to the file  <a href="#acdd13959929e294d2c99d294d1f33ac4">More...</a><br /></td></tr>
<tr class="separator:acdd13959929e294d2c99d294d1f33ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a242832ed26bed1d3c3a572b79a273"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af8a242832ed26bed1d3c3a572b79a273">parsePathSpecifierArguments</a> (std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;, <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:af8a242832ed26bed1d3c3a572b79a273"><td class="mdescLeft">&#160;</td><td class="mdescRight">treat command line arguments associated with the specification of a path specifier.  <a href="#af8a242832ed26bed1d3c3a572b79a273">More...</a><br /></td></tr>
<tr class="separator:af8a242832ed26bed1d3c3a572b79a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8dcd5d5720c4dacca99ca5663d488"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aafd8dcd5d5720c4dacca99ca5663d488">finalizePathSpecifierArgumentsParsing</a> (std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;, const <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;)</td></tr>
<tr class="memdesc:aafd8dcd5d5720c4dacca99ca5663d488"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalize the treatment of command line arguments associated with path specifiers.  <a href="#aafd8dcd5d5720c4dacca99ca5663d488">More...</a><br /></td></tr>
<tr class="separator:aafd8dcd5d5720c4dacca99ca5663d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4c8955ce25f88fcf9a1bfe7bacea9a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aaa4c8955ce25f88fcf9a1bfe7bacea9a">getImplementationsPaths</a> (const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:aaa4c8955ce25f88fcf9a1bfe7bacea9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5ee5fa7842c9f6e2183e4ae80a875c"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#adf5ee5fa7842c9f6e2183e4ae80a875c">getImplementationsPaths</a> (const <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;)</td></tr>
<tr class="separator:adf5ee5fa7842c9f6e2183e4ae80a875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec98df0da008b2af2fbe1d1355b5c19"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abec98df0da008b2af2fbe1d1355b5c19">getImplementationsPaths</a> (const std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;)</td></tr>
<tr class="separator:abec98df0da008b2af2fbe1d1355b5c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4feab99cb8d6d0576ed08334efa4764f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4feab99cb8d6d0576ed08334efa4764f">getPedanticMode</a> ()</td></tr>
<tr class="separator:a4feab99cb8d6d0576ed08334efa4764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b2740ed67d88982390ad68ba6cdcc8a">setPedanticMode</a> (const bool)</td></tr>
<tr class="memdesc:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or diable the pedantic mode  <a href="#a0b2740ed67d88982390ad68ba6cdcc8a">More...</a><br /></td></tr>
<tr class="separator:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe80e34f9ad35a89aa879d984e451e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abe80e34f9ad35a89aa879d984e451e0b">writeStandardPerformanceProfiling</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;=&quot;&quot;)</td></tr>
<tr class="memdesc:abe80e34f9ad35a89aa879d984e451e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function to declare a timer  <a href="#abe80e34f9ad35a89aa879d984e451e0b">More...</a><br /></td></tr>
<tr class="separator:abe80e34f9ad35a89aa879d984e451e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff29f71d695cca87edc553d8549a175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abff29f71d695cca87edc553d8549a175">writeStandardPerformanceProfilingBegin</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;=&quot;&quot;)</td></tr>
<tr class="memdesc:abff29f71d695cca87edc553d8549a175"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function writing the beginning of a performance measurement  <a href="#abff29f71d695cca87edc553d8549a175">More...</a><br /></td></tr>
<tr class="separator:abff29f71d695cca87edc553d8549a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788b4f8e27d07163d1fe30be9dce28c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2788b4f8e27d07163d1fe30be9dce28c">writeStandardPerformanceProfilingEnd</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a2788b4f8e27d07163d1fe30be9dce28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function writing the end of a performance measurement  <a href="#a2788b4f8e27d07163d1fe30be9dce28c">More...</a><br /></td></tr>
<tr class="separator:a2788b4f8e27d07163d1fe30be9dce28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ba4a7384294ae8b04933048cfd658f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af7ba4a7384294ae8b04933048cfd658f">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a> &amp;)</td></tr>
<tr class="memdesc:af7ba4a7384294ae8b04933048cfd658f"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a library description to a stream  <a href="#af7ba4a7384294ae8b04933048cfd658f">More...</a><br /></td></tr>
<tr class="separator:af7ba4a7384294ae8b04933048cfd658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab230ebbc6e7275edc5b0b29aaf2f130f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab230ebbc6e7275edc5b0b29aaf2f130f"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab230ebbc6e7275edc5b0b29aaf2f130f">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:ab230ebbc6e7275edc5b0b29aaf2f130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a> from a stream created by the CxxTokenizer class  <a href="#ab230ebbc6e7275edc5b0b29aaf2f130f">More...</a><br /></td></tr>
<tr class="separator:ab230ebbc6e7275edc5b0b29aaf2f130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02780b9599daa678096f6fceff95fd10"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a02780b9599daa678096f6fceff95fd10">to_string</a> (const <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &amp;)</td></tr>
<tr class="memdesc:a02780b9599daa678096f6fceff95fd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert to string  <a href="#a02780b9599daa678096f6fceff95fd10">More...</a><br /></td></tr>
<tr class="separator:a02780b9599daa678096f6fceff95fd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba13d8532f943f5c56744d78f71e9d3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8ba13d8532f943f5c56744d78f71e9d3">describes</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a8ba13d8532f943f5c56744d78f71e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8e0e717df9694a1eb87461e5d20c9"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a52e8e0e717df9694a1eb87461e5d20c9">mergeTargetsDescription</a> (<a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const bool)</td></tr>
<tr class="memdesc:a52e8e0e717df9694a1eb87461e5d20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two targets description  <a href="#a52e8e0e717df9694a1eb87461e5d20c9">More...</a><br /></td></tr>
<tr class="separator:a52e8e0e717df9694a1eb87461e5d20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa929a6b5519f6670b1eb3555b72ae6f2">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;)</td></tr>
<tr class="memdesc:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a target description to a stream  <a href="#aa929a6b5519f6670b1eb3555b72ae6f2">More...</a><br /></td></tr>
<tr class="separator:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2959bc26d843d96ef1376be34b9016f2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2959bc26d843d96ef1376be34b9016f2"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2959bc26d843d96ef1376be34b9016f2">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a2959bc26d843d96ef1376be34b9016f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a TargetDescription from a stream created by the CxxTokenizer class  <a href="#a2959bc26d843d96ef1376be34b9016f2">More...</a><br /></td></tr>
<tr class="separator:a2959bc26d843d96ef1376be34b9016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a1614edab2ab6fe607f42d5079930e"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a48a1614edab2ab6fe607f42d5079930e">getTypeSize</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="separator:a48a1614edab2ab6fe607f42d5079930e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39ab3f99649ecc8813a0ad46c824459"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af39ab3f99649ecc8813a0ad46c824459">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="separator:af39ab3f99649ecc8813a0ad46c824459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51285a40ee07f9e48e9352b2cfec5d"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5d51285a40ee07f9e48e9352b2cfec5d">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;, const unsigned short)</td></tr>
<tr class="separator:a5d51285a40ee07f9e48e9352b2cfec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4c3112eca7131d291f5f78cbac51f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a55b4c3112eca7131d291f5f78cbac51f">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="separator:a55b4c3112eca7131d291f5f78cbac51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e70fa44b1baf7c4cfdff2ff45c88f6a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2e70fa44b1baf7c4cfdff2ff45c88f6a">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;, const unsigned short)</td></tr>
<tr class="separator:a2e70fa44b1baf7c4cfdff2ff45c88f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55dca2f470dd0206fedd88a95962090"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa55dca2f470dd0206fedd88a95962090">getSymbol</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="memdesc:aa55dca2f470dd0206fedd88a95962090"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the symbol of the given variable description.  <a href="#aa55dca2f470dd0206fedd88a95962090">More...</a><br /></td></tr>
<tr class="separator:aa55dca2f470dd0206fedd88a95962090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea4c5164c361faefe633695d6a18e1"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7fea4c5164c361faefe633695d6a18e1">getIncrementSymbol</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="memdesc:a7fea4c5164c361faefe633695d6a18e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the symbols associated with the increment of the given variable.  <a href="#a7fea4c5164c361faefe633695d6a18e1">More...</a><br /></td></tr>
<tr class="separator:a7fea4c5164c361faefe633695d6a18e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2099d790aea6b6088098a2e54965b7d6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2099d790aea6b6088098a2e54965b7d6">getTimeDerivativeSymbol</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="memdesc:a2099d790aea6b6088098a2e54965b7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve the symbols associated with the time derivative of the given variable.  <a href="#a2099d790aea6b6088098a2e54965b7d6">More...</a><br /></td></tr>
<tr class="separator:a2099d790aea6b6088098a2e54965b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa9900b002ea1601dd12ddf3fabbb8b"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT VariableDescriptionContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abaa9900b002ea1601dd12ddf3fabbb8b">findByExternalName</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:abaa9900b002ea1601dd12ddf3fabbb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9480b09fe7d0d115542a7e89aee276b3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9480b09fe7d0d115542a7e89aee276b3">getTypeSize</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="separator:a9480b09fe7d0d115542a7e89aee276b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d1e6787e57312af863c5bfe6776c8"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae64d1e6787e57312af863c5bfe6776c8">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="separator:ae64d1e6787e57312af863c5bfe6776c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4338e1f5c1a194fe2eb5bf8972e87d95"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4338e1f5c1a194fe2eb5bf8972e87d95">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="separator:a4338e1f5c1a194fe2eb5bf8972e87d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcdaf4d538d58f40ecd06ff1586e909"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7bcdaf4d538d58f40ecd06ff1586e909">getSymbols</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="memdesc:a7bcdaf4d538d58f40ecd06ff1586e909"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve all symbols in the given variables.  <a href="#a7bcdaf4d538d58f40ecd06ff1586e909">More...</a><br /></td></tr>
<tr class="separator:a7bcdaf4d538d58f40ecd06ff1586e909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483eb6a5c7e8ca882de4fbb138079df7"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a483eb6a5c7e8ca882de4fbb138079df7">getIncrementSymbols</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="memdesc:a483eb6a5c7e8ca882de4fbb138079df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve all symbols associated with the increment of the given variables.  <a href="#a483eb6a5c7e8ca882de4fbb138079df7">More...</a><br /></td></tr>
<tr class="separator:a483eb6a5c7e8ca882de4fbb138079df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d93b9eb707d1b02c51b8fd30d3270f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a44d93b9eb707d1b02c51b8fd30d3270f">getTimeDerivativeSymbols</a> (std::map&lt; std::string, std::string &gt; &amp;, const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="memdesc:a44d93b9eb707d1b02c51b8fd30d3270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve all symbols associated with the time derivative of the given variables.  <a href="#a44d93b9eb707d1b02c51b8fd30d3270f">More...</a><br /></td></tr>
<tr class="separator:a44d93b9eb707d1b02c51b8fd30d3270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68938de59c162d033eb660ee4666cc70"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a68938de59c162d033eb660ee4666cc70">getOffset</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a68938de59c162d033eb660ee4666cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a8e2619ac8fcda2927821b2225447a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ac7a8e2619ac8fcda2927821b2225447a">displayName</a> (const <a class="el" href="structmfront_1_1_variable_description_base.html">VariableDescriptionBase</a> &amp;)</td></tr>
<tr class="separator:ac7a8e2619ac8fcda2927821b2225447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains material used to build the <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> code generator. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab15b0888f12e362dc6b5181e88500190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15b0888f12e362dc6b5181e88500190">&#9670;&nbsp;</a></span>IntegrationScheme</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemfront.html#ab15b0888f12e362dc6b5181e88500190">mfront::IntegrationScheme</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Available integration schemes. One of the first thing a dsl shall do is to set the integration scheme it uses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab15b0888f12e362dc6b5181e88500190a662f619ea357853446d94c8c14a84bfc"></a>IMPLICITSCHEME&#160;</td><td class="fielddoc"><p>value set by the <code>Implicit</code> Dsl family </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15b0888f12e362dc6b5181e88500190a7c43b318555eaa4d00e0cf6173788c77"></a>EXPLICITSCHEME&#160;</td><td class="fielddoc"><p>value set by the <code>Runge-Kutta</code> Dsl </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15b0888f12e362dc6b5181e88500190aaae6e19dc090b38da8456e6979ecd58c"></a>SPECIFICSCHEME&#160;</td><td class="fielddoc"><p>value set by the <code><a class="el" href="structmfront_1_1_isotropic_mises_creep_d_s_l.html">IsotropicMisesCreepDSL</a></code>, <code><a class="el" href="structmfront_1_1_isotropic_mises_plastic_flow_d_s_l.html" title="a dsl dedicated to isotropic mises plastic flows ">IsotropicMisesPlasticFlowDSL</a></code>, <code><a class="el" href="structmfront_1_1_isotropic_strain_hardening_mises_creep_d_s_l.html">IsotropicStrainHardeningMisesCreepDSL</a></code> <code><a class="el" href="structmfront_1_1_multiple_isotropic_mises_flows_d_s_l.html">MultipleIsotropicMisesFlowsDSL</a></code> dsls. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15b0888f12e362dc6b5181e88500190a8bab2c810619cd054bdd963204d48bee"></a>USERDEFINEDSCHEME&#160;</td><td class="fielddoc"><p>default value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab15b0888f12e362dc6b5181e88500190a47d4e8f298f5eb3a2c214939f88cf9f5"></a>UNDEFINEDINTEGRATIONSCHEME&#160;</td><td class="fielddoc"><p>undefined value. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a98f9aff040570406503c4bd6c1f0c013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f9aff040570406503c4bd6c1f0c013">&#9670;&nbsp;</a></span>addSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::addSymbol </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add the given symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">symbols</td><td>mapping between a symbol and a replacement string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symbol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>replacement string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ab6c6547a1443547cecfa4783d65ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ab6c6547a1443547cecfa4783d65ae">&#9670;&nbsp;</a></span>appendToMaterialPropertiesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::appendToMaterialPropertiesList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append a variable to material property list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>list of material properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>type of the variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, this is a dummy variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe4e872769b9f12c59241b0503495af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe4e872769b9f12c59241b0503495af">&#9670;&nbsp;</a></span>areCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::areCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_brick_description.html">BehaviourBrickDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check of if the the DSL' description is compatible with the description of the brick. This is mostly an hint provided to build the behaviour wizard of <code>tfel-editor</code>: additional checks are performed when the brick is added to the behaviour description. </p>
<dl class="section note"><dt>Note</dt><dd>if the user want to see why the given arguments are not compatible, they must use the <code>complete</code> function and catch the exception (the <code><a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html" title="structure used to give information about a DSL. ">BehaviourDSLDescription</a></code> is not modified on error). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>behaviour DSL description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bbd</td><td>behaviour brick description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both description are compatible </dd></dl>

</div>
</div>
<a id="a8b5f8c6afadb0248f44c349d91616887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f8c6afadb0248f44c349d91616887">&#9670;&nbsp;</a></span>buildMaterialPropertiesList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a>&gt;, <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a>&gt; mfront::buildMaterialPropertiesList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourMaterialProperty::Hypothesis</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pair which first member gives the position of the material properties in the values given through the interface and whose second members is an offset giving the number of imposed material properties. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mh</td><td>modelling hypotheses </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb83bb6d161df92950b1701de8b8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb83bb6d161df92950b1701de8b8893">&#9670;&nbsp;</a></span>buildMaterialPropertiesList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::pair&lt;std::vector&lt;<a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a>&gt;, <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a>&gt; mfront::buildMaterialPropertiesList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">tfel::material::ModellingHypothesis::Hypothesis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pair which first member gives the position of the material properties in the values given through the interface and whose second members is an offset giving the number of imposed material properties. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>modelling hypothesis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b7a794b72a2644ad38294fb159ee96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b7a794b72a2644ad38294fb159ee96">&#9670;&nbsp;</a></span>callCMake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::callCMake </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function calling the <code>make</code> utility in the given directory using the specified file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad58ad5a8c4a1231be6f634b96d196c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58ad5a8c4a1231be6f634b96d196c41">&#9670;&nbsp;</a></span>callMake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::callMake </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;Makefile.mfront&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function calling the <code>make</code> utility in the given directory using the specified file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a4e2a85b67be2d042e0917cf199ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a4e2a85b67be2d042e0917cf199ac5">&#9670;&nbsp;</a></span>checkIsStrictlyNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::checkIsStrictlyNegative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that the given material property description is strictly negative,when described by a constant material property </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d0ccbb48b35815c668014be1573004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d0ccbb48b35815c668014be1573004">&#9670;&nbsp;</a></span>checkIsStrictlyPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::checkIsStrictlyPositive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that the given material property description is strictly positive, when described by a constant material property </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e302a9710157218d755de839a78e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e302a9710157218d755de839a78e6f">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_brick_description.html">BehaviourBrickDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>complete the DSL' description using the description of the brick. The resulting description mixes both information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>behaviour DSL description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bbd</td><td>behaviour brick description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>on error, the behaviour DSL description is left unchanged </dd></dl>

</div>
</div>
<a id="a92b3b47c91a077981141799370751a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b3b47c91a077981141799370751a1c">&#9670;&nbsp;</a></span>completeMaterialPropertiesList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::completeMaterialPropertiesList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourMaterialProperty::Hypothesis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>complete the list of material properties. This method shall be called by the buildMaterialPropertiesList after that the mandatory material properties list have been filled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mprops</td><td>list of material properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>: modelling hypothesis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2342f3b523092875283f92a8ce591d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2342f3b523092875283f92a8ce591d3">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html#a04d5489883402187075df9f5ddf1dc0b">LibraryDescription::LibraryType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string describing the library type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: library type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ba13d8532f943f5c56744d78f71e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba13d8532f943f5c56744d78f71e9d3">&#9670;&nbsp;</a></span>describes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::describes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the target description describes a library with the given name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: library name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6ab40d59605edf43f1da6c21152d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6ab40d59605edf43f1da6c21152d03">&#9670;&nbsp;</a></span>displayGlossaryEntryCompleteDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::displayGlossaryEntryCompleteDescription </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1glossary_1_1_glossary_entry.html">tfel::glossary::GlossaryEntry</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>display the complete description of a glossary entry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>: glossary entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a8e2619ac8fcda2927821b2225447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a8e2619ac8fcda2927821b2225447a">&#9670;&nbsp;</a></span>displayName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT const std::string&amp; mfront::displayName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_base.html">VariableDescriptionBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the symbolic representation of the variable if defined or the variable name. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1cc837a74220e8c41c580bb5cb4976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1cc837a74220e8c41c580bb5cb4976">&#9670;&nbsp;</a></span>extractVariableNameAndArrayPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::tuple&lt;std::string, bool, unsigned short&gt; mfront::extractVariableNameAndArrayPosition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract the name of a variable and an array position from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>variable name and array position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple giving the variable name, the fact that a position was read, the read position if any.</dd></dl>
<p>For example, calling this function with the <code>A[10]</code> argument results in the following tuple: <code>{"A",true,10}</code>.</p>
<p>With <code>B</code> as argument, the result is the following tuple: <code>{"B",false,0}</code>. </p>

</div>
</div>
<a id="aafd8dcd5d5720c4dacca99ca5663d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd8dcd5d5720c4dacca99ca5663d488">&#9670;&nbsp;</a></span>finalizePathSpecifierArgumentsParsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::finalizePathSpecifierArgumentsParsing </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finalize the treatment of command line arguments associated with path specifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>registred path specifiers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>current path specifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3399de278a2dba0810b79d6f576a276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3399de278a2dba0810b79d6f576a276c">&#9670;&nbsp;</a></span>findBehaviourMaterialProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT const <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a>&amp; mfront::findBehaviourMaterialProperty </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmfront_1_1_behaviour_material_property.html">BehaviourMaterialProperty</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>an helper function returning a material property </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mprops</td><td>: material properties </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: glossary name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the umat material property with the given material property name </dd></dl>

</div>
</div>
<a id="abaa9900b002ea1601dd12ddf3fabbb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa9900b002ea1601dd12ddf3fabbb8b">&#9670;&nbsp;</a></span>findByExternalName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT VariableDescriptionContainer::const_iterator mfront::findByExternalName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator to the variable with the given external name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>external name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e22ed7643448068ef626cc999f71af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e22ed7643448068ef626cc999f71af4">&#9670;&nbsp;</a></span>generateCMakeListsFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::generateCMakeListsFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function generating a standard CMake from a target description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d07a094c859ff0db93fa5cc1f909db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d07a094c859ff0db93fa5cc1f909db6">&#9670;&nbsp;</a></span>generateMakeFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::generateMakeFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;Makefile.mfront&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function generating a standard Makefile from a target description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7385b2a646de41b06aeeb82ee3526f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7385b2a646de41b06aeeb82ee3526f79">&#9670;&nbsp;</a></span>getAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; mfront::getAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of an attribute. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the attribute does not exist </td></tr>
    <tr><td class="paramname">if</td><td>the type of the attribute does not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>code block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a143d75ad64d4b6c1096b538b088db442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143d75ad64d4b6c1096b538b088db442">&#9670;&nbsp;</a></span>getAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mfront::getAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of an attribute or a default value if the attribute is not defined. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the type of the attribute does not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>code block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>default value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af771366e22a74d5f1a7096f63b4cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af771366e22a74d5f1a7096f63b4cc1">&#9670;&nbsp;</a></span>getDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::getDebugMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the debug mode is enabled </dd></dl>

</div>
</div>
<a id="a26dc1f9e80952f4d823e233a845b3559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dc1f9e80952f4d823e233a845b3559">&#9670;&nbsp;</a></span>getDefaultFiniteStrainBehaviourDSLDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> mfront::getDefaultFiniteStrainBehaviourDSLDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a default description for DSLs handling finite strain behaviours. </dd></dl>

</div>
</div>
<a id="a12ed06a17df55b65b84f41eccc9f312e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ed06a17df55b65b84f41eccc9f312e">&#9670;&nbsp;</a></span>getDefaultStrainBasedBehaviourDSLDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> mfront::getDefaultStrainBasedBehaviourDSLDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a default description for DSLs handling strain based behaviours. </dd></dl>

</div>
</div>
<a id="aaa4c8955ce25f88fcf9a1bfe7bacea9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4c8955ce25f88fcf9a1bfe7bacea9a">&#9670;&nbsp;</a></span>getImplementationsPaths() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::vector&lt;std::string&gt; mfront::getImplementationsPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the paths to <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> implementations matching the given pattern in the given file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">material_identifier</td><td>identifier of the material (may be empty). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behaviour_identifier</td><td>identifier for material properties. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behaviour_identifier</td><td>identifier for behaviours. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_identifier</td><td>identifier for behaviours.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Standard <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> files only contains one implementations. <code>Madnex</code> files may contain several implementations. </dd></dl>

</div>
</div>
<a id="adf5ee5fa7842c9f6e2183e4ae80a875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5ee5fa7842c9f6e2183e4ae80a875c">&#9670;&nbsp;</a></span>getImplementationsPaths() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::vector&lt;std::string&gt; mfront::getImplementationsPaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the paths to <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> implementations given a path specifier.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>path specifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Standard <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> files only contains one implementations. <code>Madnex</code> files may contain several implementations. </dd></dl>

</div>
</div>
<a id="abec98df0da008b2af2fbe1d1355b5c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec98df0da008b2af2fbe1d1355b5c19">&#9670;&nbsp;</a></span>getImplementationsPaths() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::vector&lt;std::string&gt; mfront::getImplementationsPaths </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the paths to <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> implementations given a set of path specifiers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>path specifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Standard <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> files only contains one implementations. <code>Madnex</code> files may contain several implementations. </dd></dl>

</div>
</div>
<a id="a7fea4c5164c361faefe633695d6a18e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fea4c5164c361faefe633695d6a18e1">&#9670;&nbsp;</a></span>getIncrementSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getIncrementSymbol </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve the symbols associated with the increment of the given variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a483eb6a5c7e8ca882de4fbb138079df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483eb6a5c7e8ca882de4fbb138079df7">&#9670;&nbsp;</a></span>getIncrementSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getIncrementSymbols </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve all symbols associated with the increment of the given variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f3c85949184bf0dc0a34b3bdabba8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c85949184bf0dc0a34b3bdabba8d7">&#9670;&nbsp;</a></span>getInstallPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getInstallPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the installation path, if defined </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if no installation path has been specified, one try to retrieve this path from the <code>MFRONT_INSTALL_PREFIX</code> environment variable. </dd></dl>

</div>
</div>
<a id="a8b32f28338a561dc636c5f04a0f5fcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b32f28338a561dc636c5f04a0f5fcb7">&#9670;&nbsp;</a></span>getKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; mfront::getKeys </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the keys of a map </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36d053fd3da3fd9ae82f6010d08c18d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d053fd3da3fd9ae82f6010d08c18d4">&#9670;&nbsp;</a></span>getLogStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT std::ostream&amp; mfront::getLogStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current logging stream </dd></dl>

</div>
</div>
<a id="a0be1ee7db5018d5e8f0e10bcd4dc4bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be1ee7db5018d5e8f0e10bcd4dc4bdd">&#9670;&nbsp;</a></span>getMaterialLawLibraryNameBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getMaterialLawLibraryNameBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the base name (without interface specification) of the library to be generated by <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61a9206c7828318e999580ad2d95d535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a9206c7828318e999580ad2d95d535">&#9670;&nbsp;</a></span>getMaterialPropertyParametersHandlerClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getMaterialPropertyParametersHandlerClassName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68938de59c162d033eb660ee4666cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68938de59c162d033eb660ee4666cc70">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> mfront::getOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the offset of the given variable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b3f0af9335c86f4943427f26f49e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b3f0af9335c86f4943427f26f49e02">&#9670;&nbsp;</a></span>getParametersFileName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getParametersFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of a text file allowing the change the name of the parameters of the given behaviour </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bd</td><td>behaviour description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d09142b388b5c02dd9763d2f5082a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09142b388b5c02dd9763d2f5082a25">&#9670;&nbsp;</a></span>getParametersFileName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getParametersFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1material_1_1_modelling_hypothesis.html#a9a637e1af46e51842514a724c47da119">BehaviourDescription::Hypothesis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the name of a text file allowing the change the name of the parameters of the given behaviour for the given hypothesis </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bd</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>modelling hypothesis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>h must not be the undefined hypothesis. </dd></dl>

</div>
</div>
<a id="a4feab99cb8d6d0576ed08334efa4764f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4feab99cb8d6d0576ed08334efa4764f">&#9670;&nbsp;</a></span>getPedanticMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::getPedanticMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the pedantic mode is enabled </dd></dl>

</div>
</div>
<a id="aa55dca2f470dd0206fedd88a95962090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55dca2f470dd0206fedd88a95962090">&#9670;&nbsp;</a></span>getSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getSymbol </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve the symbol of the given variable description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bcdaf4d538d58f40ecd06ff1586e909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcdaf4d538d58f40ecd06ff1586e909">&#9670;&nbsp;</a></span>getSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getSymbols </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve all symbols in the given variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2099d790aea6b6088098a2e54965b7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2099d790aea6b6088098a2e54965b7d6">&#9670;&nbsp;</a></span>getTimeDerivativeSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getTimeDerivativeSymbol </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve the symbols associated with the time derivative of the given variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d93b9eb707d1b02c51b8fd30d3270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d93b9eb707d1b02c51b8fd30d3270f">&#9670;&nbsp;</a></span>getTimeDerivativeSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::getTimeDerivativeSymbols </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve all symbols associated with the time derivative of the given variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">symbols</td><td>map between symbols and replacement strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48a1614edab2ab6fe607f42d5079930e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a1614edab2ab6fe607f42d5079930e">&#9670;&nbsp;</a></span>getTypeSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> mfront::getTypeSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the variable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9480b09fe7d0d115542a7e89aee276b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9480b09fe7d0d115542a7e89aee276b3">&#9670;&nbsp;</a></span>getTypeSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> mfront::getTypeSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the sizes of all the variables </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8523af729e011a19b4c8a022517975b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8523af729e011a19b4c8a022517975b3">&#9670;&nbsp;</a></span>getUnicodeOutputOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT bool mfront::getUnicodeOutputOption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> shall use unicode characters on output. </dd></dl>

</div>
</div>
<a id="ae0ff1d91d7e2e9e79bac2c3459070307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff1d91d7e2e9e79bac2c3459070307">&#9670;&nbsp;</a></span>getVerboseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>&amp; mfront::getVerboseMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current verbose level </dd></dl>

</div>
</div>
<a id="a6e79b7a233f1116b7a780da831876980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e79b7a233f1116b7a780da831876980">&#9670;&nbsp;</a></span>hasAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mfront::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if an attribute of the given type is defined </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the type of the attribute does not match </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>code block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af39ab3f99649ecc8813a0ad46c824459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39ab3f99649ecc8813a0ad46c824459">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasBounds</code> method </dd></dl>

</div>
</div>
<a id="a5d51285a40ee07f9e48e9352b2cfec5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51285a40ee07f9e48e9352b2cfec5d">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasBounds</code> method </dd></dl>

</div>
</div>
<a id="ae64d1e6787e57312af863c5bfe6776c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d1e6787e57312af863c5bfe6776c8">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if one of the variables has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b4c3112eca7131d291f5f78cbac51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4c3112eca7131d291f5f78cbac51f">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasPhysicalBounds</code> method. </dd></dl>

</div>
</div>
<a id="a2e70fa44b1baf7c4cfdff2ff45c88f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e70fa44b1baf7c4cfdff2ff45c88f6a">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasPhysicalBounds</code> method. </dd></dl>

</div>
</div>
<a id="a4338e1f5c1a194fe2eb5bf8972e87d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4338e1f5c1a194fe2eb5bf8972e87d95">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if one of the variables has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f314f8ad542d78a287bdb5cefdc5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f314f8ad542d78a287bdb5cefdc5326">&#9670;&nbsp;</a></span>initDSLs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::initDSLs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>declare dls's delivered with mfront </p>
<p>Users can use the MFRONT_ADDITIONAL_LIBRARIES environment to load their own libraries. See the <a class="el" href="structmfront_1_1_d_s_l_proxy.html">DSLProxy</a> class for details. </p>

</div>
</div>
<a id="ad670e75ef4c065bd76ec0dd3c25cacfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad670e75ef4c065bd76ec0dd3c25cacfa">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conditionnally insert a string into a vector of string : an element is inserted if not already present or empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992daf2984c030fad89d9dd584776a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992daf2984c030fad89d9dd584776a99">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>const</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conditionnally insert a string into a vector of string : an element is inserted if not already present or has zero size or is nulltpr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c6f2952665cd1e6ab855be493999b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6f2952665cd1e6ab855be493999b2f">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call insert_if on every element of a container. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Container::value_type must be convertible to a string </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>: type of source </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7969df45cbaf9df0028b0aafa5f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7969df45cbaf9df0028b0aafa5f73a">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call insert_if on every element of an initializer_list. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Value must be convertible to a string </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>: type of the objects of the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07d0dd87827c91e6db9f0620131dd9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d0dd87827c91e6db9f0620131dd9be">&#9670;&nbsp;</a></span>isValidBehaviourName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::isValidBehaviourName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given name is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>behaviour name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a9d7f395d1933b21bef545e56834337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9d7f395d1933b21bef545e56834337">&#9670;&nbsp;</a></span>isValidLibraryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::isValidLibraryName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given name is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>library name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38131df5337431a7e793bfaf2b764511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38131df5337431a7e793bfaf2b764511">&#9670;&nbsp;</a></span>isValidMaterialName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::isValidMaterialName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given name is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>material name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf04f44574868f25f6263ca7f08869a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf04f44574868f25f6263ca7f08869a">&#9670;&nbsp;</a></span>isValidMaterialPropertyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::isValidMaterialPropertyName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given name is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>behaviour name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb89ff87fa4b9b0bc1870c00e262e092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb89ff87fa4b9b0bc1870c00e262e092">&#9670;&nbsp;</a></span>isValidModelName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::isValidModelName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given name is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>model name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4078717d72cc5b4cd87aeb490a498212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4078717d72cc5b4cd87aeb490a498212">&#9670;&nbsp;</a></span>mergeExecutableDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::mergeExecutableDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two executable description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5930af55734e78bbe4ca6bc6c31c3ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5930af55734e78bbe4ca6bc6c31c3ac4">&#9670;&nbsp;</a></span>mergeLibraryDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::mergeLibraryDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two library description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e8e0e717df9694a1eb87461e5d20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e8e0e717df9694a1eb87461e5d20c9">&#9670;&nbsp;</a></span>mergeTargetsDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::mergeTargetsDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two targets description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: override specific targets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7ba4a7384294ae8b04933048cfd658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ba4a7384294ae8b04933048cfd658f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a library description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: library description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86690a612ac4e7720ff974c0d53d14f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86690a612ac4e7720ff974c0d53d14f1">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a executable description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: executable description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a161fd946add05bb2e18d11e897882fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161fd946add05bb2e18d11e897882fb6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a library description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: library description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa929a6b5519f6670b1eb3555b72ae6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa929a6b5519f6670b1eb3555b72ae6f2">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a target description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a242832ed26bed1d3c3a572b79a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a242832ed26bed1d3c3a572b79a273">&#9670;&nbsp;</a></span>parsePathSpecifierArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::parsePathSpecifierArguments </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_path_specifier.html">PathSpecifier</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>treat command line arguments associated with the specification of a path specifier. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the argument was treated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>registred path specifiers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>current path specifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>current command line argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab230ebbc6e7275edc5b0b29aaf2f130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab230ebbc6e7275edc5b0b29aaf2f130f">&#9670;&nbsp;</a></span>read() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a <a class="el" href="structmfront_1_1_specific_target_description.html">SpecificTargetDescription</a> from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the library description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a4907839604bbff6c63df574686107563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4907839604bbff6c63df574686107563">&#9670;&nbsp;</a></span>read() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_executable_description.html">ExecutableDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a <a class="el" href="structmfront_1_1_executable_description.html" title="This structure is used to build the compilation rules for an executable. ">ExecutableDescription</a> from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the executable description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a8a01ab1f7a5376fe356b65ea8b3fb655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a01ab1f7a5376fe356b65ea8b3fb655">&#9670;&nbsp;</a></span>read() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read an object of type T from a stream created by the CxxTokenizer class </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>: type to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object read. If this function succeed, p points past the last token treated. If this function fails, p shall be unchanged. </dd></dl>

</div>
</div>
<a id="af7a0a09dcf58231a483127d6a60e2173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a0a09dcf58231a483127d6a60e2173">&#9670;&nbsp;</a></span>read() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a <a class="el" href="structmfront_1_1_library_description.html" title="This structure is used to build the compilation rules for a shared library or a module. ">LibraryDescription</a> from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the library description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a20e1e998786548791706c7e410bbd5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e1e998786548791706c7e410bbd5f8">&#9670;&nbsp;</a></span>read() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read an object of type T from a stream created by the CxxTokenizer class </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>: type to be read </td></tr>
    <tr><td class="paramname">v</td><td>: value read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object read. If this function succeed, p points past the last token treated. If this function fails, p shall be unchanged. </dd></dl>

</div>
</div>
<a id="a42669badf4c7388d3632014efcaedc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42669badf4c7388d3632014efcaedc38">&#9670;&nbsp;</a></span>read() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT double mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a16a0af8872222ac7437a786f54982927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a0af8872222ac7437a786f54982927">&#9670;&nbsp;</a></span>read() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a2959bc26d843d96ef1376be34b9016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2959bc26d843d96ef1376be34b9016f2">&#9670;&nbsp;</a></span>read() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a TargetDescription from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the target description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="aba14060c12a5afc8ad04d71eba1a9c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14060c12a5afc8ad04d71eba1a9c4d">&#9670;&nbsp;</a></span>read() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::vector&lt;std::string&gt; mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a vector of strings from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a0c1795a2f279445553fdcfae905b1292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1795a2f279445553fdcfae905b1292">&#9670;&nbsp;</a></span>readVariableBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::pair&lt;std::string, <a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a>&gt; mfront::readVariableBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the bounds associated to a variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple giving the variable name and the bounds </dd></dl>

</div>
</div>
<a id="a777635dcafa05755620e3bf934b8c2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777635dcafa05755620e3bf934b8c2e3">&#9670;&nbsp;</a></span>setDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setDebugMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or diable the debug mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: if true, set the debug mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a89c928d3f25c909d1234e3c8e09104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89c928d3f25c909d1234e3c8e09104">&#9670;&nbsp;</a></span>setElasticSymmetryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setElasticSymmetryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the elastic symmetry of a material if not already defined. If already defined, check that the symmetry is the same as the one given in argument </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bd</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetry type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af35f8a7af0b6fd66680dbccb1dc316f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35f8a7af0b6fd66680dbccb1dc316f6">&#9670;&nbsp;</a></span>setInstallPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setInstallPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the installation path </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>installation path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>an exception is thrown if the installation path has already been set. </dd></dl>

</div>
</div>
<a id="a14c2d23ca5d808da874d2d4a4c8656fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2d23ca5d808da874d2d4a4c8656fb">&#9670;&nbsp;</a></span>setLogStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setLogStream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the current logging stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af42cdcd4cbf373b3b5e5990f834f0d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42cdcd4cbf373b3b5e5990f834f0d6b">&#9670;&nbsp;</a></span>setLogStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setLogStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the current logging stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>: new logging stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>the stream is not handled by this function. The user has to take care of it </dd></dl>

</div>
</div>
<a id="a0b2740ed67d88982390ad68ba6cdcc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2740ed67d88982390ad68ba6cdcc8a">&#9670;&nbsp;</a></span>setPedanticMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setPedanticMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or diable the pedantic mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: if true, set the pedantic mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75c1f7a848b435b49c83824f18e6eb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c1f7a848b435b49c83824f18e6eb41">&#9670;&nbsp;</a></span>setUnicodeOutputOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setUnicodeOutputOption </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set if <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> shall use unicode characters on output. In particular: </p>
<ul>
<li>if true, the variable names will be displayed using their symbolic name.</li>
<li>if false, the variable names will be displayed using their mangled name. </li>
</ul>

</div>
</div>
<a id="a0b6fb5de8a983c43f315404947ba71bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6fb5de8a983c43f315404947ba71bb">&#9670;&nbsp;</a></span>setVerboseMode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setVerboseMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>&#160;</td>
          <td class="paramname"> = <code>VERBOSE_LEVEL0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>change the verbose level </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new verbose level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0ba2b8a568f40c639c7306103f1d99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ba2b8a568f40c639c7306103f1d99e">&#9670;&nbsp;</a></span>setVerboseMode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::setVerboseMode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>change the verbose level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>the new verbose level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad025dfa2bf6f9ac6710cb8a43ea4b367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad025dfa2bf6f9ac6710cb8a43ea4b367">&#9670;&nbsp;</a></span>supportAllModellingHypothes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::supportAllModellingHypothes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_d_s_l_description.html">BehaviourDSLDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a small function checking of all the modelling hypotheses can be supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>behaviour DSL description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all modelling hypotheses can be supported </dd></dl>

</div>
</div>
<a id="a02780b9599daa678096f6fceff95fd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02780b9599daa678096f6fceff95fd10">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert to string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>type size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af97d148fe6f8bb16ce41c62e153521a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97d148fe6f8bb16ce41c62e153521a7">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a vector of string to the output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector of string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>: identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd13959929e294d2c99d294d1f33ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd13959929e294d2c99d294d1f33ac4">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_overridable_implementation.html">OverridableImplementation</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the implementation to the file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>implementation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>file name</td></tr>
  </table>
  </dd>
</dl>
<p>The extension of the file is used to determine the driver used. Currently, the only driver available is associated with <code>madnex</code> files. </p>

</div>
</div>
<a id="a69aeab415213e0f01d6d4bcc733c34fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69aeab415213e0f01d6d4bcc733c34fd">&#9670;&nbsp;</a></span>writeAssignMaterialPropertyParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeAssignMaterialPropertyParameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>ouptut stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>type of the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>interface name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d1144501725a9ae6b63d0ce17c0298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1144501725a9ae6b63d0ce17c0298b">&#9670;&nbsp;</a></span>writeBoundsSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeBoundsSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_bounds_description.html">mfront::VariableBoundsDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the law </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vn</td><td>name of the variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bt</td><td>type of bounds (physical or not) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>bound description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c7f2ac74804568b167aeef08b15bacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f2ac74804568b167aeef08b15bacc">&#9670;&nbsp;</a></span>writeEntryPointSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeEntryPointSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877674ed58972534a1152a8b0c9294ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877674ed58972534a1152a8b0c9294ea">&#9670;&nbsp;</a></span>writeEntryPointSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeEntryPointSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point alias </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n2</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69beba34c391ed35ef95d7e8fba3960a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69beba34c391ed35ef95d7e8fba3960a">&#9670;&nbsp;</a></span>writeExportDirectives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeExportDirectives </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define export directives (visibility attributes) and calling conventions through the MFRONT_SHAREDOBJ and the MFRONT_CALLING_CONVENTION macros </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: output file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae51c8df3da487cf59581619b7c0a3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51c8df3da487cf59581619b7c0a3742">&#9670;&nbsp;</a></span>writeF77FUNCMacros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeF77FUNCMacros </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define the F77_FUNC and F77_FUNC_ macros. We support the GNU (gfortran) and the intel compilers. By default, the GNU fortran naming scheme is used. This can be changed when compiling mfront generated sources by defining the INTEL_FORTRAN_COMPILER flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: output file</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.wikipedia.org/wiki/Name_mangling">https://en.wikipedia.org/wiki/Name_mangling</a> :</p>
<p>Many compilers, including SGI's IRIX compilers, GNU Fortran, and Intel's Fortran compiler (except on Microsoft Windows), convert all identifiers to lower case plus an underscore ("foo_" and "foo_bar_"). On Microsoft Windows, the Intel Fortran compiler defaults to uppercase without an underscore.[2]</p>
<p>[2] User and Reference Guide for the Intel Fortran Compiler 15.0, Intel Corporation (2014), Summary of Mixed-Language Issues. Accessed 17 Nov. 2014. </p>

</div>
</div>
<a id="ab3deeabbd453cda378526fab72776315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3deeabbd453cda378526fab72776315">&#9670;&nbsp;</a></span>writeInterfaceSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeInterfaceSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol for the interface of an entry point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point alias </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5efc4c35497979e9ff3b9c3593670d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5efc4c35497979e9ff3b9c3593670d4">&#9670;&nbsp;</a></span>writeMaterialKnowledgeTypeSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeMaterialKnowledgeTypeSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the symbol giving the material knowledge type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>material knowledge type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8984a87917b2fac70f1e29179d5fd2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8984a87917b2fac70f1e29179d5fd2a4">&#9670;&nbsp;</a></span>writeMaterialPropertyParametersHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeMaterialPropertyParametersHandler </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>ouptut stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>type of the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>interface name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3495723da98686aea2857131ccbf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3495723da98686aea2857131ccbf60">&#9670;&nbsp;</a></span>writeMaterialSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeMaterialSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a symbol stating that a given entry point is associated to a material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material name name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe80e34f9ad35a89aa879d984e451e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe80e34f9ad35a89aa879d984e451e0b">&#9670;&nbsp;</a></span>writeStandardPerformanceProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeStandardPerformanceProfiling </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function to declare a timer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: class name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: code block name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: time temporary variable suffix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff29f71d695cca87edc553d8549a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff29f71d695cca87edc553d8549a175">&#9670;&nbsp;</a></span>writeStandardPerformanceProfilingBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeStandardPerformanceProfilingBegin </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function writing the beginning of a performance measurement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: class name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: code block name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: time temporary variable suffix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2788b4f8e27d07163d1fe30be9dce28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2788b4f8e27d07163d1fe30be9dce28c">&#9670;&nbsp;</a></span>writeStandardPerformanceProfilingEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeStandardPerformanceProfilingEnd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function writing the end of a performance measurement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d11ccdde7e9feaef71c7f040c122ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d11ccdde7e9feaef71c7f040c122ea6">&#9670;&nbsp;</a></span>writeTFELVersionSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeTFELVersionSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol giving the version of <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> used to generate the given entry point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8c7693694edddaedd98500b26eb81b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c7693694edddaedd98500b26eb81b5">&#9670;&nbsp;</a></span>writeVariablesBoundsSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeVariablesBoundsSymbols </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">mfront::MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the name of the variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the law </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5caee17bbd486656c694cba5e690c5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caee17bbd486656c694cba5e690c5f1">&#9670;&nbsp;</a></span>writeVariablesNamesSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> mfront::writeVariablesNamesSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">mfront::MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the name of the variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the law </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 3 2021 21:24:44 for tfel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
