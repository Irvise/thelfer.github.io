<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <title>tfel: mfront Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">The TFEL project </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mfront Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains material used to build the <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> code generator.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_explicit_interface.html">AbaqusExplicitInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_interface.html">AbaqusInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the Abaqus Standard finite element solver  <a href="structmfront_1_1_abaqus_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abaqus_interface_base.html">AbaqusInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for the interfaces to:  <a href="structmfront_1_1_abaqus_interface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_brick.html">AbstractBehaviourBrick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_brick_factory.html">AbstractBehaviourBrickFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_d_s_l.html">AbstractBehaviourDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_behaviour_interface.html">AbstractBehaviourInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_d_s_l.html">AbstractDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_material_property_interface.html">AbstractMaterialPropertyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for material property interface.  <a href="structmfront_1_1_abstract_material_property_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_abstract_model_interface.html">AbstractModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_ansys_interface.html">AnsysInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provide an interface to the Ansys/APDL finite element solver.  <a href="structmfront_1_1_ansys_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_aster_interface.html">AsterInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_brick_base.html">BehaviourBrickBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_data.html">BehaviourData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_documentation_generator.html">BehaviourDocumentationGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_d_s_l_base.html">BehaviourDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_d_s_l_common.html">BehaviourDSLCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_interface_factory.html">BehaviourInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_interface_proxy.html">BehaviourInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_profiler.html">BehaviourProfiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_behaviour_query.html">BehaviourQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_calculi_x_interface.html">CalculiXInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the CalculiX Standard finite element solver  <a href="structmfront_1_1_calculi_x_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_castem_interface.html">CastemInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_castem_material_property_interface.html">CastemMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_c_material_property_interface.html">CMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_c_material_property_interface_base.html">CMaterialPropertyInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a set of material properties interface.  <a href="structmfront_1_1_c_material_property_interface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_code_block.html">CodeBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cpp_material_property_interface.html">CppMaterialPropertyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for C++ material properties.  <a href="structmfront_1_1_cpp_material_property_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cpp_test_material_property_interface.html">CppTestMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_cyrano_interface.html">CyranoInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_d_i_f2_brick.html">DDIF2Brick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_c_z_m_d_s_l.html">DefaultCZMDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_d_s_l.html">DefaultDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_d_s_l_base.html">DefaultDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_default_finite_strain_d_s_l.html">DefaultFiniteStrainDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_driving_variable.html">DrivingVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_base.html">DSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_factory.html">DSLFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_d_s_l_proxy.html">DSLProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_europlexus_interface.html">EuroplexusInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interface the Europlexus Standard finite element solver  <a href="structmfront_1_1_europlexus_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_excel_material_property_interface.html">ExcelMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_excel_material_property_internal_interface.html">ExcelMaterialPropertyInternalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_file_description.html">FileDescription</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_behaviour_tangent_operator_conversion.html">FiniteStrainBehaviourTangentOperatorConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_behaviour_tangent_operator_conversion_path.html">FiniteStrainBehaviourTangentOperatorConversionPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_finite_strain_single_crystal_brick.html">FiniteStrainSingleCrystalBrick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_fortran03_material_property_interface.html">Fortran03MaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_fortran_material_property_interface.html">FortranMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_gnuplot_material_property_interface.html">GnuplotMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l.html">ImplicitDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l_base.html">ImplicitDSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all parser based on an implicit scheme.  <a href="structmfront_1_1_implicit_d_s_l_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_d_s_l_i_i.html">ImplicitDSLII</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_implicit_finite_strain_d_s_l.html">ImplicitFiniteStrainDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_interface_base.html">InterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_behaviour_d_s_l_base.html">IsotropicBehaviourDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_mises_creep_d_s_l.html">IsotropicMisesCreepDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_mises_plastic_flow_d_s_l.html">IsotropicMisesPlasticFlowDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a dsl dedicated to isotropic mises plastic flows  <a href="structmfront_1_1_isotropic_mises_plastic_flow_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_isotropic_strain_hardening_mises_creep_d_s_l.html">IsotropicStrainHardeningMisesCreepDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_java_material_property_interface.html">JavaMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_law_function.html">LawFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_numerical_jacobian_solver.html">LevenbergMarquardtNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_solver.html">LevenbergMarquardtSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_levenberg_marquardt_solver_base.html">LevenbergMarquardtSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to build the compilation rules for the library.  <a href="structmfront_1_1_library_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_local_data_structure.html">LocalDataStructure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_l_s_d_y_n_a_interface.html">LSDYNAInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describing a material property  <a href="structmfront_1_1_material_property_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_d_s_l.html">MaterialPropertyDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_interface_factory.html">MaterialPropertyInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_interface_proxy.html">MaterialPropertyInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_material_property_query.html">MaterialPropertyQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front.html">MFront</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the main class of <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a>  <a href="structmfront_1_1_m_front.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_base.html">MFrontBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_broyden_solver.html">MFrontBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_broyden_solver_base.html">MFrontBroydenSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_germinal_model_interface.html">MFrontGerminalModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_header.html">MFrontHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_lock.html">MFrontLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Great Mfront Lock.  <a href="structmfront_1_1_m_front_lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_lock_guard.html">MFrontLockGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_material_property_interface.html">MFrontMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_model_interface.html">MFrontModelInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_numerical_jacobian_solver.html">MFrontNewtonRaphsonNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_solver.html">MFrontNewtonRaphsonSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_newton_raphson_solver_base.html">MFrontNewtonRaphsonSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for non linear system solver based on the Newton-Raphson algorithm. The Newton-Raphson algorithm can be coupled with the PowellDogLegAlgorithm for increased robustness.  <a href="structmfront_1_1_m_front_newton_raphson_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_pleiades_model_interface_base.html">MFrontPleiadesModelInterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_broyden_solver.html">MFrontPowellDogLegBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_newton_raphson_numerical_jacobian_solver.html">MFrontPowellDogLegNewtonRaphsonNumericalJacobianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_front_powell_dog_leg_newton_raphson_solver.html">MFrontPowellDogLegNewtonRaphsonSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_description.html">ModelDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing a model.  <a href="structmfront_1_1_model_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l.html">ModelDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default class for analysing models  <a href="structmfront_1_1_model_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l_base.html">ModelDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_d_s_l_common.html">ModelDSLCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_interface_factory.html">ModelInterfaceFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_interface_proxy.html">ModelInterfaceProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_model_query.html">ModelQuery</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_m_test_file_generator_base.html">MTestFileGeneratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mtest files generation  <a href="structmfront_1_1_m_test_file_generator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_multiple_isotropic_mises_flows_d_s_l.html">MultipleIsotropicMisesFlowsDSL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver.html">NonLinearSystemSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver_base.html">NonLinearSystemSolverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_non_linear_system_solver_factory.html">NonLinearSystemSolverFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_octave_material_property_interface.html">OctaveMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_pleiades_material_property_interface.html">PleiadesMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_pleiades_model_interface.html">PleiadesModelInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a interface for the <code>PLEIADES 2.0</code> kernel.  <a href="structmfront_1_1_pleiades_model_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_powell_dog_leg_algorithm_base.html">PowellDogLegAlgorithmBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_python_material_property_interface.html">PythonMaterialPropertyInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_d_s_l.html">RungeKuttaDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DSL for integrating a mechanical behaviour using Runge-Kutta algorithms.  <a href="structmfront_1_1_runge_kutta_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_d_s_l_base.html">RungeKuttaDSLBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_runge_kutta_finite_strain_d_s_l.html">RungeKuttaFiniteStrainDSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure describing a dsl dedicated to the implementation of finite strain behaviours using explicit algorithms.  <a href="structmfront_1_1_runge_kutta_finite_strain_d_s_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_search_paths_handler.html">SearchPathsHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_second_broyden_solver.html">SecondBroydenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_standard_elasticity_brick.html">StandardElasticityBrick</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html">StandardElastoViscoPlasticityBrick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html" title="The StandardElastoViscoPlasticityBrick is meant to describe a behaviour based on: ...">StandardElastoViscoPlasticityBrick</a></code> is meant to describe a behaviour based on:  <a href="structmfront_1_1_standard_elasto_visco_plasticity_brick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_static_variable_description.html">StaticVariableDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class representing a static variable  <a href="structmfront_1_1_static_variable_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around the std::vector class  <a href="structmfront_1_1_static_variable_description_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_supported_types.html">SupportedTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class handling all type variables types supported by <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a>  <a href="structmfront_1_1_supported_types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure containing the results of the analysis of a <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> file. This structure is used to build the compilation rules for the libraries and specific targets defined by <a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a> interfaces.  <a href="structmfront_1_1_targets_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_thermodynamic_force.html">ThermodynamicForce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describes the thermodynamic force associated with a driving variable.  <a href="structmfront_1_1_thermodynamic_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_umat_finite_strain_m_test_file_generator.html">UmatFiniteStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_u_m_a_t_interface_base.html">UMATInterfaceBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_umat_small_strain_m_test_file_generator.html">UmatSmallStrainMTestFileGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure in charge of describing bounds on a variable. Two kinds of bounds are considered:  <a href="structmfront_1_1_variable_bounds_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure standing for a standard (non static) variable  <a href="structmfront_1_1_variable_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description_base.html">VariableDescriptionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure standing for a variable. The support of fixed-sized arrays has been added lately. This variable is considered as an array if arraySize is greater than 1.  <a href="structmfront_1_1_variable_description_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around the std::vector class  <a href="structmfront_1_1_variable_description_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmfront_1_1_z_m_a_t_interface.html">ZMATInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0f70cb281429504b602314a88f96d7e3"><td class="memItemLeft" align="right" valign="top"><a id="a0f70cb281429504b602314a88f96d7e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0f70cb281429504b602314a88f96d7e3">BehaviourAttributeTypes</a> = tfel::meta::GenerateTypeList&lt; bool, unsigned short, std::string, std::vector&lt; std::string &gt; &gt;::type</td></tr>
<tr class="memdesc:a0f70cb281429504b602314a88f96d7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">types that can be stored in a behaviour attribute <br /></td></tr>
<tr class="separator:a0f70cb281429504b602314a88f96d7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd45b37d80e46e14adea35f8f1b20a49"><td class="memItemLeft" align="right" valign="top"><a id="acd45b37d80e46e14adea35f8f1b20a49"></a>
typedef <a class="el" href="structtfel_1_1utilities_1_1_gen_type_base.html">tfel::utilities::GenTypeBase</a>&lt; <a class="el" href="namespacemfront.html#a0f70cb281429504b602314a88f96d7e3">BehaviourAttributeTypes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#acd45b37d80e46e14adea35f8f1b20a49">BehaviourAttribute</a></td></tr>
<tr class="memdesc:acd45b37d80e46e14adea35f8f1b20a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class storing mechanical behaviour attribute <br /></td></tr>
<tr class="separator:acd45b37d80e46e14adea35f8f1b20a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b089943bf593c40430546d099a595f7"><td class="memItemLeft" align="right" valign="top"><a id="a0b089943bf593c40430546d099a595f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b089943bf593c40430546d099a595f7">GenericData</a> = <a class="el" href="structmfront_1_1_file_description.html">FileDescription</a></td></tr>
<tr class="memdesc:a0b089943bf593c40430546d099a595f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef provided for backward compatibility <br /></td></tr>
<tr class="separator:a0b089943bf593c40430546d099a595f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="memItemLeft" align="right" valign="top"><a id="a7bad4d0575ebdf6169ea12e9b817e1e9"></a>
typedef <a class="el" href="structmfront_1_1_static_variable_description.html">StaticVariableDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7bad4d0575ebdf6169ea12e9b817e1e9">StaticVarHandler</a></td></tr>
<tr class="memdesc:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:a7bad4d0575ebdf6169ea12e9b817e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752ce8c483746dbd61bdbff711bc28a6"><td class="memItemLeft" align="right" valign="top"><a id="a752ce8c483746dbd61bdbff711bc28a6"></a>
typedef <a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a752ce8c483746dbd61bdbff711bc28a6">StaticVarContainer</a></td></tr>
<tr class="memdesc:a752ce8c483746dbd61bdbff711bc28a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:a752ce8c483746dbd61bdbff711bc28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd34862790011a2c8da6c5fa0d8fa69"><td class="memItemLeft" align="right" valign="top"><a id="a7dd34862790011a2c8da6c5fa0d8fa69"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7dd34862790011a2c8da6c5fa0d8fa69">VariableAttributeTypes</a> = tfel::meta::GenerateTypeList&lt; bool, unsigned short, int, double, std::string, std::vector&lt; double &gt;, std::vector&lt; std::string &gt; &gt;::type</td></tr>
<tr class="memdesc:a7dd34862790011a2c8da6c5fa0d8fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">types that can be stored in a variable attribute <br /></td></tr>
<tr class="separator:a7dd34862790011a2c8da6c5fa0d8fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="memItemLeft" align="right" valign="top"><a id="a5d945de16a5c5534aa7d75bd6e6f0a4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5d945de16a5c5534aa7d75bd6e6f0a4f">VariableAttribute</a> = <a class="el" href="structtfel_1_1utilities_1_1_gen_type_base.html">tfel::utilities::GenTypeBase</a>&lt; <a class="el" href="namespacemfront.html#a7dd34862790011a2c8da6c5fa0d8fa69">VariableAttributeTypes</a> &gt;</td></tr>
<tr class="memdesc:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class used to store a variable attribute <br /></td></tr>
<tr class="separator:a5d945de16a5c5534aa7d75bd6e6f0a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e4994078c9ba950e27558af93eabc"><td class="memItemLeft" align="right" valign="top"><a id="ac14e4994078c9ba950e27558af93eabc"></a>
typedef <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ac14e4994078c9ba950e27558af93eabc">VarHandler</a></td></tr>
<tr class="memdesc:ac14e4994078c9ba950e27558af93eabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:ac14e4994078c9ba950e27558af93eabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6f3c9abf853cd24cda57e2ebc0e685"><td class="memItemLeft" align="right" valign="top"><a id="a1e6f3c9abf853cd24cda57e2ebc0e685"></a>
typedef <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a1e6f3c9abf853cd24cda57e2ebc0e685">VarContainer</a></td></tr>
<tr class="memdesc:a1e6f3c9abf853cd24cda57e2ebc0e685"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility <br /></td></tr>
<tr class="separator:a1e6f3c9abf853cd24cda57e2ebc0e685"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a037bb09752bcfbdea96d56ba051c71cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a> { <b>ISOTROPIC</b>, 
<b>ORTHOTROPIC</b>
 }</td></tr>
<tr class="separator:a037bb09752bcfbdea96d56ba051c71cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d27b6a665a341871201e8ecb345ef"><td class="memItemLeft" align="right" valign="top"><a id="aec8d27b6a665a341871201e8ecb345ef"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> { <b>MATERIALPROPERTY</b> = 0, 
<b>BEHAVIOUR</b> = 1, 
<b>MODEL</b> = 2
 }<tr class="memdesc:aec8d27b6a665a341871201e8ecb345ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple structure describing the type of material knowledge treated. <br /></td></tr>
</td></tr>
<tr class="separator:aec8d27b6a665a341871201e8ecb345ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ac1ef6016bdc993a52f0602919353"><td class="memItemLeft" align="right" valign="top"><a id="a4c0ac1ef6016bdc993a52f0602919353"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a> { <br />
&#160;&#160;<b>VERBOSE_QUIET</b> = -1, 
<b>VERBOSE_LEVEL0</b> = 0, 
<b>VERBOSE_LEVEL1</b> = 1, 
<b>VERBOSE_LEVEL2</b> = 2, 
<br />
&#160;&#160;<b>VERBOSE_LEVEL3</b> = 3, 
<b>VERBOSE_DEBUG</b> = 4, 
<b>VERBOSE_FULL</b> = 5
<br />
 }<tr class="memdesc:a4c0ac1ef6016bdc993a52f0602919353"><td class="mdescLeft">&#160;</td><td class="mdescRight">list the possible values for the logging facilities provided by the getVerboseMode/getLogStream functions <br /></td></tr>
</td></tr>
<tr class="separator:a4c0ac1ef6016bdc993a52f0602919353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a89c928d3f25c909d1234e3c8e09104"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a7a89c928d3f25c909d1234e3c8e09104">setElasticSymmetryType</a> (<a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;, const <a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a>)</td></tr>
<tr class="memdesc:a7a89c928d3f25c909d1234e3c8e09104"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the elastic symmetry of a material if not already defined. If already defined, check that the symmetry is the same as the one given in argument  <a href="#a7a89c928d3f25c909d1234e3c8e09104">More...</a><br /></td></tr>
<tr class="separator:a7a89c928d3f25c909d1234e3c8e09104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d0ccbb48b35815c668014be1573004"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a83d0ccbb48b35815c668014be1573004">checkIsStrictlyPositive</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;)</td></tr>
<tr class="memdesc:a83d0ccbb48b35815c668014be1573004"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the given material property description is strictly positive, when described by a constant material property  <a href="#a83d0ccbb48b35815c668014be1573004">More...</a><br /></td></tr>
<tr class="separator:a83d0ccbb48b35815c668014be1573004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a4e2a85b67be2d042e0917cf199ac5"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a80a4e2a85b67be2d042e0917cf199ac5">checkIsStrictlyNegative</a> (const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;)</td></tr>
<tr class="memdesc:a80a4e2a85b67be2d042e0917cf199ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that the given material property description is strictly negative,when described by a constant material property  <a href="#a80a4e2a85b67be2d042e0917cf199ac5">More...</a><br /></td></tr>
<tr class="separator:a80a4e2a85b67be2d042e0917cf199ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22ed7643448068ef626cc999f71af4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5e22ed7643448068ef626cc999f71af4">generateCMakeListsFile</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;, const std::string &amp;=&quot;src&quot;)</td></tr>
<tr class="memdesc:a5e22ed7643448068ef626cc999f71af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function generating a standard CMake from a target description.  <a href="#a5e22ed7643448068ef626cc999f71af4">More...</a><br /></td></tr>
<tr class="separator:a5e22ed7643448068ef626cc999f71af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b7a794b72a2644ad38294fb159ee96"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa9b7a794b72a2644ad38294fb159ee96">callCMake</a> (const std::string &amp;, const std::string &amp;=&quot;src&quot;)</td></tr>
<tr class="memdesc:aa9b7a794b72a2644ad38294fb159ee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function calling the <code>make</code> utility in the given directory using the specified file.  <a href="#aa9b7a794b72a2644ad38294fb159ee96">More...</a><br /></td></tr>
<tr class="separator:aa9b7a794b72a2644ad38294fb159ee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f2ac74804568b167aeef08b15bacc"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a1c7f2ac74804568b167aeef08b15bacc">writeEntryPointSymbol</a> (std::ostream &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a1c7f2ac74804568b167aeef08b15bacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>.  <a href="#a1c7f2ac74804568b167aeef08b15bacc">More...</a><br /></td></tr>
<tr class="separator:a1c7f2ac74804568b167aeef08b15bacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9d11ccdde7e9feaef71c7f040c122ea6">writeTFELVersionSymbol</a> (std::ostream &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol giving the version of <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> used to generate the given entry point.  <a href="#a9d11ccdde7e9feaef71c7f040c122ea6">More...</a><br /></td></tr>
<tr class="separator:a9d11ccdde7e9feaef71c7f040c122ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877674ed58972534a1152a8b0c9294ea"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a877674ed58972534a1152a8b0c9294ea">writeEntryPointSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a877674ed58972534a1152a8b0c9294ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>.  <a href="#a877674ed58972534a1152a8b0c9294ea">More...</a><br /></td></tr>
<tr class="separator:a877674ed58972534a1152a8b0c9294ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3deeabbd453cda378526fab72776315"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab3deeabbd453cda378526fab72776315">writeInterfaceSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:ab3deeabbd453cda378526fab72776315"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a specific symbol for the interface of an entry point.  <a href="#ab3deeabbd453cda378526fab72776315">More...</a><br /></td></tr>
<tr class="separator:ab3deeabbd453cda378526fab72776315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3495723da98686aea2857131ccbf60"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aab3495723da98686aea2857131ccbf60">writeMaterialSymbol</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:aab3495723da98686aea2857131ccbf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a symbol stating that a given entry point is associated to a material.  <a href="#aab3495723da98686aea2857131ccbf60">More...</a><br /></td></tr>
<tr class="separator:aab3495723da98686aea2857131ccbf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5efc4c35497979e9ff3b9c3593670d4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa5efc4c35497979e9ff3b9c3593670d4">writeMaterialKnowledgeTypeSymbol</a> (std::ostream &amp;, const std::string &amp;, const <a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> &amp;)</td></tr>
<tr class="memdesc:aa5efc4c35497979e9ff3b9c3593670d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the symbol giving the material knowledge type.  <a href="#aa5efc4c35497979e9ff3b9c3593670d4">More...</a><br /></td></tr>
<tr class="separator:aa5efc4c35497979e9ff3b9c3593670d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518d849f7d0dc844f724f8a9a906bbb"><td class="memItemLeft" align="right" valign="top"><a id="a3518d849f7d0dc844f724f8a9a906bbb"></a>
MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>writeMaterialLaws</b> (std::ostream &amp;, const std::vector&lt; std::string &gt; &amp;)</td></tr>
<tr class="separator:a3518d849f7d0dc844f724f8a9a906bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af927e8d4859643f8af58246a967f1fe6"><td class="memItemLeft" align="right" valign="top"><a id="af927e8d4859643f8af58246a967f1fe6"></a>
MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>writeStaticVariables</b> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_static_variable_description_container.html">StaticVariableDescriptionContainer</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:af927e8d4859643f8af58246a967f1fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be1ee7db5018d5e8f0e10bcd4dc4bdd"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0be1ee7db5018d5e8f0e10bcd4dc4bdd">getMaterialLawLibraryNameBase</a> (const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;)</td></tr>
<tr class="separator:a0be1ee7db5018d5e8f0e10bcd4dc4bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c8df3da487cf59581619b7c0a3742"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae51c8df3da487cf59581619b7c0a3742">writeF77FUNCMacros</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:ae51c8df3da487cf59581619b7c0a3742"><td class="mdescLeft">&#160;</td><td class="mdescRight">define the F77_FUNC and F77_FUNC_ macros. We support the GNU (gfortran) and the intel compilers. By default, the GNU fortran naming scheme is used. This can be changed when compiling mfront generated sources by defining the INTEL_FORTRAN_COMPILER flag.  <a href="#ae51c8df3da487cf59581619b7c0a3742">More...</a><br /></td></tr>
<tr class="separator:ae51c8df3da487cf59581619b7c0a3742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69beba34c391ed35ef95d7e8fba3960a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a69beba34c391ed35ef95d7e8fba3960a">writeExportDirectives</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a69beba34c391ed35ef95d7e8fba3960a"><td class="mdescLeft">&#160;</td><td class="mdescRight">define export directives (visibility attributes) and calling conventions through the MFRONT_SHAREDOBJ and the MFRONT_CALLING_CONVENTION macros  <a href="#a69beba34c391ed35ef95d7e8fba3960a">More...</a><br /></td></tr>
<tr class="separator:a69beba34c391ed35ef95d7e8fba3960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d9b3422b4d320e01a21f042b3573f1"><td class="memItemLeft" align="right" valign="top"><a id="a62d9b3422b4d320e01a21f042b3573f1"></a>
MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>makeUpperCase</b> (const std::string &amp;)</td></tr>
<tr class="separator:a62d9b3422b4d320e01a21f042b3573f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d5f0592762c89afcec5993c02a9a55"><td class="memItemLeft" align="right" valign="top"><a id="ad5d5f0592762c89afcec5993c02a9a55"></a>
MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>makeLowerCase</b> (const std::string &amp;)</td></tr>
<tr class="separator:ad5d5f0592762c89afcec5993c02a9a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6ab40d59605edf43f1da6c21152d03"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6b6ab40d59605edf43f1da6c21152d03">displayGlossaryEntryCompleteDescription</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1glossary_1_1_glossary_entry.html">tfel::glossary::GlossaryEntry</a> &amp;)</td></tr>
<tr class="memdesc:a6b6ab40d59605edf43f1da6c21152d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">display the complete description of a glossary entry  <a href="#a6b6ab40d59605edf43f1da6c21152d03">More...</a><br /></td></tr>
<tr class="separator:a6b6ab40d59605edf43f1da6c21152d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f314f8ad542d78a287bdb5cefdc5326"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a6f314f8ad542d78a287bdb5cefdc5326">initDSLs</a> ()</td></tr>
<tr class="memdesc:a6f314f8ad542d78a287bdb5cefdc5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare dls's delivered with mfront  <a href="#a6f314f8ad542d78a287bdb5cefdc5326">More...</a><br /></td></tr>
<tr class="separator:a6f314f8ad542d78a287bdb5cefdc5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadc97fc84786a8a784094ead66d830"><td class="memItemLeft" align="right" valign="top"><a id="a9fadc97fc84786a8a784094ead66d830"></a>
MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>initInterfaces</b> ()</td></tr>
<tr class="separator:a9fadc97fc84786a8a784094ead66d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2342f3b523092875283f92a8ce591d3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ab2342f3b523092875283f92a8ce591d3">convert</a> (const <a class="el" href="structmfront_1_1_library_description.html#a04d5489883402187075df9f5ddf1dc0b">LibraryDescription::LibraryType</a>)</td></tr>
<tr class="separator:ab2342f3b523092875283f92a8ce591d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5930af55734e78bbe4ca6bc6c31c3ac4">mergeLibraryDescription</a> (<a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;, const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;)</td></tr>
<tr class="memdesc:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two library description  <a href="#a5930af55734e78bbe4ca6bc6c31c3ac4">More...</a><br /></td></tr>
<tr class="separator:a5930af55734e78bbe4ca6bc6c31c3ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161fd946add05bb2e18d11e897882fb6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a161fd946add05bb2e18d11e897882fb6">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;)</td></tr>
<tr class="memdesc:a161fd946add05bb2e18d11e897882fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a library description to a stream  <a href="#a161fd946add05bb2e18d11e897882fb6">More...</a><br /></td></tr>
<tr class="separator:a161fd946add05bb2e18d11e897882fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a0a09dcf58231a483127d6a60e2173"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af7a0a09dcf58231a483127d6a60e2173"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af7a0a09dcf58231a483127d6a60e2173">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:af7a0a09dcf58231a483127d6a60e2173"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a <a class="el" href="structmfront_1_1_library_description.html" title="This structure is used to build the compilation rules for the library. ">LibraryDescription</a> from a stream created by the CxxTokenizer class  <a href="#af7a0a09dcf58231a483127d6a60e2173">More...</a><br /></td></tr>
<tr class="separator:af7a0a09dcf58231a483127d6a60e2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d07a094c859ff0db93fa5cc1f909db6"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9d07a094c859ff0db93fa5cc1f909db6">generateMakeFile</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;, const std::string &amp;=&quot;src&quot;, const std::string &amp;=&quot;Makefile.mfront&quot;)</td></tr>
<tr class="memdesc:a9d07a094c859ff0db93fa5cc1f909db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function generating a standard Makefile from a target description.  <a href="#a9d07a094c859ff0db93fa5cc1f909db6">More...</a><br /></td></tr>
<tr class="separator:a9d07a094c859ff0db93fa5cc1f909db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58ad5a8c4a1231be6f634b96d196c41"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad58ad5a8c4a1231be6f634b96d196c41">callMake</a> (const std::string &amp;, const std::string &amp;=&quot;src&quot;, const std::string &amp;=&quot;Makefile.mfront&quot;)</td></tr>
<tr class="memdesc:ad58ad5a8c4a1231be6f634b96d196c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function calling the <code>make</code> utility in the given directory using the specified file.  <a href="#ad58ad5a8c4a1231be6f634b96d196c41">More...</a><br /></td></tr>
<tr class="separator:ad58ad5a8c4a1231be6f634b96d196c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8984a87917b2fac70f1e29179d5fd2a4"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8984a87917b2fac70f1e29179d5fd2a4">writeMaterialPropertyParametersHandler</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a8984a87917b2fac70f1e29179d5fd2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aeab415213e0f01d6d4bcc733c34fd"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a69aeab415213e0f01d6d4bcc733c34fd">writeAssignMaterialPropertyParameters</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a69aeab415213e0f01d6d4bcc733c34fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a9206c7828318e999580ad2d95d535"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a61a9206c7828318e999580ad2d95d535">getMaterialPropertyParametersHandlerClassName</a> (const std::string &amp;)</td></tr>
<tr class="separator:a61a9206c7828318e999580ad2d95d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af771366e22a74d5f1a7096f63b4cc1"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5af771366e22a74d5f1a7096f63b4cc1">getDebugMode</a> ()</td></tr>
<tr class="separator:a5af771366e22a74d5f1a7096f63b4cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777635dcafa05755620e3bf934b8c2e3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a777635dcafa05755620e3bf934b8c2e3">setDebugMode</a> (const bool)</td></tr>
<tr class="memdesc:a777635dcafa05755620e3bf934b8c2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or diable the debug mode  <a href="#a777635dcafa05755620e3bf934b8c2e3">More...</a><br /></td></tr>
<tr class="separator:a777635dcafa05755620e3bf934b8c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff1d91d7e2e9e79bac2c3459070307"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae0ff1d91d7e2e9e79bac2c3459070307">getVerboseMode</a> ()</td></tr>
<tr class="separator:ae0ff1d91d7e2e9e79bac2c3459070307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6fb5de8a983c43f315404947ba71bb"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b6fb5de8a983c43f315404947ba71bb">setVerboseMode</a> (const <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>=VERBOSE_LEVEL0)</td></tr>
<tr class="separator:a0b6fb5de8a983c43f315404947ba71bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d053fd3da3fd9ae82f6010d08c18d4"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a36d053fd3da3fd9ae82f6010d08c18d4">getLogStream</a> ()</td></tr>
<tr class="separator:a36d053fd3da3fd9ae82f6010d08c18d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2d23ca5d808da874d2d4a4c8656fb"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a14c2d23ca5d808da874d2d4a4c8656fb">setLogStream</a> (const std::string &amp;f)</td></tr>
<tr class="separator:a14c2d23ca5d808da874d2d4a4c8656fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42cdcd4cbf373b3b5e5990f834f0d6b"><td class="memItemLeft" align="right" valign="top">MFRONTLOGSTREAM_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af42cdcd4cbf373b3b5e5990f834f0d6b">setLogStream</a> (std::ostream &amp;)</td></tr>
<tr class="separator:af42cdcd4cbf373b3b5e5990f834f0d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ad670e75ef4c065bd76ec0dd3c25cacfa">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditionnally insert a string into a vector of string : an element is inserted if not already present or empty.  <a href="#ad670e75ef4c065bd76ec0dd3c25cacfa">More...</a><br /></td></tr>
<tr class="separator:ad670e75ef4c065bd76ec0dd3c25cacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992daf2984c030fad89d9dd584776a99"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a992daf2984c030fad89d9dd584776a99">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const char *const)</td></tr>
<tr class="memdesc:a992daf2984c030fad89d9dd584776a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditionnally insert a string into a vector of string : an element is inserted if not already present or has zero size or is nulltpr.  <a href="#a992daf2984c030fad89d9dd584776a99">More...</a><br /></td></tr>
<tr class="separator:a992daf2984c030fad89d9dd584776a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6f2952665cd1e6ab855be493999b2f"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a9c6f2952665cd1e6ab855be493999b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a9c6f2952665cd1e6ab855be493999b2f">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const Container &amp;)</td></tr>
<tr class="memdesc:a9c6f2952665cd1e6ab855be493999b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">call insert_if on every element of a container.  <a href="#a9c6f2952665cd1e6ab855be493999b2f">More...</a><br /></td></tr>
<tr class="separator:a9c6f2952665cd1e6ab855be493999b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aea7969df45cbaf9df0028b0aafa5f73a">insert_if</a> (std::vector&lt; std::string &gt; &amp;, const std::initializer_list&lt; Value &gt; &amp;)</td></tr>
<tr class="memdesc:aea7969df45cbaf9df0028b0aafa5f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">call insert_if on every element of an initializer_list.  <a href="#aea7969df45cbaf9df0028b0aafa5f73a">More...</a><br /></td></tr>
<tr class="separator:aea7969df45cbaf9df0028b0aafa5f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97d148fe6f8bb16ce41c62e153521a7"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af97d148fe6f8bb16ce41c62e153521a7">write</a> (std::ostream &amp;, const std::vector&lt; std::string &gt; &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:af97d148fe6f8bb16ce41c62e153521a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a vector of string to the output stream  <a href="#af97d148fe6f8bb16ce41c62e153521a7">More...</a><br /></td></tr>
<tr class="separator:af97d148fe6f8bb16ce41c62e153521a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8a01ab1f7a5376fe356b65ea8b3fb655">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an object of type T from a stream created by the CxxTokenizer class  <a href="#a8a01ab1f7a5376fe356b65ea8b3fb655">More...</a><br /></td></tr>
<tr class="separator:a8a01ab1f7a5376fe356b65ea8b3fb655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e1e998786548791706c7e410bbd5f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20e1e998786548791706c7e410bbd5f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a20e1e998786548791706c7e410bbd5f8">read</a> (T &amp;, <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a20e1e998786548791706c7e410bbd5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">read an object of type T from a stream created by the CxxTokenizer class  <a href="#a20e1e998786548791706c7e410bbd5f8">More...</a><br /></td></tr>
<tr class="separator:a20e1e998786548791706c7e410bbd5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42669badf4c7388d3632014efcaedc38"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a42669badf4c7388d3632014efcaedc38"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a42669badf4c7388d3632014efcaedc38">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a42669badf4c7388d3632014efcaedc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from a stream created by the CxxTokenizer class  <a href="#a42669badf4c7388d3632014efcaedc38">More...</a><br /></td></tr>
<tr class="separator:a42669badf4c7388d3632014efcaedc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0af8872222ac7437a786f54982927"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a16a0af8872222ac7437a786f54982927"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a16a0af8872222ac7437a786f54982927">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a16a0af8872222ac7437a786f54982927"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a string from a stream created by the CxxTokenizer class  <a href="#a16a0af8872222ac7437a786f54982927">More...</a><br /></td></tr>
<tr class="separator:a16a0af8872222ac7437a786f54982927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aba14060c12a5afc8ad04d71eba1a9c4d">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a vector of strings from a stream created by the CxxTokenizer class  <a href="#aba14060c12a5afc8ad04d71eba1a9c4d">More...</a><br /></td></tr>
<tr class="separator:aba14060c12a5afc8ad04d71eba1a9c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40877174d229287a91b8710caaab96f2"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::pair&lt; std::string, <a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a40877174d229287a91b8710caaab96f2">readVariableBounds</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;p, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> pe)</td></tr>
<tr class="memdesc:a40877174d229287a91b8710caaab96f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the bounds associated to a variable  <a href="#a40877174d229287a91b8710caaab96f2">More...</a><br /></td></tr>
<tr class="separator:a40877174d229287a91b8710caaab96f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f15d5db7d916e4e9fe5c0381ffe7374"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::tuple&lt; std::string, bool, unsigned short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8f15d5db7d916e4e9fe5c0381ffe7374">extractVariableNameAndArrayPosition</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a8f15d5db7d916e4e9fe5c0381ffe7374"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the name of a variable and an array position from a string.  <a href="#a8f15d5db7d916e4e9fe5c0381ffe7374">More...</a><br /></td></tr>
<tr class="separator:a8f15d5db7d916e4e9fe5c0381ffe7374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4feab99cb8d6d0576ed08334efa4764f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4feab99cb8d6d0576ed08334efa4764f">getPedanticMode</a> ()</td></tr>
<tr class="separator:a4feab99cb8d6d0576ed08334efa4764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a0b2740ed67d88982390ad68ba6cdcc8a">setPedanticMode</a> (const bool)</td></tr>
<tr class="memdesc:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">enable or diable the pedantic mode  <a href="#a0b2740ed67d88982390ad68ba6cdcc8a">More...</a><br /></td></tr>
<tr class="separator:a0b2740ed67d88982390ad68ba6cdcc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe80e34f9ad35a89aa879d984e451e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abe80e34f9ad35a89aa879d984e451e0b">writeStandardPerformanceProfiling</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;=&quot;&quot;)</td></tr>
<tr class="memdesc:abe80e34f9ad35a89aa879d984e451e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function to declare a timer  <a href="#abe80e34f9ad35a89aa879d984e451e0b">More...</a><br /></td></tr>
<tr class="separator:abe80e34f9ad35a89aa879d984e451e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff29f71d695cca87edc553d8549a175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#abff29f71d695cca87edc553d8549a175">writeStandardPerformanceProfilingBegin</a> (std::ostream &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;=&quot;&quot;)</td></tr>
<tr class="memdesc:abff29f71d695cca87edc553d8549a175"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function writing the beginning of a performance measurement  <a href="#abff29f71d695cca87edc553d8549a175">More...</a><br /></td></tr>
<tr class="separator:abff29f71d695cca87edc553d8549a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788b4f8e27d07163d1fe30be9dce28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2788b4f8e27d07163d1fe30be9dce28c">writeStandardPerformanceProfilingEnd</a> (std::ostream &amp;)</td></tr>
<tr class="memdesc:a2788b4f8e27d07163d1fe30be9dce28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">: an helper function writing the end of a performance measurement  <a href="#a2788b4f8e27d07163d1fe30be9dce28c">More...</a><br /></td></tr>
<tr class="separator:a2788b4f8e27d07163d1fe30be9dce28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02780b9599daa678096f6fceff95fd10"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a02780b9599daa678096f6fceff95fd10">to_string</a> (const <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &amp;)</td></tr>
<tr class="memdesc:a02780b9599daa678096f6fceff95fd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert to string  <a href="#a02780b9599daa678096f6fceff95fd10">More...</a><br /></td></tr>
<tr class="separator:a02780b9599daa678096f6fceff95fd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba13d8532f943f5c56744d78f71e9d3"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a8ba13d8532f943f5c56744d78f71e9d3">describes</a> (const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const std::string &amp;)</td></tr>
<tr class="separator:a8ba13d8532f943f5c56744d78f71e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8e0e717df9694a1eb87461e5d20c9"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a52e8e0e717df9694a1eb87461e5d20c9">mergeTargetsDescription</a> (<a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;, const bool)</td></tr>
<tr class="memdesc:a52e8e0e717df9694a1eb87461e5d20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge two targets description  <a href="#a52e8e0e717df9694a1eb87461e5d20c9">More...</a><br /></td></tr>
<tr class="separator:a52e8e0e717df9694a1eb87461e5d20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#aa929a6b5519f6670b1eb3555b72ae6f2">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;)</td></tr>
<tr class="memdesc:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a target description to a stream  <a href="#aa929a6b5519f6670b1eb3555b72ae6f2">More...</a><br /></td></tr>
<tr class="separator:aa929a6b5519f6670b1eb3555b72ae6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2959bc26d843d96ef1376be34b9016f2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2959bc26d843d96ef1376be34b9016f2"><td class="memTemplItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2959bc26d843d96ef1376be34b9016f2">read</a> (<a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;, const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>)</td></tr>
<tr class="memdesc:a2959bc26d843d96ef1376be34b9016f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a TargetDescription from a stream created by the CxxTokenizer class  <a href="#a2959bc26d843d96ef1376be34b9016f2">More...</a><br /></td></tr>
<tr class="separator:a2959bc26d843d96ef1376be34b9016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39ab3f99649ecc8813a0ad46c824459"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#af39ab3f99649ecc8813a0ad46c824459">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="separator:af39ab3f99649ecc8813a0ad46c824459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51285a40ee07f9e48e9352b2cfec5d"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a5d51285a40ee07f9e48e9352b2cfec5d">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;, const unsigned short)</td></tr>
<tr class="separator:a5d51285a40ee07f9e48e9352b2cfec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4c3112eca7131d291f5f78cbac51f"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a55b4c3112eca7131d291f5f78cbac51f">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;)</td></tr>
<tr class="separator:a55b4c3112eca7131d291f5f78cbac51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e70fa44b1baf7c4cfdff2ff45c88f6a"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a2e70fa44b1baf7c4cfdff2ff45c88f6a">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;, const unsigned short)</td></tr>
<tr class="separator:a2e70fa44b1baf7c4cfdff2ff45c88f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d1e6787e57312af863c5bfe6776c8"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#ae64d1e6787e57312af863c5bfe6776c8">hasBounds</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="separator:ae64d1e6787e57312af863c5bfe6776c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4338e1f5c1a194fe2eb5bf8972e87d95"><td class="memItemLeft" align="right" valign="top">MFRONT_VISIBILITY_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemfront.html#a4338e1f5c1a194fe2eb5bf8972e87d95">hasPhysicalBounds</a> (const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;)</td></tr>
<tr class="separator:a4338e1f5c1a194fe2eb5bf8972e87d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains material used to build the <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> code generator. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a037bb09752bcfbdea96d56ba051c71cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037bb09752bcfbdea96d56ba051c71cd">&#9670;&nbsp;</a></span>BehaviourSymmetryType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">mfront::BehaviourSymmetryType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the castem finite element code, its is mandatory to distinguish isotropic and orthotropic behaviours </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa9b7a794b72a2644ad38294fb159ee96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b7a794b72a2644ad38294fb159ee96">&#9670;&nbsp;</a></span>callCMake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::callCMake </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function calling the <code>make</code> utility in the given directory using the specified file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad58ad5a8c4a1231be6f634b96d196c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58ad5a8c4a1231be6f634b96d196c41">&#9670;&nbsp;</a></span>callMake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::callMake </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;Makefile.mfront&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function calling the <code>make</code> utility in the given directory using the specified file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a4e2a85b67be2d042e0917cf199ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a4e2a85b67be2d042e0917cf199ac5">&#9670;&nbsp;</a></span>checkIsStrictlyNegative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::checkIsStrictlyNegative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that the given material property description is strictly negative,when described by a constant material property </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d0ccbb48b35815c668014be1573004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d0ccbb48b35815c668014be1573004">&#9670;&nbsp;</a></span>checkIsStrictlyPositive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::checkIsStrictlyPositive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_behaviour_description.html#aa1f2fa54d36c03d6f2012e6e58e9ce57">BehaviourDescription::MaterialProperty</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that the given material property description is strictly positive, when described by a constant material property </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2342f3b523092875283f92a8ce591d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2342f3b523092875283f92a8ce591d3">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html#a04d5489883402187075df9f5ddf1dc0b">LibraryDescription::LibraryType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string describing the library type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: library type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ba13d8532f943f5c56744d78f71e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba13d8532f943f5c56744d78f71e9d3">&#9670;&nbsp;</a></span>describes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::describes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the target description describes a library with the given name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: library name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b6ab40d59605edf43f1da6c21152d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6ab40d59605edf43f1da6c21152d03">&#9670;&nbsp;</a></span>displayGlossaryEntryCompleteDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::displayGlossaryEntryCompleteDescription </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1glossary_1_1_glossary_entry.html">tfel::glossary::GlossaryEntry</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>display the complete description of a glossary entry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>: glossary entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f15d5db7d916e4e9fe5c0381ffe7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f15d5db7d916e4e9fe5c0381ffe7374">&#9670;&nbsp;</a></span>extractVariableNameAndArrayPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::tuple&lt;std::string,bool,unsigned short&gt; mfront::extractVariableNameAndArrayPosition </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract the name of a variable and an array position from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>variable name and array position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple giving the variable name, the fact that a position was read, the read position if any.</dd></dl>
<p>For example, calling this function with the <code>A[10]</code> argument results in the following tuple: <code>{"A",true,10}</code>.</p>
<p>With <code>B</code> as argument, the result is the following tuple: <code>{"B",false,0}</code>. </p>

</div>
</div>
<a id="a5e22ed7643448068ef626cc999f71af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e22ed7643448068ef626cc999f71af4">&#9670;&nbsp;</a></span>generateCMakeListsFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::generateCMakeListsFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function generating a standard CMake from a target description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d07a094c859ff0db93fa5cc1f909db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d07a094c859ff0db93fa5cc1f909db6">&#9670;&nbsp;</a></span>generateMakeFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::generateMakeFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_generator_options.html">GeneratorOptions</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;src&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;Makefile.mfront&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function generating a standard Makefile from a target description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>: options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>: directory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af771366e22a74d5f1a7096f63b4cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af771366e22a74d5f1a7096f63b4cc1">&#9670;&nbsp;</a></span>getDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::getDebugMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the debug mode is enabled </dd></dl>

</div>
</div>
<a id="a36d053fd3da3fd9ae82f6010d08c18d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d053fd3da3fd9ae82f6010d08c18d4">&#9670;&nbsp;</a></span>getLogStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT std::ostream&amp; mfront::getLogStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current logging stream </dd></dl>

</div>
</div>
<a id="a0be1ee7db5018d5e8f0e10bcd4dc4bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be1ee7db5018d5e8f0e10bcd4dc4bdd">&#9670;&nbsp;</a></span>getMaterialLawLibraryNameBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getMaterialLawLibraryNameBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the base name (without interface specification) of the library to be generated by <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61a9206c7828318e999580ad2d95d535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a9206c7828318e999580ad2d95d535">&#9670;&nbsp;</a></span>getMaterialPropertyParametersHandlerClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::getMaterialPropertyParametersHandlerClassName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4feab99cb8d6d0576ed08334efa4764f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4feab99cb8d6d0576ed08334efa4764f">&#9670;&nbsp;</a></span>getPedanticMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::getPedanticMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the pedantic mode is enabled </dd></dl>

</div>
</div>
<a id="ae0ff1d91d7e2e9e79bac2c3459070307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff1d91d7e2e9e79bac2c3459070307">&#9670;&nbsp;</a></span>getVerboseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>&amp; mfront::getVerboseMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current verbose level </dd></dl>

</div>
</div>
<a id="af39ab3f99649ecc8813a0ad46c824459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39ab3f99649ecc8813a0ad46c824459">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasBounds</code> method </dd></dl>

</div>
</div>
<a id="a5d51285a40ee07f9e48e9352b2cfec5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51285a40ee07f9e48e9352b2cfec5d">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasBounds</code> method </dd></dl>

</div>
</div>
<a id="ae64d1e6787e57312af863c5bfe6776c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d1e6787e57312af863c5bfe6776c8">&#9670;&nbsp;</a></span>hasBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if one of the variables has bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b4c3112eca7131d291f5f78cbac51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4c3112eca7131d291f5f78cbac51f">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasPhysicalBounds</code> method. </dd></dl>

</div>
</div>
<a id="a2e70fa44b1baf7c4cfdff2ff45c88f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e70fa44b1baf7c4cfdff2ff45c88f6a">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description.html">VariableDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the variable has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is a simple wrapper around the <code>hasPhysicalBounds</code> method. </dd></dl>

</div>
</div>
<a id="a4338e1f5c1a194fe2eb5bf8972e87d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4338e1f5c1a194fe2eb5bf8972e87d95">&#9670;&nbsp;</a></span>hasPhysicalBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT bool mfront::hasPhysicalBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_variable_description_container.html">VariableDescriptionContainer</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if one of the variables has physical bounds. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>variable description container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f314f8ad542d78a287bdb5cefdc5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f314f8ad542d78a287bdb5cefdc5326">&#9670;&nbsp;</a></span>initDSLs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::initDSLs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>declare dls's delivered with mfront </p>
<p>Users can use the MFRONT_ADDITIONAL_LIBRARIES environment to load their own libraries. See the <a class="el" href="structmfront_1_1_d_s_l_proxy.html">DSLProxy</a> class for details. </p>

</div>
</div>
<a id="ad670e75ef4c065bd76ec0dd3c25cacfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad670e75ef4c065bd76ec0dd3c25cacfa">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conditionnally insert a string into a vector of string : an element is inserted if not already present or empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992daf2984c030fad89d9dd584776a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992daf2984c030fad89d9dd584776a99">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>const</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conditionnally insert a string into a vector of string : an element is inserted if not already present or has zero size or is nulltpr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c6f2952665cd1e6ab855be493999b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6f2952665cd1e6ab855be493999b2f">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call insert_if on every element of a container. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Container::value_type must be convertible to a string </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>: type of source </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7969df45cbaf9df0028b0aafa5f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7969df45cbaf9df0028b0aafa5f73a">&#9670;&nbsp;</a></span>insert_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mfront::insert_if </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call insert_if on every element of an initializer_list. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Value must be convertible to a string </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>: type of the objects of the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5930af55734e78bbe4ca6bc6c31c3ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5930af55734e78bbe4ca6bc6c31c3ac4">&#9670;&nbsp;</a></span>mergeLibraryDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::mergeLibraryDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two library description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e8e0e717df9694a1eb87461e5d20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e8e0e717df9694a1eb87461e5d20c9">&#9670;&nbsp;</a></span>mergeTargetsDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::mergeTargetsDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge two targets description </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>: destination </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: source </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: override specific targets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a161fd946add05bb2e18d11e897882fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161fd946add05bb2e18d11e897882fb6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a library description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: library description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa929a6b5519f6670b1eb3555b72ae6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa929a6b5519f6670b1eb3555b72ae6f2">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::ostream&amp; mfront::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a target description to a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: target description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a01ab1f7a5376fe356b65ea8b3fb655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a01ab1f7a5376fe356b65ea8b3fb655">&#9670;&nbsp;</a></span>read() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read an object of type T from a stream created by the CxxTokenizer class </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>: type to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object read. If this function succeed, p points past the last token treated. If this function fails, p shall be unchanged. </dd></dl>

</div>
</div>
<a id="a20e1e998786548791706c7e410bbd5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e1e998786548791706c7e410bbd5f8">&#9670;&nbsp;</a></span>read() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mfront::read </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read an object of type T from a stream created by the CxxTokenizer class </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>: type to be read </td></tr>
    <tr><td class="paramname">v</td><td>: value read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object read. If this function succeed, p points past the last token treated. If this function fails, p shall be unchanged. </dd></dl>

</div>
</div>
<a id="a42669badf4c7388d3632014efcaedc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42669badf4c7388d3632014efcaedc38">&#9670;&nbsp;</a></span>read() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT double mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a16a0af8872222ac7437a786f54982927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a0af8872222ac7437a786f54982927">&#9670;&nbsp;</a></span>read() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a string from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="af7a0a09dcf58231a483127d6a60e2173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a0a09dcf58231a483127d6a60e2173">&#9670;&nbsp;</a></span>read() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_library_description.html">LibraryDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a <a class="el" href="structmfront_1_1_library_description.html" title="This structure is used to build the compilation rules for the library. ">LibraryDescription</a> from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the library description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="aba14060c12a5afc8ad04d71eba1a9c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14060c12a5afc8ad04d71eba1a9c4d">&#9670;&nbsp;</a></span>read() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::vector&lt;std::string&gt; mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a vector of strings from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a2959bc26d843d96ef1376be34b9016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2959bc26d843d96ef1376be34b9016f2">&#9670;&nbsp;</a></span>read() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT <a class="el" href="structmfront_1_1_targets_description.html">TargetsDescription</a> mfront::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a TargetDescription from a stream created by the CxxTokenizer class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the target description read. If this function succeed, p points past the last token treated. If this function fails, p is unchanged. </dd></dl>

</div>
</div>
<a id="a40877174d229287a91b8710caaab96f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40877174d229287a91b8710caaab96f2">&#9670;&nbsp;</a></span>readVariableBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::pair&lt;std::string,<a class="el" href="structmfront_1_1_variable_bounds_description.html">VariableBoundsDescription</a>&gt; mfront::readVariableBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1utilities_1_1_cxx_tokenizer.html#a5e7b9fe171d1d7eeefd475dc65e9ed36">tfel::utilities::CxxTokenizer::const_iterator</a>&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the bounds associated to a variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>: current position in the stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>: end of the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple giving the variable name and the bounds </dd></dl>

</div>
</div>
<a id="a777635dcafa05755620e3bf934b8c2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777635dcafa05755620e3bf934b8c2e3">&#9670;&nbsp;</a></span>setDebugMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::setDebugMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or diable the debug mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: if true, set the debug mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a89c928d3f25c909d1234e3c8e09104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89c928d3f25c909d1234e3c8e09104">&#9670;&nbsp;</a></span>setElasticSymmetryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::setElasticSymmetryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmfront_1_1_behaviour_description.html">BehaviourDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#a037bb09752bcfbdea96d56ba051c71cd">BehaviourSymmetryType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the elastic symmetry of a material if not already defined. If already defined, check that the symmetry is the same as the one given in argument </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bd</td><td>behaviour description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetry type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c2d23ca5d808da874d2d4a4c8656fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2d23ca5d808da874d2d4a4c8656fb">&#9670;&nbsp;</a></span>setLogStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT void mfront::setLogStream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the current logging stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af42cdcd4cbf373b3b5e5990f834f0d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42cdcd4cbf373b3b5e5990f834f0d6b">&#9670;&nbsp;</a></span>setLogStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT void mfront::setLogStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the current logging stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>: new logging stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>the stream is not handled by this function. The user has to take care of it </dd></dl>

</div>
</div>
<a id="a0b2740ed67d88982390ad68ba6cdcc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2740ed67d88982390ad68ba6cdcc8a">&#9670;&nbsp;</a></span>setPedanticMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::setPedanticMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable or diable the pedantic mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>: if true, set the pedantic mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b6fb5de8a983c43f315404947ba71bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6fb5de8a983c43f315404947ba71bb">&#9670;&nbsp;</a></span>setVerboseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONTLOGSTREAM_VISIBILITY_EXPORT void mfront::setVerboseMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#a4c0ac1ef6016bdc993a52f0602919353">VerboseLevel</a>&#160;</td>
          <td class="paramname"> = <code>VERBOSE_LEVEL0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>change the verbose level </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>new verbose level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02780b9599daa678096f6fceff95fd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02780b9599daa678096f6fceff95fd10">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT std::string mfront::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_supported_types_1_1_type_size.html">SupportedTypes::TypeSize</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert to string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>type size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af97d148fe6f8bb16ce41c62e153521a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97d148fe6f8bb16ce41c62e153521a7">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a vector of string to the output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector of string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>: identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69aeab415213e0f01d6d4bcc733c34fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69aeab415213e0f01d6d4bcc733c34fd">&#9670;&nbsp;</a></span>writeAssignMaterialPropertyParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeAssignMaterialPropertyParameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>ouptut stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>type of the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>interface name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c7f2ac74804568b167aeef08b15bacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f2ac74804568b167aeef08b15bacc">&#9670;&nbsp;</a></span>writeEntryPointSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeEntryPointSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a877674ed58972534a1152a8b0c9294ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877674ed58972534a1152a8b0c9294ea">&#9670;&nbsp;</a></span>writeEntryPointSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeEntryPointSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol stating that a given name entry point (<code>C</code>-like function for example) has been created using <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point alias </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n2</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69beba34c391ed35ef95d7e8fba3960a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69beba34c391ed35ef95d7e8fba3960a">&#9670;&nbsp;</a></span>writeExportDirectives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeExportDirectives </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define export directives (visibility attributes) and calling conventions through the MFRONT_SHAREDOBJ and the MFRONT_CALLING_CONVENTION macros </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: output file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae51c8df3da487cf59581619b7c0a3742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51c8df3da487cf59581619b7c0a3742">&#9670;&nbsp;</a></span>writeF77FUNCMacros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeF77FUNCMacros </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define the F77_FUNC and F77_FUNC_ macros. We support the GNU (gfortran) and the intel compilers. By default, the GNU fortran naming scheme is used. This can be changed when compiling mfront generated sources by defining the INTEL_FORTRAN_COMPILER flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>: output file</td></tr>
  </table>
  </dd>
</dl>
<p><a href="https://en.wikipedia.org/wiki/Name_mangling">https://en.wikipedia.org/wiki/Name_mangling</a> :</p>
<p>Many compilers, including SGI's IRIX compilers, GNU Fortran, and Intel's Fortran compiler (except on Microsoft Windows), convert all identifiers to lower case plus an underscore ("foo_" and "foo_bar_"). On Microsoft Windows, the Intel Fortran compiler defaults to uppercase without an underscore.[2]</p>
<p>[2] User and Reference Guide for the Intel Fortran Compiler 15.0, Intel Corporation (2014), Summary of Mixed-Language Issues. Accessed 17 Nov. 2014. </p>

</div>
</div>
<a id="ab3deeabbd453cda378526fab72776315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3deeabbd453cda378526fab72776315">&#9670;&nbsp;</a></span>writeInterfaceSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeInterfaceSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol for the interface of an entry point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point alias </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5efc4c35497979e9ff3b9c3593670d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5efc4c35497979e9ff3b9c3593670d4">&#9670;&nbsp;</a></span>writeMaterialKnowledgeTypeSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeMaterialKnowledgeTypeSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemfront.html#aec8d27b6a665a341871201e8ecb345ef">MaterialKnowledgeType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the symbol giving the material knowledge type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>material knowledge type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8984a87917b2fac70f1e29179d5fd2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8984a87917b2fac70f1e29179d5fd2a4">&#9670;&nbsp;</a></span>writeMaterialPropertyParametersHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeMaterialPropertyParametersHandler </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmfront_1_1_material_property_description.html">MaterialPropertyDescription</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>ouptut stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpd</td><td>material property description </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>name of the material property </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>type of the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>interface name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3495723da98686aea2857131ccbf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3495723da98686aea2857131ccbf60">&#9670;&nbsp;</a></span>writeMaterialSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeMaterialSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a symbol stating that a given entry point is associated to a material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>entry point name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material name name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe80e34f9ad35a89aa879d984e451e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe80e34f9ad35a89aa879d984e451e0b">&#9670;&nbsp;</a></span>writeStandardPerformanceProfiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfront::writeStandardPerformanceProfiling </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function to declare a timer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: class name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: code block name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: time temporary variable suffix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff29f71d695cca87edc553d8549a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff29f71d695cca87edc553d8549a175">&#9670;&nbsp;</a></span>writeStandardPerformanceProfilingBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfront::writeStandardPerformanceProfilingBegin </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function writing the beginning of a performance measurement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>: class name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: code block name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: time temporary variable suffix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2788b4f8e27d07163d1fe30be9dce28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2788b4f8e27d07163d1fe30be9dce28c">&#9670;&nbsp;</a></span>writeStandardPerformanceProfilingEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mfront::writeStandardPerformanceProfilingEnd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: an helper function writing the end of a performance measurement </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>: output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d11ccdde7e9feaef71c7f040c122ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d11ccdde7e9feaef71c7f040c122ea6">&#9670;&nbsp;</a></span>writeTFELVersionSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MFRONT_VISIBILITY_EXPORT void mfront::writeTFELVersionSymbol </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a specific symbol giving the version of <code><a class="el" href="structmfront_1_1_m_front.html" title="the main class of MFront ">MFront</a></code> used to generate the given entry point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>entry point name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 18 2018 20:55:01 for tfel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
