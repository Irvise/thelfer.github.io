<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Implementation of a perfect plastic behaviour using the Drucker yield criterion (Drucker (1949)) and two of its extensions to orthotropy (Cazacu and Barlat (2001))</title>
        <meta name="author" content="Thomas Helfer" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      a.sourceLine { display: inline-block; line-height: 1.25; }
      a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
      a.sourceLine:empty { height: 1.2em; position: absolute; }
      .sourceCode { overflow: visible; }
      code.sourceCode { white-space: pre; position: relative; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      code.sourceCode { white-space: pre-wrap; }
      a.sourceLine { text-indent: -1em; padding-left: 1em; }
      }
      pre.numberSource a.sourceLine
        { position: relative; }
      pre.numberSource a.sourceLine:empty
        { position: absolute; }
      pre.numberSource a.sourceLine::before
        { content: attr(data-line-number);
          position: absolute; left: -5em; text-align: right; vertical-align: baseline;
          border: none; pointer-events: all;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  }
      @media screen {
      a.sourceLine::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Interfaces</a></li>
	    <li><a href="mfront-doc.html">mfront-doc</a></li>
	    <li><a href="mtest.html">mtest</a></li>
	    <li><a href="mfm.html">mfm</a></li>
	    <li><a href="mfm-test-generator.html">mfm</a></li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://sourceforge.net/projects/tfel/files">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	    <ul>
            <li><a>Versions 2.0.x</a>
                <ul>
                <li><a href="release-notes.html">Versions prior to 2.0.5</a><li>
	 	       <li><a href="release-notes-2.0.5.html">Version 2.0.5</a><li>
                </ul>
            </li>
            <li><a>Versions 3.0.x</a>
                <ul>
                    <li><a href="release-notes-3.0.html">Version 3.0.0</a><li>
		           <li><a href="release-notes-3.0.1.html">Version 3.0.1</a><li>
                    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a><li>
		           <li><a href="release-notes-3.0.3.html">Version 3.0.3</a><li>
		           <li><a href="release-notes-3.0.4.html">Version 3.0.4</a><li>
		           <li><a href="release-notes-3.0.5.html">Version 3.0.5</a><li>
                </ul>
           </li>
            <li><a>Versions 3.1.x</a>
                <ul>
		<li><a href="release-notes-3.1.html">Version 3.1.0</a><li>
		<li><a href="release-notes-3.1.1.html">Version 3.1.1</a><li>
		<li><a href="release-notes-3.1.2.html">Version 3.1.2</a><li>
		<li><a href="release-notes-3.1.3.html">Version 3.1.3</a><li>
		<li><a href="release-notes-3.1.4.html">Version 3.1.4</a><li>
		<li><a href="release-notes-3.1.5.html">Version 3.1.5</a><li>
                </ul>
           </li>
            <li><a>Versions 3.2.x</a>
                <ul>
		           <li><a href="release-notes-3.2.html">Version 3.2.0</a><li>
		           <li><a href="release-notes-3.2.1.html">Version 3.2.1</a><li>
		           <li><a href="release-notes-3.2.2.html">Version 3.2.2</a><li>
                </ul>
           </li>
            <li><a>Versions 3.3.x</a>
                <ul>
		           <li><a href="release-notes-3.3.html">Version 3.3.0</a><li>
                </ul>
           </li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
	    <li><a>Behaviours</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
    		    <li><a href="epx.html">EUROPLEXUS</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic Behaviour Interface</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="material.html">TFEL/Material</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a>MFront keywords</a>
	      <ul>
		<li><a href="DefaultDSL-keywords.html">DefaultDSL</a></li> 
		<li><a href="DefaultCZMDSL-keywords.html">DefaultCZMDSL</a></li> 
		<li><a href="DefaultFiniteStrainDSL-keywords.html">DefaultFiniteStrainDSL</a></li> 
		<li><a href="Implicit-keywords.html">Implicit</a></li> 
		<li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li> 
		<li><a href="ImplicitII-keywords.html">ImplicitII</a></li> 
		<li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li> 
		<li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li> 
		<li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li> 
		<li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li> 
		<li><a href="Model-keywords.html">Model</a></li> 
		<li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li> 
		<li><a href="RungeKutta-keywords.html">RungeKutta</a></li> 
	      </ul>
	    </li>
	    <li><a href="MTest-keywords.html">MTest keywords</a></li>
	    <li><a href="physical-constants.html">Physical constants</a></li>
	    <li><a href="glossary.html">Glossary</a></li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="svn.html">Access to source repositories</a></li>
	    <li><a href="devel.html">Development guidelines</a></li>
	    <li><a href="http://sourceforge.net/p/tfel/tickets">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="http://sourceforge.net/p/tfel/discussion">Forum</a></li>
	    <li><a href="http://sourceforge.net/p/tfel/tfel">Mailing lists</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
    <br></br>
        <div id="header">
      <h1 class="title">Implementation of a perfect plastic behaviour using the Drucker yield criterion (<span class="citation" data-cites="drucker_relation_1949">Drucker (1949)</span>) and two of its extensions to orthotropy (<span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>)</h1>
                  <h2 class="author">Thomas Helfer</h2>
                  <h3 class="date">21/11/2017</h3>
          </div>
            <div id="TOC">
      <ul>
      <li><a href="#description">Description</a><ul>
      <li><a href="#elasticity">Elasticity</a></li>
      <li><a href="#plasticity">Plasticity</a></li>
      <li><a href="#derivatives-of-the-equivalent-stress">Derivatives of the equivalent stress</a><ul>
      <li><a href="#first-derivative-of-the-equivalent-stress">First derivative of the equivalent stress</a></li>
      <li><a href="#second-derivative-of-the-equivalent-stress">Second derivative of the equivalent stress</a></li>
      </ul></li>
      </ul></li>
      <li><a href="#implicit-scheme">Implicit scheme</a><ul>
      <li><a href="#choice-of-the-state-variables">Choice of the state variables</a></li>
      <li><a href="#elastic-prediction">Elastic prediction</a></li>
      <li><a href="#equation-assciated-with-the-elastic-strain">Equation assciated with the elastic strain</a></li>
      <li><a href="#equation-governing-the-material-evolution-under-plastic-loading">Equation governing the material evolution under plastic loading</a></li>
      </ul></li>
      <li><a href="#implementation">Implementation</a><ul>
      <li><a href="#metadata">Metadata</a></li>
      <li><a href="#supported-modelling-hypothesis">Supported modelling hypothesis</a></li>
      <li><a href="#the-standard-elasticity-brick">The standard elasticity brick</a></li>
      <li><a href="#numerical-parameters">Numerical parameters</a></li>
      <li><a href="#state-variables">State variables</a></li>
      <li><a href="#material-constants">Material constants</a></li>
      <li><a href="#local-variable-declaration">Local variable declaration</a></li>
      <li><a href="#local-variable-initialization">Local variable initialization</a></li>
      <li><a href="#implicit-system">Implicit system</a></li>
      </ul></li>
      <li><a href="#a-first-extension-to-orthotropy-cazacu_generalization_2001">A first Extension to orthotropy (<span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>)</a><ul>
      <li><a href="#verification">Verification</a></li>
      </ul></li>
      <li><a href="#a-second-extension-to-orthotropy-barlat_linear_2007">A second extension to orthotropy (<span class="citation" data-cites="barlat_linear_2007">Barlat, Yoon, and Cazacu (2007)</span>)</a><ul>
      <li><a href="#verification-1">Verification</a></li>
      </ul></li>
      <li><a href="#references">References</a></li>
      </ul>
    </div>
        
<p>This paper is dedicated to the implementation a perfect plastic behaviour based on the Drucker yield criterion and two generalizations to orthotropy.</p>
<p>Those three implementations are available here:</p>
<ul>
<li><a href="./gallery/plasticity/DruckerPerfectPlasticity_Cazacu2001.mfront">DruckerPerfectPlasticity_Cazacu2001.mfront</a>.</li>
<li><a href="./gallery/plasticity/OrthotropicDruckerPerfectPlasticity2090T3_Cazacu2001.mfront">OrthotropicDruckerPerfectPlasticity2090T3_Cazacu2001.mfront</a></li>
<li><a href="./gallery/plasticity/OrthotropicDruckerPerfectPlasticityYdLin6016T4_Cazacu2001.mfront">OrthotropicDruckerPerfectPlasticityYdLin6016T4_Cazacu2001.mfront</a></li>
</ul>
<h1 id="description">Description</h1>
<h2 id="elasticity">Elasticity</h2>
<p>The elasticity is assumed linear and isotropic, i.e. given by the Hooke law: <span class="math display">\[
\underline{\sigma}=\lambda\,{\mathrm{tr}{\left(\underline{\varepsilon}^{\mathrm{el}}\right)}}\,\underline{I}+2\,\mu\,\underline{\varepsilon}^{\mathrm{el}}
\]</span> where <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\mu\)</span> are the first and second Lamé parameters.</p>
<h2 id="plasticity">Plasticity</h2>
<p>The yield surface is chosen as follows: <span class="math display">\[
f{\left(\underline{\sigma}\right)}=\sigma_{\mathrm{eq}}^{D}-\sigma_{Y}
\]</span> where:</p>
<ul>
<li><span class="math inline">\(\sigma_{\mathrm{eq}}^{D}\)</span> is the Drucker yield criterion defined hereafter.</li>
<li>The yield stress <span class="math inline">\(\sigma_{Y}\)</span> is a constant material parameter.</li>
</ul>
<p>The Drucker yield criterion is defined by (<span class="citation" data-cites="drucker_relation_1949">Drucker (1949)</span>): <span class="math display">\[
\sigma_{\mathrm{eq}}^{D}=\sqrt{3}\,{\left(J_{2}^{3}-c\,J_{3}^2\right)}^{\tfrac{1}{6}}
\]</span> where <span class="math inline">\(J_{2}\)</span> and <span class="math inline">\(J_{3}\)</span> are the invariants of <span class="math inline">\(\underline{s}\)</span> the deviatoric part of the stress tensor which are defined as follows: <span class="math display">\[
\left\{
\begin{aligned}
\underline{s} &amp;= \underline{\sigma}-{{\displaystyle \frac{\displaystyle 1}{\displaystyle 3}}}\,{\mathrm{tr}{\left(\underline{\sigma}\right)}}\,\underline{I}\\
J_2 &amp;= {{\displaystyle \frac{\displaystyle 1}{\displaystyle 2}}}\,\underline{s}\,\colon\,\underline{s} \\
J_3 &amp;= \det{\left(\underline{s}\right)} \\
\end{aligned}
\right.
\]</span></p>
<p>The Drucker stress is an isotropic homogeneous function of degree 1. The flow rule is assumed associated and the plastic strain rate <span class="math inline">\(\underline{\dot{\varepsilon}}^{\mathrm{p}}\)</span> is given by: <span class="math display">\[
\underline{\dot{\varepsilon}}^{\mathrm{p}}=\dot{p}\,{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial \underline{\sigma}}}=\dot{p}\,\underline{n}^{D}
\]</span> where <span class="math inline">\(\dot{p}\)</span> is the rate of the equivalent plastic strain <span class="math inline">\(p\)</span>.</p>
<h2 id="derivatives-of-the-equivalent-stress">Derivatives of the equivalent stress</h2>
<p>In the following, the first and second derivatives of the equivalent stress with respect to the stress <span class="math inline">\(\underline{\sigma}\)</span> will be required.</p>
<h3 id="first-derivative-of-the-equivalent-stress">First derivative of the equivalent stress</h3>
<p>The first derivative of the equivalent stress <span class="math inline">\(\sigma_{\mathrm{eq}}^{D}\)</span> with with respect to the stress <span class="math inline">\(\underline{\sigma}\)</span> are readily obtained by chain rule: <span class="math display">\[
{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial \underline{\sigma}}}={\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{2}}}\,{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \underline{\sigma}}}+{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{3}}}\,{\displaystyle \frac{\displaystyle \partial J_{3}}{\displaystyle \partial \underline{\sigma}}},
\]</span></p>
<p>The first derivatives of the Drucker equivalent stress <span class="math inline">\(\sigma_{\mathrm{eq}}^{D}\)</span> with respect <span class="math inline">\(J_{2}\)</span> and <span class="math inline">\(J_{3}\)</span> are given by the following formulae:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{2}}}&amp;={{\displaystyle \frac{\displaystyle J_{2}^{2}}{\displaystyle 2\,{\left(J_{2}^{3}-c\,J_{3}^{2}\right)}}}}\,\sigma_{\mathrm{eq}}^{D}\\
{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{3}}}&amp;={{\displaystyle \frac{\displaystyle -c\,J_{3}}{\displaystyle 3\,{\left(J_{2}^{3}-c\,J_{3}^{2}\right)}}}}\,\sigma_{\mathrm{eq}}^{D}\\
\end{aligned}
\right.
\]</span></p>
<p>The derivative of <span class="math inline">\(J_{2}\)</span> with respect to <span class="math inline">\(\underline{\sigma}\)</span> is trivial: <span class="math display">\[
{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \sigma}}=\underline{s}
\]</span></p>
<p>The derivative of <span class="math inline">\(J_{2}\)</span> with respect to <span class="math inline">\(\underline{\sigma}\)</span> can be computed using the <code>computeJ3Derivative</code> function, which is available since <code>TFEL</code> version <code>3.2</code>.</p>
<p>See <a href="tensors.html">this page</a> for details.</p>
<h3 id="second-derivative-of-the-equivalent-stress">Second derivative of the equivalent stress</h3>
<p>The second derivative of the equivalent stress can also be obtained by chain rule:</p>
<p><span class="math display">\[
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial \underline{\sigma}^{2}}}=&amp;
{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{2}^{2}}}\,{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \underline{\sigma}}}\,\otimes\,{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \underline{\sigma}}}+{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{2}}}\,{\displaystyle \frac{\displaystyle \partial^{2} J_{2}}{\displaystyle \partial \underline{\sigma}^{2}}}+\\
&amp;{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{3}^{2}}}\,{\displaystyle \frac{\displaystyle \partial J_{3}}{\displaystyle \partial \underline{\sigma}}}\,\otimes\,{\displaystyle \frac{\displaystyle \partial J_{3}}{\displaystyle \partial \underline{\sigma}}}+{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{3}}}\,{\displaystyle \frac{\displaystyle \partial^{2} J_{3}}{\displaystyle \partial \underline{\sigma}^{2}}}+\\
&amp;{{\displaystyle \frac{\displaystyle \partial^{2}\sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial\,J_{2}\,\partial\,J_{3}}}}\,\left[{\displaystyle \frac{\displaystyle \partial J_{3}}{\displaystyle \partial \underline{\sigma}}}\,\otimes\,{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \underline{\sigma}}}+{\displaystyle \frac{\displaystyle \partial J_{2}}{\displaystyle \partial \underline{\sigma}}}\,\otimes\,{\displaystyle \frac{\displaystyle \partial J_{3}}{\displaystyle \partial \underline{\sigma}}}\right]
\end{aligned}
\]</span></p>
<p>The second derivatives of the Drucker equivalent stress <span class="math inline">\(\sigma_{\mathrm{eq}}^{D}\)</span> with respect <span class="math inline">\(J_{2}\)</span> and <span class="math inline">\(J_{3}\)</span> are given by the following formulae:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{2}^{2}}}&amp;=
{{\displaystyle \frac{\displaystyle -4\,c\,J_{2}\,J_{3}^{2}-J_{2}^{4}}{\displaystyle 4\,c^{2}\,J_{3}^{4}-8\,c\,J_{2}^{3}\,J_{3}^{2}+4\,J_{2}^{6}}}}\,\sigma_{\mathrm{eq}}^{D}\\
{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial J_{3}^{2}}}&amp;=
{{\displaystyle \frac{\displaystyle -2\,c^{2}\,J_{3}^{2}-3\,\,c\,J_{2}^{3}}{\displaystyle 9\,c^{2}\,J_{3}^{4}-18\,c\,J_{2}^{3}\,J_{3}^{2}+9\,J_{2}^{6}}}}\,\sigma_{\mathrm{eq}}^{D}\\
{{\displaystyle \frac{\displaystyle \partial^{2}\,\sigma_{\mathrm{eq}}^{D}}{\displaystyle \partial\,J_{2}\,\partial\,J_{3}}}}&amp;=
{{\displaystyle \frac{\displaystyle 5\,c\,J_{2}^{2}\,J_{3}}{\displaystyle 6\,c^{2}\,J_{3}^{4}-12\,c\,J_{2}^{3}\,J_{3}^{2}+6\,J_{2}^{6}}}}\,\sigma_{\mathrm{eq}}^{D}\\
\end{aligned}
\right.
\]</span></p>
<p>The second derivative of <span class="math inline">\(J_{2}\)</span> is trivial: <span class="math display">\[
{\displaystyle \frac{\displaystyle \partial^{2} J_{2}}{\displaystyle \partial \underline{\sigma}^{2}}}=\underline{\underline{\mathbf{I}}}-{{\displaystyle \frac{\displaystyle 1}{\displaystyle 3}}}\,\underline{I}\,\otimes\,\underline{I}
\]</span></p>
<p>The second derivative of <span class="math inline">\(J_{3}\)</span> can be computed using the <code>computeJ3SecondDerivative</code> function.</p>
<blockquote>
<p><strong>Notes</strong></p>
<p>Another approach is to express explicitly the equivalent stress and to compute the previous derivatives explicitly. This approach is more cumbersome and one have to take care of:</p>
<ul>
<li>The conventions used by <code>TFEL</code> to represent symmetric tensors as vectors (see <a href="tensors.html">this page</a> for details).</li>
<li>Providing specializations for every supported space dimension (<span class="math inline">\(1D\)</span>, <span class="math inline">\(2D\)</span> or <span class="math inline">\(3D\)</span>).</li>
</ul>
<p>This is the approach used most of the time by the <code>TFEL</code> developpers to provide optimised versions. One can refer to the implementation of the <code>computeJ3Derivative</code> and <code>computeJ3SecondDerivative</code> for concrete example. Those functions are declared in the <code>IsotropicPlasticity.hxx</code> header and implemented in the <code>IsotropicPlasticity.ixx</code> file. Those headers are explicitly included in the code generated by <code>MFront</code>.</p>
<p>Note that for the extension to orthotropy we will use various functions (<code>computeJ20</code>, <code>computeJ20Derivative</code>, etc.) that have also been implemented by this approach. Those functions are declared in the <code>OrthotropicPlasticity.hxx</code> header and implemented in the <code>OrthotropicPlasticity.ixx</code> file. Those headers are explicitly included in the code generated by <code>MFront</code> for orthotropic behaiours.</p>
<p>We did not take this approach here for two reasons:</p>
<ul>
<li>Most users will have to deal with the existing functions.</li>
<li>The extension to orthotropy will be straightforward.</li>
</ul>
</blockquote>
<h1 id="implicit-scheme">Implicit scheme</h1>
<h2 id="choice-of-the-state-variables">Choice of the state variables</h2>
<p>The behaviour is integrated by an implicit scheme. Two state variables are introduced:</p>
<ul>
<li>the elastic strain <span class="math inline">\(\underline{\varepsilon}^{\mathrm{el}}\)</span>.</li>
<li>the equivalent plastic strain <span class="math inline">\(p\)</span>.</li>
</ul>
<p>The elastic strain is automatically defined by the <code>Implicit</code> domain specific language.</p>
<p>The latter could be considered as an integration variable, but, for post-processing purposes, we choose to keep it as a state variable.</p>
<h2 id="elastic-prediction">Elastic prediction</h2>
<p>First, an elastic prediction of the stress <span class="math inline">\(\underline{\sigma}^{\mathrm{tr}}\)</span> is made (The following expression is not valid in plane stress hypothesis, see below): <span class="math display">\[
\underline{\sigma}^{\mathrm{tr}}=\lambda\,{\mathrm{tr}{\left({\left.\underline{\varepsilon}^{\mathrm{el}}\right|_{t}}+\theta\,\Delta\,\underline{\varepsilon}^{\mathrm{to}}\right)}}\,\underline{I}+2\,\mu\,{\left({\left.\underline{\varepsilon}^{\mathrm{el}}\right|_{t}}+\theta\,\Delta\,\underline{\varepsilon}^{\mathrm{to}}\right)} \]</span></p>
<ul>
<li>If the predicted stress is inside the elastic domain, no plastic flow occurs.</li>
<li>Otherwise, the material state at the end of the time step lies on the yield surface.</li>
</ul>
<h2 id="equation-assciated-with-the-elastic-strain">Equation assciated with the elastic strain</h2>
<p>The equation associated with the evolution of the elastic strain is given by the split of strain: <span class="math display">\[
f_{\underline{\varepsilon}^{\mathrm{el}}}=\Delta\,\underline{\varepsilon}^{\mathrm{el}}-\Delta\,\underline{\varepsilon}^{\mathrm{to}}+\Delta\,p\,{\left.\underline{n}^{D}\right|_{t+\theta\,\Delta\,t}}
\]</span></p>
<p>The derivatives of this equation with respect to <span class="math inline">\(\Delta\,\underline{\varepsilon}^{\mathrm{el}}\)</span> and <span class="math inline">\(\Delta\,p\)</span> are given by:</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial f_{\underline{\varepsilon}^{\mathrm{el}}}}{\displaystyle \partial \Delta\,\underline{\varepsilon}^{\mathrm{el}}}} &amp;= \underline{\underline{\mathbf{I}}}+2\,\mu\,\theta\,\Delta\,p\,{\displaystyle \frac{\displaystyle \partial {\left.\underline{n}^{D}\right|_{t+\theta\,\Delta\,t}}}{\displaystyle \partial {\left.\underline{\sigma}\right|_{t+\theta\,\Delta\,t}}}}\\
{\displaystyle \frac{\displaystyle \partial f_{\underline{\varepsilon}^{\mathrm{el}}}}{\displaystyle \partial \Delta\, p}} &amp;= {\left.\underline{n}^{D}\right|_{t+\theta\,\Delta\,t}}\\
\end{aligned}
\right.
\]</span></p>
<h2 id="equation-governing-the-material-evolution-under-plastic-loading">Equation governing the material evolution under plastic loading</h2>
<p>To determine the equivalent plastic strain increment, the following equation must be satisfied: <span class="math display">\[
f_{p}={\left.\sigma_{\mathrm{eq}}^{D}\right|_{t+\theta\,\Delta\,t}}-\sigma_{Y}=0
\]</span></p>
<p>In the implementation described below, this equation will be normalised by the Young modulus to ensure that all equations have the same magnitude.</p>
<p>The derivatives of this equation with respect to <span class="math inline">\(\Delta\,\underline{\varepsilon}^{\mathrm{el}}\)</span> and <span class="math inline">\(\Delta\,p\)</span> are given by: <span class="math display">\[
\left\{
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial f_{p}}{\displaystyle \partial \Delta\,\underline{\varepsilon}^{\mathrm{el}}}} &amp;= 2\,\mu\,\theta\,{\left.\underline{n}^{D}\right|_{t+\theta\,\Delta\,t}}\\
{\displaystyle \frac{\displaystyle \partial f_{p}}{\displaystyle \partial \Delta\,p}}           &amp;= 0\\
\end{aligned}
\right.
\]</span></p>
<h1 id="implementation">Implementation</h1>
<h2 id="metadata">Metadata</h2>
<p>The beginning of the file gives some information about the behaviour:</p>
<ul>
<li>the integration scheme used, selected by the <code>@DSL</code> keyword.</li>
<li>the name of the behaviour, introduced by the <code>@Behaviour</code> keyword.</li>
<li>the author of the implementation (<code>@Author</code>).</li>
<li>a small description of the behaviour (<code>@Description</code>).</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="er">@</span>DSL       Implicit;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="er">@</span>Behaviour DruckerPerfectPlasticity;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="er">@</span>Author    Thomas Helfer;</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="er">@</span>Description{</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  A simple implementation of a perfect</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  plasticity behaviour <span class="kw">using</span> the</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  Drucker stress.</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">};</a></code></pre></div>
<h2 id="supported-modelling-hypothesis">Supported modelling hypothesis</h2>
<p>Thanks to the <code>StandardElasticity</code> brick, all the modelling hypotheses can be supported. The following statement, starting with the <code>@ModellingHypotheses</code>, enables all the modelling hypotheses:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="er">@</span>ModellingHypotheses {<span class="st">&quot;.+&quot;</span>};</a></code></pre></div>
<h2 id="the-standard-elasticity-brick">The standard elasticity brick</h2>
<p>To implement this behaviour, we will use the <code>StandardElasticity</code> brick which provides:</p>
<ul>
<li>Automatic computation of the stress tensor at various stages of the behaviour integration.</li>
<li>Automatic computation of the consistent tangent operator.</li>
<li>Automatic support for plane stress and generalized plane stress modelling hypotheses (The axial strain is defined as an additional state variable and the associated equation in the implicit system is added to enforce the plane stess condition).</li>
<li>Automatic addition of the standard terms associated with the elastic strain state variable.</li>
</ul>
<p>This behaviour brick is fully described <a href="BehaviourBricks.html">here</a>.</p>
<p>The usage of the <code>StandardElasticity</code> is introduced as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="er">@</span>Brick StandardElasticity;</a></code></pre></div>
<h2 id="numerical-parameters">Numerical parameters</h2>
<p>The following part of file give some default values for numerical parameters used by the integration algorithm:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="er">@</span>Epsilon <span class="dv">1</span>.e<span class="dv">-16</span>;</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="er">@</span>Theta <span class="dv">1</span>;</a></code></pre></div>
<h2 id="state-variables">State variables</h2>
<p>The elastic strain is automatically declared the <code>StandardElasticity</code> brick. The associated variable is <code>eel</code>.</p>
<p>The following statement introduces the equivalent plastic strain named <code>p</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="er">@</span>StateVariable strain p;</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">p.setGlossaryName(<span class="st">&quot;EquivalentPlasticStrain&quot;</span>);</a></code></pre></div>
<h2 id="material-constants">Material constants</h2>
<p>The material properties are hard-coded. The <code>@ElasticMaterialProperties</code> is used to declare the Young modulus and the Poisson ratio.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="er">@</span>ElasticMaterialProperties {<span class="fl">150e9</span>,<span class="fl">0.3</span>};</a></code></pre></div>
<p>In the <code>Implicit</code> scheme, the lame coefficients are automatically deduced from the Young modulus and the Poisson ratio. They are accessible though the <code>lambda</code> and <code>mu</code> local variables which are automatically defined.</p>
<p>The parameters associated with the plastic part of the behaviour are defined as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="er">@</span>Parameter c    = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">c.setEntryName(<span class="st">&quot;DruckerCoefficient&quot;</span>);</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="er">@</span>Parameter sigy = <span class="fl">150e6</span>;</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">c.setEntryName(<span class="st">&quot;YieldStrength&quot;</span>);</a></code></pre></div>
<h2 id="local-variable-declaration">Local variable declaration</h2>
<p>A boolean <code>b</code> is declared as a local variable.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="er">@</span>LocalVariable <span class="dt">bool</span> b;</a></code></pre></div>
<p>This boolean will be <code>true</code> if plastic loading occurs.</p>
<h2 id="local-variable-initialization">Local variable initialization</h2>
<p>The main goal of the local variable initialization is to test if the elastic prediction of the stress lies inside the yield surface.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="er">@</span>InitializeLocalVariables{</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> e = real(<span class="dv">1</span>)/<span class="dv">6</span>;</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> sqrt3 = Cste&lt;real&gt;::sqrt3;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="at">const</span> <span class="kw">auto</span> sigel = computeElasticPrediction();</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="at">const</span> <span class="kw">auto</span> sel   = deviator(sigel);</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="at">const</span> <span class="kw">auto</span> J2    = (sel|sel)/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="at">const</span> <span class="kw">auto</span> J3    = det(sel);</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="at">const</span> <span class="kw">auto</span> seqel = sqrt3*pow(J2*J2*J2-c*J3*J3,e);</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  b = seqel&gt;sigy;</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">}</a></code></pre></div>
<p>The <code>computeElasticPrediction</code> method, provided by the <code>StandardElasticity</code> brick, computes the elastic prediction of the stress and takes into account the modelling hypothesis. This prediction is thus valid under the plane stress hypothesis.</p>
<p>At the last line, the boolean variable <code>b</code> is set to <code>true</code> if the elastic prediction of the Drucker stress exceeds the yield stress.</p>
<h2 id="implicit-system">Implicit system</h2>
<p>The code describing the implicit system is rather short:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="er">@</span>Integrator{</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> e = real(<span class="dv">1</span>)/<span class="dv">6</span>;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> sqrt3 = Cste&lt;real&gt;::sqrt3;</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="at">const</span> stress seps = <span class="dv">1</span>.e<span class="dv">-10</span>*young;</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="cf">if</span>(!b){</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="co">// elastic loading, nothing to be done</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> id  = Stensor::Id();</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> id4 = Stensor4::Id();</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  <span class="at">const</span> <span class="kw">auto</span>  s    = deviator(sig);</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">  <span class="at">const</span> <span class="kw">auto</span>  J2   = (s|s)/<span class="dv">2</span>;</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">  <span class="cf">if</span>(J2&gt;seps*seps){</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">    <span class="at">const</span> <span class="kw">auto</span>  J2_2 = J2*J2;</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">    <span class="at">const</span> <span class="kw">auto</span>  J2_3 = J2_2*J2;</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">    <span class="at">const</span> <span class="kw">auto</span>  J2_4 = J2_2*J2_2;</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    <span class="at">const</span> <span class="kw">auto</span>  J2_6 = J2_4*J2_2;</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="at">const</span> <span class="kw">auto</span>  J3   = det(s);</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">    <span class="at">const</span> <span class="kw">auto</span>  J3_2 = J3*J3;</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    <span class="at">const</span> <span class="kw">auto</span>  J3_4 = J3_2*J3_2;</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">    <span class="at">const</span> <span class="kw">auto</span>&amp; dJ2  = s;</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    <span class="at">const</span> <span class="kw">auto</span>  d2J2 = eval(id4-(id^id)/<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    <span class="at">const</span> <span class="kw">auto</span>  dJ3  = computeJ3Derivative(sig);</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">    <span class="at">const</span> <span class="kw">auto</span>  d2J3 = computeJ3SecondDerivative(sig);</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">    <span class="at">const</span> <span class="kw">auto</span>  s6   = J2_3-c*J3_2;</a>
<a class="sourceLine" id="cb10-26" data-line-number="26">    <span class="at">const</span> <span class="kw">auto</span>  seq  = sqrt3*pow(s6,e);</a>
<a class="sourceLine" id="cb10-27" data-line-number="27">    <span class="at">const</span> <span class="kw">auto</span>  dseq_dJ2 = J2_2/(<span class="dv">2</span>*s6)*seq;</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">    <span class="at">const</span> <span class="kw">auto</span>  dseq_dJ3 = -c*J3/(<span class="dv">3</span>*s6)*seq;</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    <span class="at">const</span> <span class="kw">auto</span>  n  = dseq_dJ2*dJ2+dseq_dJ3*dJ3;</a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    <span class="at">const</span> <span class="kw">auto</span>  d2seq_dJ2dJ2 =</a>
<a class="sourceLine" id="cb10-31" data-line-number="31">      seq*(<span class="dv">-4</span>*J2*J3_2*c-J2_4)/(<span class="dv">4</span>*J3_4*c*c<span class="dv">-8</span>*J2_3*J3_2<span class="dv">+4</span>*J2_6);</a>
<a class="sourceLine" id="cb10-32" data-line-number="32">    <span class="at">const</span> <span class="kw">auto</span>  d2seq_dJ3dJ3 =</a>
<a class="sourceLine" id="cb10-33" data-line-number="33">      seq*(<span class="dv">-2</span>*J3_2*c*c<span class="dv">-3</span>*J2_3*c)/(<span class="dv">9</span>*J3_4*c*c<span class="dv">-18</span>*J2_3*J3_2<span class="dv">+9</span>*J2_6);</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">    <span class="at">const</span> <span class="kw">auto</span>  d2seq_dJ2dJ3 =</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">      seq*(<span class="dv">5</span>*J2_2*J3*c)/(<span class="dv">6</span>*J3_4*c*c<span class="dv">-12</span>*J2_3*J3_2<span class="dv">+6</span>*J2_6);</a>
<a class="sourceLine" id="cb10-36" data-line-number="36">    <span class="co">// d2f=f*d(df/f)+df*df/f</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37">    <span class="at">const</span> <span class="kw">auto</span>  dn = eval(d2seq_dJ2dJ2*(dJ2^dJ2)+</a>
<a class="sourceLine" id="cb10-38" data-line-number="38">              dseq_dJ2*d2J2+</a>
<a class="sourceLine" id="cb10-39" data-line-number="39">              d2seq_dJ2dJ3*((dJ2^dJ3)+(dJ3^dJ2))+</a>
<a class="sourceLine" id="cb10-40" data-line-number="40">              d2seq_dJ3dJ3*(dJ3^dJ3)+</a>
<a class="sourceLine" id="cb10-41" data-line-number="41">              dseq_dJ3*d2J3);</a>
<a class="sourceLine" id="cb10-42" data-line-number="42">    feel        += dp*n;</a>
<a class="sourceLine" id="cb10-43" data-line-number="43">    dfeel_ddeel += <span class="dv">2</span>*mu*theta*dp*dn;</a>
<a class="sourceLine" id="cb10-44" data-line-number="44">    dfeel_ddp    = n;</a>
<a class="sourceLine" id="cb10-45" data-line-number="45">    fp           = (seq-s0)/young;</a>
<a class="sourceLine" id="cb10-46" data-line-number="46">    dfp_ddeel    = <span class="dv">2</span>*mu*theta*n/young;</a>
<a class="sourceLine" id="cb10-47" data-line-number="47">    dfp_ddp      = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-48" data-line-number="48">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb10-49" data-line-number="49">    <span class="co">// This case can happen for example at the first time step if the</span></a>
<a class="sourceLine" id="cb10-50" data-line-number="50">    <span class="co">// elastic prediction directly leads to a plastic loading: at the</span></a>
<a class="sourceLine" id="cb10-51" data-line-number="51">    <span class="co">// first iteration the stress is still zero.</span></a>
<a class="sourceLine" id="cb10-52" data-line-number="52">    fp           = -s0/young;</a>
<a class="sourceLine" id="cb10-53" data-line-number="53">    <span class="co">// this is arbitrary, but this avoids</span></a>
<a class="sourceLine" id="cb10-54" data-line-number="54">    <span class="co">// a singularity in the  jacobian</span></a>
<a class="sourceLine" id="cb10-55" data-line-number="55">    dfp_ddp      = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb10-56" data-line-number="56">  }</a>
<a class="sourceLine" id="cb10-57" data-line-number="57">}</a></code></pre></div>
<p>It shall be noted that, at the beginning of this code block:</p>
<ul>
<li><code>feel</code> has been initialized to <span class="math inline">\(\Delta\,\underline{\varepsilon}^{\mathrm{el}}-\Delta\,\underline{\varepsilon}^{\mathrm{to}}\)</span> by the <code>StandardElasticity</code> brick</li>
<li><code>fp</code> has been initialized to <span class="math inline">\(\Delta\,p\)</span> following standard conventions defined in the the <code>Implicit</code> domain specific language.</li>
<li>the jacobian has been set to identity, following standard conventions defined in the <code>Implicit</code> domain specific language.</li>
</ul>
<p>Thus, all the variables have been set to describe a purely elastic behaviour. Hence, nothing is to be done if the boolean variable <code>b</code> is <code>false</code>. In this case, one just return <code>true</code>.</p>
<h1 id="a-first-extension-to-orthotropy-cazacu_generalization_2001">A first Extension to orthotropy (<span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>)</h1>
<p>Within the framework of the theory of representation, generalizations to orthotropic conditions of the invariants of the deviatoric stress have been proposed by Cazacu and Barlat (see <span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>):</p>
<ul>
<li>The generalization of <span class="math inline">\(J_{2}\)</span> is denoted <span class="math inline">\(J_{2}^{O}\)</span>. It is defined by: <span class="math display">\[
J_{2}^{O}= a_6\,s_{yz}^2+a_5\,s_{xz}^2+a_4\,s_{xy}^2+\frac{a_2}{6}\,(s_{yy}-s_{zz})^2+\frac{a_3}{6}\,(s_{xx}-s_{zz})^2+\frac{a_1}{6}\,(s_{xx}-s_{yy})^2
\]</span> where the <span class="math inline">\(\left.a_{i}\right|_{i\in[1:6]}\)</span> are six coefficients describing the orthotropy of the material.</li>
<li>The generalization of <span class="math inline">\(J_{3}\)</span> is denoted <span class="math inline">\(J_{3}^{O}\)</span>. It is defined by: <span class="math display">\[
\begin{aligned}
J_{3}^{O}=
&amp;\frac{1}{27}\,(b_1+b_2)\,s_{xx}^3+\frac{1}{27}\,(b_3+b_4)\,s_{yy}^3+\frac{1}{27}\,(2\,(b_1+b_4)-b_2-b_3)\,s_{zz}^3\\
&amp;-\frac{1}{9}\,(b_1\,s_{yy}+b_2s_{zz})\,s_{xx}^2\\
&amp;-\frac{1}{9}\,(b_3\,s_{zz}+b_4\,s_{xx})\,s_{yy}^2\\
&amp;-\frac{1}{9}\,((b_1-b_2+b_4)\,s_{xx}+(b_1-b3+b_4)\,s_{yy})\,s_{zz}^3\\
&amp;+\frac{2}{9}\,(b_1+b_4)\,s_{xx}\,s_{yy}\,s_{zz}\\
&amp;-\frac{s_{xz}^2}{3}\,(2\,b_9\,s_{yy}-b_8\,s_{zz}-(2\,b_9-b_8)\,s_{xx})\\
&amp;-\frac{s_{xy}^2}{3}\,(2\,b_{10}\,s_{zz}-b_5\,s_{yy}-(2\,b_{10}-b_5)\,s_{xx})\\
&amp;-\frac{s_{yz}^2}{3}\,((b_6+b_7)\,s_{xx}-b_6\,s_{yy}-b_7\,s_{zz})\\
&amp;+2\,b_{11}\,s_{xy}\,s_{xz}\,s_{yz}
\end{aligned}
\]</span> where the <span class="math inline">\(\left.b_{i}\right|_{i\in[1:11]}\)</span> are eleven coefficients describing the orthotropy of the material.</li>
</ul>
<p>Those invariants may be used to generalize isotropic yield criteria based on <span class="math inline">\(J_{2}\)</span> and <span class="math inline">\(J_{3}\)</span> invariants to orthotropy.</p>
<p><span class="math inline">\(J_{2}^{0}\)</span>, <span class="math inline">\(J_{3}^{0}\)</span> and their first and second derivatives with respect to the stress tensor <span class="math inline">\(\underline{\sigma}\)</span> can be computed by the following functions:</p>
<ul>
<li><code>computesJ2O</code>, <code>computesJ2ODerivative</code> and <code>computesJ2OSecondDerivative</code>.</li>
<li><code>computesJ3O</code>, <code>computesJ3ODerivative</code> and <code>computesJ3OSecondDerivative</code>.</li>
</ul>
<p>Those functions take the stress tensor as first argument and each orthotropic coefficients. Each of those functions has an overload taking the stress tensor as its firs arguments and a tiny vector (<code>tfel::math::tvector</code>) containing the orthotropic coefficients.</p>
<p>Using those invariants, building a new yield criterion is quite straight-forward:</p>
<p><span class="math display">\[
\sigma_{\mathrm{eq}}^{D,O}=\sqrt{3}\,{\left({\left(J_{2}^{O}\right)}^{3}-c\,{\left(J_{3}^{O}\right)}^2\right)}^{\tfrac{1}{6}}
\]</span></p>
<h2 id="verification">Verification</h2>
<figure>
<img src="img/Cazacu2001_2090-T3.svg" title="Plane stress yield surface ((\sigma_{xy}=0) and (\sigma_{xy}=0.45,\sigma_{0})) of 2090-T3 alloy sheet as predicted by the generalization of the Drucker yield criterion using generalized invariants (See @cazacu_generalization_2001, Figure 3)" alt="Plane stress yield surface (\sigma_{xy}=0 and \sigma_{xy}=0.45\,\sigma_{0}) of 2090-T3 alloy sheet as predicted by the generalization of the Drucker yield criterion using generalized invariants (See Cazacu and Barlat (2001), Figure 6)." style="width:80.0%" /><figcaption>Plane stress yield surface (<span class="math inline">\(\sigma_{xy}=0\)</span> and <span class="math inline">\(\sigma_{xy}=0.45\,\sigma_{0}\)</span>) of 2090-T3 alloy sheet as predicted by the generalization of the Drucker yield criterion using generalized invariants (See <span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>, Figure 6).</figcaption>
</figure>
<h1 id="a-second-extension-to-orthotropy-barlat_linear_2007">A second extension to orthotropy (<span class="citation" data-cites="barlat_linear_2007">Barlat, Yoon, and Cazacu (2007)</span>)</h1>
<p>Another approach is to introduce a linear transformation of the stress, as follows: <span class="math display">\[
\underline{s&#39;}=\underline{\underline{\mathbf{L}}}\,\colon\,\underline{\sigma}
\]</span></p>
<p>The linear transformation <span class="math inline">\(\underline{\underline{\mathbf{L}}}\)</span> are defined by <span class="math inline">\(9\)</span> coefficients (each) which describe the material orthotropy. There are defined through auxiliary linear transformation <span class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> as follows: <span class="math display">\[
\underline{\underline{\mathbf{L}}} =\underline{\underline{\mathbf{C}}}\,\colon\,\underline{\underline{\mathbf{M}}}
\]</span> where <span class="math inline">\(\underline{\underline{\mathbf{M}}}\)</span> is the transformation of the stress to its deviator: <span class="math display">\[
\underline{\underline{\mathbf{M}}}=\underline{\underline{\mathbf{I}}}-{{\displaystyle \frac{\displaystyle 1}{\displaystyle 3}}}\underline{I}\,\otimes\,\underline{I}
\]</span></p>
<p>The linear transformation <span class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> of the deviator stress is defined as follows: <span class="math display">\[
\underline{\underline{\mathbf{C}}}=
\begin{pmatrix}
0 &amp; -c_{12} &amp; -c_{13} &amp; 0 &amp; 0 &amp; 0 \\
-c_{21} &amp; 0 &amp; -c_{23} &amp; 0 &amp; 0 &amp; 0 \\
-c_{31} &amp; -c_{32} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; c_{44} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; c_{55} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; c_{66} \\
\end{pmatrix}
\]</span></p>
<p>Another equivalent stress can then be defined, as follows:</p>
<p><span class="math display">\[
\sigma_{\mathrm{eq}}^{D,OL}=\sqrt{3}\,{\left({\left(J_{2}&#39;\right)}^{3}-c\,{\left(J_{3}&#39;\right)}^2\right)}^{\tfrac{1}{6}}
\]</span></p>
<p>where <span class="math inline">\(J_{2}&#39;\)</span> and <span class="math inline">\(J_{3}&#39;\)</span> are the invariants associated with <span class="math inline">\(\underline{s&#39;}\)</span></p>
<p>The implementation is here made straight-forward because of the following relations: <span class="math display">\[
\left\{
\begin{aligned}
{\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{\sigma}}}&amp;={\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{s}&#39;}}\,\colon\,\underline{\underline{\mathbf{L}}} \\
{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{\sigma}^{2}}}&amp;={\underline{\underline{\mathbf{L}}}^{\mathrm{T}}}\,\cdot\,{\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{s}&#39;^{2}}}\,\cdot\,\underline{\underline{\mathbf{L}}} \\
\end{aligned}
\right.
\]</span></p>
<p>The expressions of <span class="math inline">\({\displaystyle \frac{\displaystyle \partial \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{s}&#39;}}\)</span> and <span class="math inline">\({\displaystyle \frac{\displaystyle \partial^{2} \sigma_{\mathrm{eq}}^{D,OL}}{\displaystyle \partial \underline{s}&#39;^{2}}}\)</span> are the obtained from the isotropic case by replacing <span class="math inline">\(\underline{\sigma}\)</span> with <span class="math inline">\(\underline{s}&#39;\)</span>, which is trivial to implement on the basis of the isotropic implementation described in the beginning of this document.</p>
<h2 id="verification-1">Verification</h2>
<figure>
<img src="img/Cazacu2001_6016-T4-YdLin.svg" title="Plane stress yield surface ((\sigma_{xy}=0)) of 6016-T4 alloy sheet as predicted by the generalization of the Drucker yield criterion using a linear transformation (See @cazacu_generalization_2001, Figure 3)" alt="Plane stress yield surface (\sigma_{xy}=0) of 6016-T4 alloy sheet as predicted by the generalization of the Drucker yield criterion using a linear transformation (See Cazacu and Barlat (2001), Figure 3)." style="width:80.0%" /><figcaption>Plane stress yield surface (<span class="math inline">\(\sigma_{xy}=0\)</span>) of 6016-T4 alloy sheet as predicted by the generalization of the Drucker yield criterion using a linear transformation (See <span class="citation" data-cites="cazacu_generalization_2001">Cazacu and Barlat (2001)</span>, Figure 3).</figcaption>
</figure>
<h1 id="references">References</h1>
<!-- Local IspellDict: english -->
<div id="refs" class="references">
<div id="ref-barlat_linear_2007">
<p>Barlat, Frédéric, Jeong Whan Yoon, and Oana Cazacu. 2007. “On Linear Transformations of Stress Tensors for the Description of Plastic Anisotropy.” <em>International Journal of Plasticity</em> 23 (5): 876–96. <a href="https://doi.org/10.1016/j.ijplas.2006.10.001" class="uri">https://doi.org/10.1016/j.ijplas.2006.10.001</a>.</p>
</div>
<div id="ref-cazacu_generalization_2001">
<p>Cazacu, Oana, and Frédéric Barlat. 2001. “Generalization of Drucker’s Yield Criterion to Orthotropy.” <em>Mathematics and Mechanics of Solids</em> 6 (6): 613–30. <a href="https://doi.org/10.1177/108128650100600603" class="uri">https://doi.org/10.1177/108128650100600603</a>.</p>
</div>
<div id="ref-drucker_relation_1949">
<p>Drucker, Daniel Charles. 1949. “Relation of Experiments to Mathematical Theories of Plasticity.” <em>Journal of Applied Mechanics</em>, no. 16: 349–57.</p>
</div>
</div>
        <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
